{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Bem vindo disciplina de Elementos de Sistemas! \u00b6 Curso: Engenharia Da Computa\u00e7\u00e3o - Terceiro semestre Disciplina: Elementos de Sistemas Insper - 2019-2. Prof. Rafael Corsi / rafael.corsi@insper.edu.br Reposit\u00f3rio: http:/github.com/Insper/Z01.1 Local: Laborat\u00f3rio de Inform\u00e1tica - 404 \u00a9 Todos os direitos reservados Objetivos de aprendizagem \u00b6 Ao final da disciplina o estudante ser\u00e1 capaz de: Implementar um computador digital simples a partir de componentes eletr\u00f4nicos. Integrar as camadas de programa\u00e7\u00e3o e execu\u00e7\u00e3o de um computador simples. Trabalhar de forma colaborativa no desenvolvimento de um sistema computacional. Compreender a evolu\u00e7\u00e3o da inform\u00e1tica. Descrever como dados e instru\u00e7\u00f5es s\u00e3o armazenados e tratados em computadores. Motiva\u00e7\u00e3o \u00b6 Desenvolver um computador do ZERO! Avalia\u00e7\u00e3o \u00b6 A disciplina \u00e9 avaliada em duas frentes: avalia\u00e7\u00e3o individual e APS: Individual: ao longo do semestre o aluno deve acumular 60 pontos de Software e 60 pontos de Hardware esses pontos estar\u00e3o distribu\u00eddos nas quatro avalia\u00e7\u00f5es (P1,P2,P3,P4) que ser\u00e3o aplicadas ao longo do semestre. APS: Compostas por duas notas: Grupo e Individual sendo que cada uma segue uma rubrica diferente e avalia objetivo diferentes do curso. Infraestrutura \u00b6 O ferramental da disciplina foi desenvolvido para o sistema operacional Linux , e necessita de uma s\u00e9rie de softwares e configurados. Voc\u00ea receber\u00e1 um SSD com tudo pronto. Bibliografia \u00b6 B\u00e1sica \u00b6 Livros NISAN, Noam; SCHOCKEN, Shimon., The Elements of Computing Systems, \u00aa ed., MIT Press, 2005 TOCCI, R. J.; WIDMER, N. S.; MOSS, G. L., Sistemas Digitais: Princ\u00edpios e Aplica\u00e7\u00f5es, 11\u00aa ed., Pearson, 2011 PATTERSON, D.; HENNESSY, J. L., Organiza\u00e7\u00e3o e Projeto de Computadores: A Interface Hardware/Software., 4\u00aa ed., Campus, Artigos: Artigos KHAN, S. et. Al.. A high performance processor architecture for multimedia applications. Computer & Electrical Engineering. , v. 66 , p. 14-29 , 2018. ; Dispon\u00edvel em: https://www.sciencedirect.com/science/article/pii/S0045790616305894 . Acesso em: 04 ago 2019. Complementar \u00b6 Livros MOORE, Cristopher ; MERTENS, Stephan., The Nature of Computation, \u00aa ed., University Press, 2011 STALLINGS, W., Arquitetura e organiza\u00e7\u00e3o de computadores, 8\u00aa ed., Prentice Hall Brasil, 2010 LAING, Gordon., Digital Retro: The Evolution and Design of the Personal Computer, \u00aa ed., Sybex, 2004 NIELSEN, L., Computing: A Business History, \u00aa ed., New Street Communications LLC, 2012 FLOYD, T. L., Digital Fundamentals, 11\u00aa ed., Pearson, 2015","title":"Bem vindo disciplina de Elementos de Sistemas!"},{"location":"#bem-vindo-disciplina-de-elementos-de-sistemas","text":"Curso: Engenharia Da Computa\u00e7\u00e3o - Terceiro semestre Disciplina: Elementos de Sistemas Insper - 2019-2. Prof. Rafael Corsi / rafael.corsi@insper.edu.br Reposit\u00f3rio: http:/github.com/Insper/Z01.1 Local: Laborat\u00f3rio de Inform\u00e1tica - 404 \u00a9 Todos os direitos reservados","title":"Bem vindo disciplina de Elementos de Sistemas!"},{"location":"#objetivos-de-aprendizagem","text":"Ao final da disciplina o estudante ser\u00e1 capaz de: Implementar um computador digital simples a partir de componentes eletr\u00f4nicos. Integrar as camadas de programa\u00e7\u00e3o e execu\u00e7\u00e3o de um computador simples. Trabalhar de forma colaborativa no desenvolvimento de um sistema computacional. Compreender a evolu\u00e7\u00e3o da inform\u00e1tica. Descrever como dados e instru\u00e7\u00f5es s\u00e3o armazenados e tratados em computadores.","title":"Objetivos de aprendizagem"},{"location":"#motivacao","text":"Desenvolver um computador do ZERO!","title":"Motiva\u00e7\u00e3o"},{"location":"#avaliacao","text":"A disciplina \u00e9 avaliada em duas frentes: avalia\u00e7\u00e3o individual e APS: Individual: ao longo do semestre o aluno deve acumular 60 pontos de Software e 60 pontos de Hardware esses pontos estar\u00e3o distribu\u00eddos nas quatro avalia\u00e7\u00f5es (P1,P2,P3,P4) que ser\u00e3o aplicadas ao longo do semestre. APS: Compostas por duas notas: Grupo e Individual sendo que cada uma segue uma rubrica diferente e avalia objetivo diferentes do curso.","title":"Avalia\u00e7\u00e3o"},{"location":"#infraestrutura","text":"O ferramental da disciplina foi desenvolvido para o sistema operacional Linux , e necessita de uma s\u00e9rie de softwares e configurados. Voc\u00ea receber\u00e1 um SSD com tudo pronto.","title":"Infraestrutura"},{"location":"#bibliografia","text":"","title":"Bibliografia"},{"location":"#basica","text":"Livros NISAN, Noam; SCHOCKEN, Shimon., The Elements of Computing Systems, \u00aa ed., MIT Press, 2005 TOCCI, R. J.; WIDMER, N. S.; MOSS, G. L., Sistemas Digitais: Princ\u00edpios e Aplica\u00e7\u00f5es, 11\u00aa ed., Pearson, 2011 PATTERSON, D.; HENNESSY, J. L., Organiza\u00e7\u00e3o e Projeto de Computadores: A Interface Hardware/Software., 4\u00aa ed., Campus, Artigos: Artigos KHAN, S. et. Al.. A high performance processor architecture for multimedia applications. Computer & Electrical Engineering. , v. 66 , p. 14-29 , 2018. ; Dispon\u00edvel em: https://www.sciencedirect.com/science/article/pii/S0045790616305894 . Acesso em: 04 ago 2019.","title":"B\u00e1sica"},{"location":"#complementar","text":"Livros MOORE, Cristopher ; MERTENS, Stephan., The Nature of Computation, \u00aa ed., University Press, 2011 STALLINGS, W., Arquitetura e organiza\u00e7\u00e3o de computadores, 8\u00aa ed., Prentice Hall Brasil, 2010 LAING, Gordon., Digital Retro: The Evolution and Design of the Personal Computer, \u00aa ed., Sybex, 2004 NIELSEN, L., Computing: A Business History, \u00aa ed., New Street Communications LLC, 2012 FLOYD, T. L., Digital Fundamentals, 11\u00aa ed., Pearson, 2015","title":"Complementar"},{"location":"A-Ambiente-Desenvolvimento-Projeto/","text":"A - Ambiente de desenvolvimento \u00b6 Nesse projeto iremos configurar grande parte do ambiente de desenvolvimento a ser utilizado por toda a disciplina, que \u00e9 composto basicamente pelas ferramentas: Reposit\u00f3rio github Slack Travis CI Esse projeto tamb\u00e9m tem como objetivo introduzir a din\u00e2mica de trabalho e avalia\u00e7\u00e3o que ser\u00e1 usada na disciplina, onde uma pessoa \u00e9 respons\u00e1vel pela gest\u00e3o do projeto e avalia\u00e7\u00e3o dos colegas e as demais por implementar o que \u00e9 pedido. Para executar esse projeto basta completar os laborat\u00f3rios: Lab1 ; Lab2 ; Rubricas \u00b6 Cada projeto da disciplina \u00e9 composto por duas notas: Grupo E Individual . A nota desse projeto espec\u00edfico \u00e9 bin\u00e1ria: A ou I . Grupo \u00b6 Para obter A \u00e9 necess\u00e1rio: Ter o reposit\u00f3rio forkado Nome atualizado do fork github configurado com issues e project GRUPO.json atualizado corretamente INTEGRANTES.json atualizado Teste de arquivos .json passando Travis configurado Grupo realizou pull-request e os mesmos foram aceitos Ter criado um canal dentro do Slack da disciplina Individual \u00b6 Para obter A \u00e9 necess\u00e1rio: Participar do reposit\u00f3rio do grupo Ter configurado INTEGRANTES.json Ter criado uma branch e realizado o pull-Request Ter entrado no canal do Slack da disciplina Ter entrado no canal do grupo no slack da disciplina","title":"A - Ambiente de desenvolvimento"},{"location":"A-Ambiente-Desenvolvimento-Projeto/#a-ambiente-de-desenvolvimento","text":"Nesse projeto iremos configurar grande parte do ambiente de desenvolvimento a ser utilizado por toda a disciplina, que \u00e9 composto basicamente pelas ferramentas: Reposit\u00f3rio github Slack Travis CI Esse projeto tamb\u00e9m tem como objetivo introduzir a din\u00e2mica de trabalho e avalia\u00e7\u00e3o que ser\u00e1 usada na disciplina, onde uma pessoa \u00e9 respons\u00e1vel pela gest\u00e3o do projeto e avalia\u00e7\u00e3o dos colegas e as demais por implementar o que \u00e9 pedido. Para executar esse projeto basta completar os laborat\u00f3rios: Lab1 ; Lab2 ;","title":"A - Ambiente de desenvolvimento"},{"location":"A-Ambiente-Desenvolvimento-Projeto/#rubricas","text":"Cada projeto da disciplina \u00e9 composto por duas notas: Grupo E Individual . A nota desse projeto espec\u00edfico \u00e9 bin\u00e1ria: A ou I .","title":"Rubricas"},{"location":"A-Ambiente-Desenvolvimento-Projeto/#grupo","text":"Para obter A \u00e9 necess\u00e1rio: Ter o reposit\u00f3rio forkado Nome atualizado do fork github configurado com issues e project GRUPO.json atualizado corretamente INTEGRANTES.json atualizado Teste de arquivos .json passando Travis configurado Grupo realizou pull-request e os mesmos foram aceitos Ter criado um canal dentro do Slack da disciplina","title":"Grupo"},{"location":"A-Ambiente-Desenvolvimento-Projeto/#individual","text":"Para obter A \u00e9 necess\u00e1rio: Participar do reposit\u00f3rio do grupo Ter configurado INTEGRANTES.json Ter criado uma branch e realizado o pull-Request Ter entrado no canal do Slack da disciplina Ter entrado no canal do grupo no slack da disciplina","title":"Individual"},{"location":"A-Ambiente-Lab-1/","text":"Lab 1: Configurando Github \u00b6 Devemos come\u00e7ar a preparar o terreno para os projetos em grupo que estar\u00e3o por vir, nessa etapa voc\u00eas devem montar um grupo de \u215a colegas e dar um nome a ele (os grupos s\u00e3o nomeados por letras, a primeira letra do nome do seu grupo ser\u00e1 fornecida pelo professor). O grupo ir\u00e1 trabalhar de forma colaborativa via a utiliza\u00e7\u00e3o do git/ github. \u00c9 imprescind\u00edvel que todos trabalhem dessa forma, pois ser\u00e1 a maneira que iremos avaliar individualmente voc\u00eas. Criando o grupo \u00b6 Grupo de at\u00e9 6 pessoas! Preencher o form a seguir... Loading\u2026 GitHub \u00b6 O git ser\u00e1 uma das ferramentas mais importantes para o projeto, com as etapas a seguir voc\u00eas realizaram um Fork do reposit\u00f3rio do projeto e adicionaram os colaboradores. Fork \u00b6 Um por grupo Daqui at\u00e9 o pr\u00f3ximo aviso s\u00f3 uma pessoa do grupo deve fazer! Os demais devem acompanhar. O Scrum Master do grupo (ser\u00e1 sorteado em sala) dever\u00e1 realizar o fork do reposit\u00f3rio do projeto do computador Z01, para isso, basta acessar a p\u00e1gina do github do projeto: https://github.com/Insper/Z01.1 E no site clicar em fork : Note que criar um fork \u00e9 diferente de criar apenas uma c\u00f3pia. No fork o seu reposit\u00f3rio ainda possui como refer\u00eancia o original (/insper/Z01.1) o que possibilitar\u00e1 que voc\u00eas atualizem o reposit\u00f3rio com novos materiais que ser\u00e3o necess\u00e1rios ao longo do semestre sem perder o que j\u00e1 foi feito e mais importante sem muito trabalho. git fork n\u00e3o existe no git, \u00e9 algo implementado pelo github (e similares). \u00c9 utilizado para criar uma 'c\u00f3pia' de um reposit\u00f3rio para podermos trabalhar nele sem a necessidade de mexermos no original. Alterando o nome do Fork \u00b6 Acesse a p\u00e1gina do reposit\u00f3rio de voc\u00eas no github SETTINGS Repository Name e altere o nome do reposit\u00f3rio para: nome : Z01.1-NomeDoGrupo NomeDoGrupo O Nome do grupo deve ser uma palavra que come\u00e7e com a letra que o grupo recebeu... Colaboradores \u00b6 Isso ir\u00e1 criar uma c\u00f3pia do reposit\u00f3rio na sua conta, uma vez realizado a c\u00f3pia ser\u00e1 necess\u00e1rio inserir os demais colegas como integrantes desse reposit\u00f3rio (para que eles possam propor altera\u00e7\u00f5es). Para isso v\u00e1 at\u00e9 a p\u00e1gina do reposit\u00f3rio na sua conta e clique em Settings Collaborators e adicione os usu\u00e1rios ou e-mails dos seus colegas. Todos integrantes do grupo j\u00e1 devem ter uma conta no github j\u00e1 criada. Ferramentas github \u00b6 git GitHub Inc. is a web-based hosting service for version control using Git. It is mostly used for computer code. It offers all of the distributed version control and source code management functionality of Git as well as adding its own features. Wikipedia http://github.com Nessa disciplina iremos utilizar n\u00e3o s\u00f3 a ferramenta principal do github, que \u00e9 o servidor de reposit\u00f3rios git, mas todas as outras ferramentas j\u00e1 integradas na plataforma para gest\u00e3o e acompanhamento de projeto. Para isso ser\u00e1 alteramos algumas configura\u00e7\u00f5es no reposit\u00f3rio: Execute Na p\u00e1gina do seu reposit\u00f3rio v\u00e1 em: Settings Features e ative Issues e Project . Ferramentas github Github Project : Ferramenta do github para gerenciamento de projetos (estilo Kambam), cada reposit\u00f3rio pode ter N projetos, e o github automatiza o processo de todo/doing/done deixando de maneira visual as tarefas. github issues : Plataforma do github para cria\u00e7\u00e3o de tarefas/ reportar erros. As tarefas aqui criadas ser\u00e3o associadas a um projeto espec\u00edfico e a um grupo de pessoas espec\u00edficas. Branch : Ramo criado para implementar um feature/ corre\u00e7\u00e3o de bug que ser\u00e1 futuramente incorporado no master (merge) Master : Ramo principal do projeto, gerenciado pelo Scrum Master Pull-request : Maneira de um lider de projeto receber altera\u00e7\u00f5es a um projeto e ter controle do que ser\u00e1 aceito ou n\u00e3o. Na maioria dos casos o pull-request \u00e9 criado por um usu\u00e1rio e revisado por outro. Quem for fazer a eletiva de Desenvolvimento Aberto do Prof. Igor ver\u00e1 bem a fundo essa quest\u00e3o. Travis CI \u00b6 Travis \u00e9 um sistema de integra\u00e7\u00e3o cont\u00ednua que vai executar de forma autom\u00e1tica alguns testes (criado por n\u00f3s) no projeto e em caso de alguma falha ir\u00e1 notificar no github e por e-mail todos os integrantes. Como ele funciona ? Ele fica verificando o reposit\u00f3rio por altera\u00e7\u00f5es (voc\u00ea deve al\u00e9m de dar commit, dar push) e para cada novo commit ele faz o seguinte Inicializa uma nova m\u00e1quina virtual na nuvem (ubuntu, windows, mac) Instala todo a infra necess\u00e1ria do projeto (no caso do Z01.1 : python, java, Quartus, ...) Executa os scripts de teste localizados em cada projeto. Desliga e \"deleta\" a m\u00e1quina virtual rec\u00e9m criada. O arquivo de configura\u00e7\u00e3o do travis est\u00e1 localizado na raiz do reposit\u00f3rio: Z01.1/.travis.yml . Nele que est\u00e3o feitas todas as defini\u00e7\u00f5es de execu\u00e7\u00e3o. Na pagina do seu reposit\u00f3rio em commits deve aparecer uma pequena bolinha em cada um dos commits novos que ser\u00e3o feitos no projeto, esse indicador ser\u00e1 atualizado pelo travis sendo: Amarelo: O teste est\u00e1 em execu\u00e7\u00e3o Verde: O teste passou Vermelho: O teste falhou Note Cada teste leva em torno de alguns minutos j\u00e1 que toda a infraestrutura \u00e9 instalada sempre do zero, n\u00e3o utilize o sistema de Integra\u00e7\u00e3o Cont\u00ednua para validar as suas novas implementa\u00e7\u00f5es, esse sistema deve ser utilizado para encontrar problemas mais amplos ou para o scrum master aceitar ou n\u00e3o um pull-request, j\u00e1 que o resultado do sucesso ou n\u00e3o dessa requisi\u00e7\u00e3o \u00e9 vis\u00edvel facilmente. Ativando o Travis \u00b6 Somente o owner do reposit\u00f3rio Daqui at\u00e9 o pr\u00f3ximo aviso s\u00f3 uma pessoa do grupo deve fazer! Os demais devem acompanhar. Ser\u00e1 necess\u00e1rio acessar o site do travis: https://travis-ci.org/ e adicione o projeto forkado ao travis: Arquivo GRUPO.json de configura\u00e7\u00e3o \u00b6 Um por grupo Somente um do grupo deve realizar isso. Ap\u00f3s clonar o reposit\u00f3rio o mediador desse projeto deve editar o arquivo json GRUPO.json que est\u00e1 localizado na raiz do projeto inserindo a letra do grupo (que foi atribu\u00edda em sala) e o nome rec\u00e9m criado do grupo (o nome do grupo deve ser uma Frase com a primeira palavra come\u00e7ando com a letra do Grupo). Exemplo um grupo com a letra M , GRUPO.json : { \"Nome-Grupo\" : \"Macarrao\" } Ap\u00f3s editar o arquivo deve-se: fazer um commit e um push para o reposit\u00f3rio. $ git commit -am \"update Grupo\" $ git push origin master Slack \u00b6 O Slack \u00e9 uma ferramenta de conversa similar ao discord por\u00e9m para uso de empresas (e n\u00e3o para jogos =/). Termos um canal da disciplina no Slack, e todos devem participar , para isso basta acessar o link a seguir: https://join.slack.com/t/z01-2020/shared_invite/enQtOTQ2MjMwNzUyNjc4LWNmMGQzMTdhYzRlZmE5NDI1ODYyZWQzOTcwYTdmNjM2ZDNlODAwYTJiNWZjMDc4OTI0ZDMxZDg1NjU4MGNhYzE Note Como nome de usu\u00e1rio colocar seu Nome e Sobrenome Canal do grupo \u00b6 Um por grupo Somente um do grupo deve realizar isso. Cada grupo deve ter um canal privado no slack, na qual todos fazer parte e o seus professores tamb\u00e9m (Rafael Corsi, Eduardo Marossi). O canal deve ser o nome do grupo!","title":"Lab 1: Configurando Github"},{"location":"A-Ambiente-Lab-1/#lab-1-configurando-github","text":"Devemos come\u00e7ar a preparar o terreno para os projetos em grupo que estar\u00e3o por vir, nessa etapa voc\u00eas devem montar um grupo de \u215a colegas e dar um nome a ele (os grupos s\u00e3o nomeados por letras, a primeira letra do nome do seu grupo ser\u00e1 fornecida pelo professor). O grupo ir\u00e1 trabalhar de forma colaborativa via a utiliza\u00e7\u00e3o do git/ github. \u00c9 imprescind\u00edvel que todos trabalhem dessa forma, pois ser\u00e1 a maneira que iremos avaliar individualmente voc\u00eas.","title":"Lab 1: Configurando Github"},{"location":"A-Ambiente-Lab-1/#criando-o-grupo","text":"Grupo de at\u00e9 6 pessoas! Preencher o form a seguir... Loading\u2026","title":"Criando o grupo"},{"location":"A-Ambiente-Lab-1/#github","text":"O git ser\u00e1 uma das ferramentas mais importantes para o projeto, com as etapas a seguir voc\u00eas realizaram um Fork do reposit\u00f3rio do projeto e adicionaram os colaboradores.","title":"GitHub"},{"location":"A-Ambiente-Lab-1/#fork","text":"Um por grupo Daqui at\u00e9 o pr\u00f3ximo aviso s\u00f3 uma pessoa do grupo deve fazer! Os demais devem acompanhar. O Scrum Master do grupo (ser\u00e1 sorteado em sala) dever\u00e1 realizar o fork do reposit\u00f3rio do projeto do computador Z01, para isso, basta acessar a p\u00e1gina do github do projeto: https://github.com/Insper/Z01.1 E no site clicar em fork : Note que criar um fork \u00e9 diferente de criar apenas uma c\u00f3pia. No fork o seu reposit\u00f3rio ainda possui como refer\u00eancia o original (/insper/Z01.1) o que possibilitar\u00e1 que voc\u00eas atualizem o reposit\u00f3rio com novos materiais que ser\u00e3o necess\u00e1rios ao longo do semestre sem perder o que j\u00e1 foi feito e mais importante sem muito trabalho. git fork n\u00e3o existe no git, \u00e9 algo implementado pelo github (e similares). \u00c9 utilizado para criar uma 'c\u00f3pia' de um reposit\u00f3rio para podermos trabalhar nele sem a necessidade de mexermos no original.","title":"Fork"},{"location":"A-Ambiente-Lab-1/#alterando-o-nome-do-fork","text":"Acesse a p\u00e1gina do reposit\u00f3rio de voc\u00eas no github SETTINGS Repository Name e altere o nome do reposit\u00f3rio para: nome : Z01.1-NomeDoGrupo NomeDoGrupo O Nome do grupo deve ser uma palavra que come\u00e7e com a letra que o grupo recebeu...","title":"Alterando o nome do Fork"},{"location":"A-Ambiente-Lab-1/#colaboradores","text":"Isso ir\u00e1 criar uma c\u00f3pia do reposit\u00f3rio na sua conta, uma vez realizado a c\u00f3pia ser\u00e1 necess\u00e1rio inserir os demais colegas como integrantes desse reposit\u00f3rio (para que eles possam propor altera\u00e7\u00f5es). Para isso v\u00e1 at\u00e9 a p\u00e1gina do reposit\u00f3rio na sua conta e clique em Settings Collaborators e adicione os usu\u00e1rios ou e-mails dos seus colegas. Todos integrantes do grupo j\u00e1 devem ter uma conta no github j\u00e1 criada.","title":"Colaboradores"},{"location":"A-Ambiente-Lab-1/#ferramentas-github","text":"git GitHub Inc. is a web-based hosting service for version control using Git. It is mostly used for computer code. It offers all of the distributed version control and source code management functionality of Git as well as adding its own features. Wikipedia http://github.com Nessa disciplina iremos utilizar n\u00e3o s\u00f3 a ferramenta principal do github, que \u00e9 o servidor de reposit\u00f3rios git, mas todas as outras ferramentas j\u00e1 integradas na plataforma para gest\u00e3o e acompanhamento de projeto. Para isso ser\u00e1 alteramos algumas configura\u00e7\u00f5es no reposit\u00f3rio: Execute Na p\u00e1gina do seu reposit\u00f3rio v\u00e1 em: Settings Features e ative Issues e Project . Ferramentas github Github Project : Ferramenta do github para gerenciamento de projetos (estilo Kambam), cada reposit\u00f3rio pode ter N projetos, e o github automatiza o processo de todo/doing/done deixando de maneira visual as tarefas. github issues : Plataforma do github para cria\u00e7\u00e3o de tarefas/ reportar erros. As tarefas aqui criadas ser\u00e3o associadas a um projeto espec\u00edfico e a um grupo de pessoas espec\u00edficas. Branch : Ramo criado para implementar um feature/ corre\u00e7\u00e3o de bug que ser\u00e1 futuramente incorporado no master (merge) Master : Ramo principal do projeto, gerenciado pelo Scrum Master Pull-request : Maneira de um lider de projeto receber altera\u00e7\u00f5es a um projeto e ter controle do que ser\u00e1 aceito ou n\u00e3o. Na maioria dos casos o pull-request \u00e9 criado por um usu\u00e1rio e revisado por outro. Quem for fazer a eletiva de Desenvolvimento Aberto do Prof. Igor ver\u00e1 bem a fundo essa quest\u00e3o.","title":"Ferramentas github"},{"location":"A-Ambiente-Lab-1/#travis-ci","text":"Travis \u00e9 um sistema de integra\u00e7\u00e3o cont\u00ednua que vai executar de forma autom\u00e1tica alguns testes (criado por n\u00f3s) no projeto e em caso de alguma falha ir\u00e1 notificar no github e por e-mail todos os integrantes. Como ele funciona ? Ele fica verificando o reposit\u00f3rio por altera\u00e7\u00f5es (voc\u00ea deve al\u00e9m de dar commit, dar push) e para cada novo commit ele faz o seguinte Inicializa uma nova m\u00e1quina virtual na nuvem (ubuntu, windows, mac) Instala todo a infra necess\u00e1ria do projeto (no caso do Z01.1 : python, java, Quartus, ...) Executa os scripts de teste localizados em cada projeto. Desliga e \"deleta\" a m\u00e1quina virtual rec\u00e9m criada. O arquivo de configura\u00e7\u00e3o do travis est\u00e1 localizado na raiz do reposit\u00f3rio: Z01.1/.travis.yml . Nele que est\u00e3o feitas todas as defini\u00e7\u00f5es de execu\u00e7\u00e3o. Na pagina do seu reposit\u00f3rio em commits deve aparecer uma pequena bolinha em cada um dos commits novos que ser\u00e3o feitos no projeto, esse indicador ser\u00e1 atualizado pelo travis sendo: Amarelo: O teste est\u00e1 em execu\u00e7\u00e3o Verde: O teste passou Vermelho: O teste falhou Note Cada teste leva em torno de alguns minutos j\u00e1 que toda a infraestrutura \u00e9 instalada sempre do zero, n\u00e3o utilize o sistema de Integra\u00e7\u00e3o Cont\u00ednua para validar as suas novas implementa\u00e7\u00f5es, esse sistema deve ser utilizado para encontrar problemas mais amplos ou para o scrum master aceitar ou n\u00e3o um pull-request, j\u00e1 que o resultado do sucesso ou n\u00e3o dessa requisi\u00e7\u00e3o \u00e9 vis\u00edvel facilmente.","title":"Travis CI"},{"location":"A-Ambiente-Lab-1/#ativando-o-travis","text":"Somente o owner do reposit\u00f3rio Daqui at\u00e9 o pr\u00f3ximo aviso s\u00f3 uma pessoa do grupo deve fazer! Os demais devem acompanhar. Ser\u00e1 necess\u00e1rio acessar o site do travis: https://travis-ci.org/ e adicione o projeto forkado ao travis:","title":"Ativando o Travis"},{"location":"A-Ambiente-Lab-1/#arquivo-grupojson-de-configuracao","text":"Um por grupo Somente um do grupo deve realizar isso. Ap\u00f3s clonar o reposit\u00f3rio o mediador desse projeto deve editar o arquivo json GRUPO.json que est\u00e1 localizado na raiz do projeto inserindo a letra do grupo (que foi atribu\u00edda em sala) e o nome rec\u00e9m criado do grupo (o nome do grupo deve ser uma Frase com a primeira palavra come\u00e7ando com a letra do Grupo). Exemplo um grupo com a letra M , GRUPO.json : { \"Nome-Grupo\" : \"Macarrao\" } Ap\u00f3s editar o arquivo deve-se: fazer um commit e um push para o reposit\u00f3rio. $ git commit -am \"update Grupo\" $ git push origin master","title":"Arquivo GRUPO.json de configura\u00e7\u00e3o"},{"location":"A-Ambiente-Lab-1/#slack","text":"O Slack \u00e9 uma ferramenta de conversa similar ao discord por\u00e9m para uso de empresas (e n\u00e3o para jogos =/). Termos um canal da disciplina no Slack, e todos devem participar , para isso basta acessar o link a seguir: https://join.slack.com/t/z01-2020/shared_invite/enQtOTQ2MjMwNzUyNjc4LWNmMGQzMTdhYzRlZmE5NDI1ODYyZWQzOTcwYTdmNjM2ZDNlODAwYTJiNWZjMDc4OTI0ZDMxZDg1NjU4MGNhYzE Note Como nome de usu\u00e1rio colocar seu Nome e Sobrenome","title":"Slack"},{"location":"A-Ambiente-Lab-1/#canal-do-grupo","text":"Um por grupo Somente um do grupo deve realizar isso. Cada grupo deve ter um canal privado no slack, na qual todos fazer parte e o seus professores tamb\u00e9m (Rafael Corsi, Eduardo Marossi). O canal deve ser o nome do grupo!","title":"Canal do grupo"},{"location":"A-Ambiente-Lab-2/","text":"Lab 2: Github \u00b6 Nesse laborat\u00f3rio iremos trabalhar com o uso do git de forma colaborativa. Tip Aconselh\u00e1vel fazer no Linux, mas pode fazer no Windows Clonando \u00b6 Individual Todos do grupo devem realizar de maneira individual! Uma vez criado o fork e adicionado os colegas voc\u00eas dever\u00e3o clonar o reposit\u00f3rio para o computador de voc\u00eas com o comando: $ git clone URL_DO_FORK URL_DO_FORK A URL do seu fork pode ser obtida pelo bot\u00e3o 'Clone or Download' do github: Linux O s\u00edmbolo $ indica que \u00e9 um comando para ser executado no terminal do Linux ( bash ), mas ele n\u00e3o deve fazer parte do comando. No caso anterior, o comando a ser colado deve ser: git clone URL_DO_FORK . Linux Para abrir o terminal: meta + t Adicionando nomes ao INTEGRANTES.json \u00b6 Individual Deve ser realizado individual por todos do grupo. Tip Antes de come\u00e7ar, atualize seu reposit\u00f3rio com o remote: $ git pull origin master Nesse etapa cada integrante do grupo ir\u00e1 editar um arquivo no seu computador e realizar um pull-request para o reposit\u00f3rio do grupo. Para isso seguiremos as etapas a seguir: Gerar mudan\u00e7as no reposit\u00f3rio local Criando um branch com as mudan\u00e7as Enviar mudan\u00e7as para o reposit\u00f3rio remoto Gerar pull-request Atualizando INTEGRANTES.json \u00b6 Cada integrante do grupo deve editar o documento com na raiz do projeto com nome INTEGRANTES.json e adicionar a esse arquivo o seu nome, e-mail (insper) e usu\u00e1rio gituhb. Conforme o exemplo a seguir: { \"aluno-1\" : { \"nome\" : \"Rafae Corsi\" , \"email-insper\" : \"rafael.corsi@insper.edu.br\" , \"user-github\" : \"rafaelcorsi\" }, Warning Uma \u00fanica pessoa n\u00e3o deve editar o documento com todos os nomes. Cada um deve realizar individualmente em seu computador. Testando \u00b6 A disciplina utiliza uma t\u00e9cnica chamada de \"Test Driven Development\" onde utilizamos de teste unit\u00e1rio e de integra\u00e7\u00e3o para validarmos se a implementa\u00e7\u00e3o est\u00e1 correta. Nesse caso, iremos utilizar um script para validar se o arquivo .json editado est\u00e1 com formata\u00e7\u00e3o correta. Para isso, execute no terminal: $ ./Projetos/A-AmbienteDesenvolvimento/testeAmbienteDesenvolvimento.py Voc\u00ea deve obter: \u279c Z01.1 git:(master) \u2717 ./Projetos/A-AmbienteDesenvolvimento/testeAmbienteDesenvolvimento.py =================================================== [OK] GRUPO.json =================================================== =================================================== [OK] INTEGRANTES.json =================================================== Warning Se obter [FAIL] em algum dos dois arquivos, editar o arquivo e executar a etapa anterior novamente. S\u00f3 continuar se n\u00e3o tiver falhas! Criando um branch para fazer o commit. \u00b6 A fim de realizarmos um pull-request ao mediador do projeto \u00e9 preciso salvarmos essas modifica\u00e7\u00f5es em um novo branch. O comando a seguir faz isso: $ # criando um novo branch $ git checkout -B $NOME git Substitua nos comandos o termo $NOME pelo seu nome. Agora vamos fazer um commit com o seu nome nesse novo branch: $ git add INTEGRANTES.json $ git commit -m \"Adicionado meu $NOME ao arquivo\" Ser\u00e1 necess\u00e1rio enviarmos esse branch ao servidor (github) antes de realizarmos o pull-request : $ # enviando o branch para o reposit\u00f3rio remoto $ git push origin $NOME git Esse comando diz para o git que \u00e9 para enviar o branch $NOME para o reposit\u00f3rio remoto origin . Aquele que aparece no comando $ git remote -v . Realizando pull-request \u00b6 Uma vez enviando o branch para o servidor, podemos via a interface web do github realizar o pull-request . Abra a pag\u00edna do github do reposit\u00f3rio do seu grupo. git Se tiver instalado o software hub digite na linha de comando: $ hub browser . Vamos agora gerar o pull-request na interface do github, de forma similar ao exemplo a seguir: Warning Cuidado! Escolher o seu reposit\u00f3rio no momento de realizar o pullrequest. Tip Ao realizar o PR, o Travis ir\u00e1 verificar o seu arquivo com o mesmo teste que voc\u00ea executou anteriormente, esse ser\u00e1 o fluxo geral da disciplina, onde o mesmo teste \u00e9 realizado local na m\u00e1quina de cada aluno e remoto automaticamente pelo Travis. Aceitando pull-request \u00b6 Apenas o mediador Voc\u00eas devem escolher um do grupo para assumir o papel do mediador! O mediador do projeto deve revisar os pull-requests (e corrigir eventuais erros de merge) e aceitar ou negar o pedido.","title":"Lab 2: Github"},{"location":"A-Ambiente-Lab-2/#lab-2-github","text":"Nesse laborat\u00f3rio iremos trabalhar com o uso do git de forma colaborativa. Tip Aconselh\u00e1vel fazer no Linux, mas pode fazer no Windows","title":"Lab 2: Github"},{"location":"A-Ambiente-Lab-2/#clonando","text":"Individual Todos do grupo devem realizar de maneira individual! Uma vez criado o fork e adicionado os colegas voc\u00eas dever\u00e3o clonar o reposit\u00f3rio para o computador de voc\u00eas com o comando: $ git clone URL_DO_FORK URL_DO_FORK A URL do seu fork pode ser obtida pelo bot\u00e3o 'Clone or Download' do github: Linux O s\u00edmbolo $ indica que \u00e9 um comando para ser executado no terminal do Linux ( bash ), mas ele n\u00e3o deve fazer parte do comando. No caso anterior, o comando a ser colado deve ser: git clone URL_DO_FORK . Linux Para abrir o terminal: meta + t","title":"Clonando"},{"location":"A-Ambiente-Lab-2/#adicionando-nomes-ao-integrantesjson","text":"Individual Deve ser realizado individual por todos do grupo. Tip Antes de come\u00e7ar, atualize seu reposit\u00f3rio com o remote: $ git pull origin master Nesse etapa cada integrante do grupo ir\u00e1 editar um arquivo no seu computador e realizar um pull-request para o reposit\u00f3rio do grupo. Para isso seguiremos as etapas a seguir: Gerar mudan\u00e7as no reposit\u00f3rio local Criando um branch com as mudan\u00e7as Enviar mudan\u00e7as para o reposit\u00f3rio remoto Gerar pull-request","title":"Adicionando nomes ao INTEGRANTES.json"},{"location":"A-Ambiente-Lab-2/#atualizando-integrantesjson","text":"Cada integrante do grupo deve editar o documento com na raiz do projeto com nome INTEGRANTES.json e adicionar a esse arquivo o seu nome, e-mail (insper) e usu\u00e1rio gituhb. Conforme o exemplo a seguir: { \"aluno-1\" : { \"nome\" : \"Rafae Corsi\" , \"email-insper\" : \"rafael.corsi@insper.edu.br\" , \"user-github\" : \"rafaelcorsi\" }, Warning Uma \u00fanica pessoa n\u00e3o deve editar o documento com todos os nomes. Cada um deve realizar individualmente em seu computador.","title":"Atualizando INTEGRANTES.json"},{"location":"A-Ambiente-Lab-2/#testando","text":"A disciplina utiliza uma t\u00e9cnica chamada de \"Test Driven Development\" onde utilizamos de teste unit\u00e1rio e de integra\u00e7\u00e3o para validarmos se a implementa\u00e7\u00e3o est\u00e1 correta. Nesse caso, iremos utilizar um script para validar se o arquivo .json editado est\u00e1 com formata\u00e7\u00e3o correta. Para isso, execute no terminal: $ ./Projetos/A-AmbienteDesenvolvimento/testeAmbienteDesenvolvimento.py Voc\u00ea deve obter: \u279c Z01.1 git:(master) \u2717 ./Projetos/A-AmbienteDesenvolvimento/testeAmbienteDesenvolvimento.py =================================================== [OK] GRUPO.json =================================================== =================================================== [OK] INTEGRANTES.json =================================================== Warning Se obter [FAIL] em algum dos dois arquivos, editar o arquivo e executar a etapa anterior novamente. S\u00f3 continuar se n\u00e3o tiver falhas!","title":"Testando"},{"location":"A-Ambiente-Lab-2/#criando-um-branch-para-fazer-o-commit","text":"A fim de realizarmos um pull-request ao mediador do projeto \u00e9 preciso salvarmos essas modifica\u00e7\u00f5es em um novo branch. O comando a seguir faz isso: $ # criando um novo branch $ git checkout -B $NOME git Substitua nos comandos o termo $NOME pelo seu nome. Agora vamos fazer um commit com o seu nome nesse novo branch: $ git add INTEGRANTES.json $ git commit -m \"Adicionado meu $NOME ao arquivo\" Ser\u00e1 necess\u00e1rio enviarmos esse branch ao servidor (github) antes de realizarmos o pull-request : $ # enviando o branch para o reposit\u00f3rio remoto $ git push origin $NOME git Esse comando diz para o git que \u00e9 para enviar o branch $NOME para o reposit\u00f3rio remoto origin . Aquele que aparece no comando $ git remote -v .","title":"Criando um branch para fazer o commit."},{"location":"A-Ambiente-Lab-2/#realizando-pull-request","text":"Uma vez enviando o branch para o servidor, podemos via a interface web do github realizar o pull-request . Abra a pag\u00edna do github do reposit\u00f3rio do seu grupo. git Se tiver instalado o software hub digite na linha de comando: $ hub browser . Vamos agora gerar o pull-request na interface do github, de forma similar ao exemplo a seguir: Warning Cuidado! Escolher o seu reposit\u00f3rio no momento de realizar o pullrequest. Tip Ao realizar o PR, o Travis ir\u00e1 verificar o seu arquivo com o mesmo teste que voc\u00ea executou anteriormente, esse ser\u00e1 o fluxo geral da disciplina, onde o mesmo teste \u00e9 realizado local na m\u00e1quina de cada aluno e remoto automaticamente pelo Travis.","title":"Realizando pull-request"},{"location":"A-Ambiente-Lab-2/#aceitando-pull-request","text":"Apenas o mediador Voc\u00eas devem escolher um do grupo para assumir o papel do mediador! O mediador do projeto deve revisar os pull-requests (e corrigir eventuais erros de merge) e aceitar ou negar o pedido.","title":"Aceitando pull-request"},{"location":"A-Transistores-Lab-1/","text":"Lab 3: Transistores \u00b6 Esse laborat\u00f3rio tem como objetivo trabalhar com os conceitos b\u00e1sicos de portas l\u00f3gicas do tipo RTL realizadas a base de transistores discretos do tipo BJT . Assim como desenvolver o trabalho em grupo via a fragmenta\u00e7\u00e3o das atividades em m\u00f3dulos. Parte 1 \u00b6 Realizar em duplas Abra o site: http://www.falstad.com/circuit/ Arquivo Importar Arquivo Texto Copiar e colar o texto a seguir $ 1 0.000005 10.20027730826997 52 5 50 R 368 64 320 64 0 0 40 6 0 0 0.5 g 368 432 368 496 0 t 320 208 368 208 0 1 -2.4273420612275154 0.6036514634436996 100 w 368 160 368 192 0 t 320 256 368 256 0 1 0.5145133301062574 0.6054914059129475 100 w 368 224 368 240 0 w 368 272 368 288 0 w 368 368 368 384 0 r 320 208 240 208 0 2000 r 240 256 320 256 0 2000 L 240 208 208 208 0 1 false 3.6 0 L 240 256 208 256 0 1 false 3.6 0 r 368 288 368 368 0 2000 r 368 288 448 288 0 2000 t 448 288 496 288 0 1 -3.1219716002696054 -0.07756831971486333 100 t 448 368 496 368 0 1 -5.999999999780089 -2.9555967192253467 100 w 448 368 320 368 0 r 320 368 224 368 0 2000 w 496 272 496 160 0 w 496 160 368 160 0 w 368 160 368 64 0 w 496 352 544 352 0 w 544 352 544 160 0 w 544 160 496 160 0 w 496 304 576 304 0 w 496 384 576 384 0 w 576 384 576 304 0 r 576 400 576 464 0 1000 w 368 432 368 384 0 g 576 448 576 496 0 M 576 384 640 384 0 2.5 L 224 368 208 368 0 0 false 5 0 w 576 400 576 384 0 Voc\u00eas devem obter o seguinte diagrama: Tarefa Encontre a tabela verdade do circuito Encontrar a equa\u00e7\u00e3o l\u00f3gica Desenhar o diagrama da equa\u00e7\u00e3o (simplificado) Simula\u00e7\u00e3o Existem basicamente tr\u00eas n\u00edveis de simula\u00e7\u00e3o: a primeira, puramente l\u00f3gica utiliza de portas l\u00f3gicas \"ideais\" ( https://simulator.io/board ). Um simulador mais preciso ir\u00e1 utilizar transistores para a implementa\u00e7\u00e3o dessas portas l\u00f3gicas por\u00e9m n\u00e3o leva em considera\u00e7\u00e3o todos os fatores f\u00edsicos-eletr\u00f4nicos dos componentes ( http://falstad.com/circuit/ ). J\u00e1 um simulador que leva em considera\u00e7\u00e3o as propriedades dos componentes \u00e9 chamado de SPICE e ir\u00e1 gerar uma simula\u00e7\u00e3o mais precisa em termos f\u00edsicos do circuito original ( http://circuitlab.com ). Parte 2 \u00b6 Implementando porta l\u00f3gicas com transistores BJT. Material \u00b6 Cada grupo receber\u00e1: Duas protoboards Duas baterias 9V Jumpers macho-macho 12 transistores BJT-N BC337 24 resistores de 2k 6 LEDs coloridos (Vermelho, amarelo e verde) Trabalhando \u00b6 Warning Todos do grupo devem participar! O grupo deve se organizar e executar da melhor forma poss\u00edvel (com todos participando) os m\u00f3dulos a seguir, utilizando: Entradas: Utilizar como entrada do sistema (A,B,C,...) jumpers que estar\u00e3o hora conectados em GND (0) ou VCC (1) . Sa\u00eddas: A sa\u00edda final do sistema deve ser representada com um LED, sendo aceso indicando l\u00f3gica 1 e apagado l\u00f3gica 0 . Valida\u00e7\u00e3o: Uma tabela verdade do circuito deve ser apresentada e em aula demonstrado que o circuito representa a tabela. 1a - NOT \u00b6 Cada grupo deve realizar duas implementa\u00e7\u00f5es do circuito a seguir que representa uma NOT: Tip Utilize o datasheet do transistor para entender a montagem A imagem \u00e9 uma ilustra\u00e7\u00e3o do que voc\u00eas devem montar, utilizem como refer\u00eancia. Warning Se voc\u00ea perceber que algum transistor est\u00e1 aquecendo, desconecte a bateria e verifique novamente a montagem. Isso \u00e9 um sinal que alguma coisa est\u00e1 errada. Tarefa Levante a tabela verdade do circuito rec\u00e9m montado, \u00e9 uma not ? Tip O fio 'rosa' da imagem anterior representa a entrada do seu circuito, voc\u00ea deve colocar ela em GND para simular uma entrada 0 e em VCC para simular uma entrada 1 . 1b - NOT NOT \u00b6 Agora que as duas NOT foram implementadas, testadas e est\u00e3o funcionado, conecte a sa\u00edda de uma na entrada da outra. Isso vai fazer com que a sa\u00edda siga o valor de refer\u00eancia da entrada. Exerc\u00edcio 1b Levante a tabela verdade do circuito rec\u00e9m montado Tarefa Levante a tabela verdade do circuito rec\u00e9m montado. Qual porta l\u00f3gica \u00e9 essa? 2 - Equa\u00e7\u00e3o \u00b6 Implemente de forma a equa\u00e7\u00e3o l\u00f3gica a seguir em um circuito do tipo RTL. Q = A.(A.(A+B)+A.C) Warning Voc\u00eas devem conseguir paralelizar a execu\u00e7\u00e3o dessa equa\u00e7\u00e3o, para isso divida o grupo e cada um faz uma parte da equa\u00e7\u00e3o, depois junte tudo! Tip Da para simplificar? Antes de montar, fa\u00e7a o diagrama de blocos! Simular \u00e9 sempre bem vindo. Tarefa Levante a tabela verdade do circuito rec\u00e9m montado Refer\u00eancias \u00b6 A p\u00e1gina: http://hyperphysics.phy-astr.gsu.edu/hbase/Electronic/trangate.html#c4 possui exemplos de diversas portas l\u00f3gicas que podem ser implementadas via RTL. J\u00e1 o site https://www.electronics-tutorials.ws/logic/logic_1.html possui uma parte te\u00f3rica mais trabalhada.","title":"Lab 3: Transistores"},{"location":"A-Transistores-Lab-1/#lab-3-transistores","text":"Esse laborat\u00f3rio tem como objetivo trabalhar com os conceitos b\u00e1sicos de portas l\u00f3gicas do tipo RTL realizadas a base de transistores discretos do tipo BJT . Assim como desenvolver o trabalho em grupo via a fragmenta\u00e7\u00e3o das atividades em m\u00f3dulos.","title":"Lab 3: Transistores"},{"location":"A-Transistores-Lab-1/#parte-1","text":"Realizar em duplas Abra o site: http://www.falstad.com/circuit/ Arquivo Importar Arquivo Texto Copiar e colar o texto a seguir $ 1 0.000005 10.20027730826997 52 5 50 R 368 64 320 64 0 0 40 6 0 0 0.5 g 368 432 368 496 0 t 320 208 368 208 0 1 -2.4273420612275154 0.6036514634436996 100 w 368 160 368 192 0 t 320 256 368 256 0 1 0.5145133301062574 0.6054914059129475 100 w 368 224 368 240 0 w 368 272 368 288 0 w 368 368 368 384 0 r 320 208 240 208 0 2000 r 240 256 320 256 0 2000 L 240 208 208 208 0 1 false 3.6 0 L 240 256 208 256 0 1 false 3.6 0 r 368 288 368 368 0 2000 r 368 288 448 288 0 2000 t 448 288 496 288 0 1 -3.1219716002696054 -0.07756831971486333 100 t 448 368 496 368 0 1 -5.999999999780089 -2.9555967192253467 100 w 448 368 320 368 0 r 320 368 224 368 0 2000 w 496 272 496 160 0 w 496 160 368 160 0 w 368 160 368 64 0 w 496 352 544 352 0 w 544 352 544 160 0 w 544 160 496 160 0 w 496 304 576 304 0 w 496 384 576 384 0 w 576 384 576 304 0 r 576 400 576 464 0 1000 w 368 432 368 384 0 g 576 448 576 496 0 M 576 384 640 384 0 2.5 L 224 368 208 368 0 0 false 5 0 w 576 400 576 384 0 Voc\u00eas devem obter o seguinte diagrama: Tarefa Encontre a tabela verdade do circuito Encontrar a equa\u00e7\u00e3o l\u00f3gica Desenhar o diagrama da equa\u00e7\u00e3o (simplificado) Simula\u00e7\u00e3o Existem basicamente tr\u00eas n\u00edveis de simula\u00e7\u00e3o: a primeira, puramente l\u00f3gica utiliza de portas l\u00f3gicas \"ideais\" ( https://simulator.io/board ). Um simulador mais preciso ir\u00e1 utilizar transistores para a implementa\u00e7\u00e3o dessas portas l\u00f3gicas por\u00e9m n\u00e3o leva em considera\u00e7\u00e3o todos os fatores f\u00edsicos-eletr\u00f4nicos dos componentes ( http://falstad.com/circuit/ ). J\u00e1 um simulador que leva em considera\u00e7\u00e3o as propriedades dos componentes \u00e9 chamado de SPICE e ir\u00e1 gerar uma simula\u00e7\u00e3o mais precisa em termos f\u00edsicos do circuito original ( http://circuitlab.com ).","title":"Parte 1"},{"location":"A-Transistores-Lab-1/#parte-2","text":"Implementando porta l\u00f3gicas com transistores BJT.","title":"Parte 2"},{"location":"A-Transistores-Lab-1/#material","text":"Cada grupo receber\u00e1: Duas protoboards Duas baterias 9V Jumpers macho-macho 12 transistores BJT-N BC337 24 resistores de 2k 6 LEDs coloridos (Vermelho, amarelo e verde)","title":"Material"},{"location":"A-Transistores-Lab-1/#trabalhando","text":"Warning Todos do grupo devem participar! O grupo deve se organizar e executar da melhor forma poss\u00edvel (com todos participando) os m\u00f3dulos a seguir, utilizando: Entradas: Utilizar como entrada do sistema (A,B,C,...) jumpers que estar\u00e3o hora conectados em GND (0) ou VCC (1) . Sa\u00eddas: A sa\u00edda final do sistema deve ser representada com um LED, sendo aceso indicando l\u00f3gica 1 e apagado l\u00f3gica 0 . Valida\u00e7\u00e3o: Uma tabela verdade do circuito deve ser apresentada e em aula demonstrado que o circuito representa a tabela.","title":"Trabalhando"},{"location":"A-Transistores-Lab-1/#1a-not","text":"Cada grupo deve realizar duas implementa\u00e7\u00f5es do circuito a seguir que representa uma NOT: Tip Utilize o datasheet do transistor para entender a montagem A imagem \u00e9 uma ilustra\u00e7\u00e3o do que voc\u00eas devem montar, utilizem como refer\u00eancia. Warning Se voc\u00ea perceber que algum transistor est\u00e1 aquecendo, desconecte a bateria e verifique novamente a montagem. Isso \u00e9 um sinal que alguma coisa est\u00e1 errada. Tarefa Levante a tabela verdade do circuito rec\u00e9m montado, \u00e9 uma not ? Tip O fio 'rosa' da imagem anterior representa a entrada do seu circuito, voc\u00ea deve colocar ela em GND para simular uma entrada 0 e em VCC para simular uma entrada 1 .","title":"1a - NOT"},{"location":"A-Transistores-Lab-1/#1b-not-not","text":"Agora que as duas NOT foram implementadas, testadas e est\u00e3o funcionado, conecte a sa\u00edda de uma na entrada da outra. Isso vai fazer com que a sa\u00edda siga o valor de refer\u00eancia da entrada. Exerc\u00edcio 1b Levante a tabela verdade do circuito rec\u00e9m montado Tarefa Levante a tabela verdade do circuito rec\u00e9m montado. Qual porta l\u00f3gica \u00e9 essa?","title":"1b - NOT NOT"},{"location":"A-Transistores-Lab-1/#2-equacao","text":"Implemente de forma a equa\u00e7\u00e3o l\u00f3gica a seguir em um circuito do tipo RTL. Q = A.(A.(A+B)+A.C) Warning Voc\u00eas devem conseguir paralelizar a execu\u00e7\u00e3o dessa equa\u00e7\u00e3o, para isso divida o grupo e cada um faz uma parte da equa\u00e7\u00e3o, depois junte tudo! Tip Da para simplificar? Antes de montar, fa\u00e7a o diagrama de blocos! Simular \u00e9 sempre bem vindo. Tarefa Levante a tabela verdade do circuito rec\u00e9m montado","title":"2 - Equa\u00e7\u00e3o"},{"location":"A-Transistores-Lab-1/#referencias","text":"A p\u00e1gina: http://hyperphysics.phy-astr.gsu.edu/hbase/Electronic/trangate.html#c4 possui exemplos de diversas portas l\u00f3gicas que podem ser implementadas via RTL. J\u00e1 o site https://www.electronics-tutorials.ws/logic/logic_1.html possui uma parte te\u00f3rica mais trabalhada.","title":"Refer\u00eancias"},{"location":"Atendimento/","text":"Atendimento \u00b6 Os atendimentos de aula (individual ou de grupi) ser\u00e3o resolvidos no canal do seu grupo, em atendimento as d\u00favidas ser\u00e3o tiradas no canal #Geral . Tip Para acompanhar a evolu\u00e7\u00e3o da lista, siga a tabela a seguir: https://alinsperedu-my.sharepoint.com/:x:/g/personal/rafael_ferrao_al_insper_edu_br/EWZnLEOMh7xHnACwei2yi40BnMcnAs3j4HEC8sn_ZUtZ3Q?e=jMBiy2 Warning Toda a d\u00favida deve ser registrada nesse forms","title":"Atendimento"},{"location":"Atendimento/#atendimento","text":"Os atendimentos de aula (individual ou de grupi) ser\u00e3o resolvidos no canal do seu grupo, em atendimento as d\u00favidas ser\u00e3o tiradas no canal #Geral . Tip Para acompanhar a evolu\u00e7\u00e3o da lista, siga a tabela a seguir: https://alinsperedu-my.sharepoint.com/:x:/g/personal/rafael_ferrao_al_insper_edu_br/EWZnLEOMh7xHnACwei2yi40BnMcnAs3j4HEC8sn_ZUtZ3Q?e=jMBiy2 Warning Toda a d\u00favida deve ser registrada nesse forms","title":"Atendimento"},{"location":"Avaliacoes/","text":"Avalia\u00e7\u00f5es \u00b6 Informa\u00e7\u00f5es sobre as avalia\u00e7\u00f5es (e simulados) da disciplina: Calend\u00e1rio das avalia\u00e7\u00f5es \u00b6 AV1: 27/3 AV2: 29/4 (n\u00e3o vai ser durante a AI) AV3: 27/5 AV4: 19/6 (durante AF) AV1 \u00b6 Conte\u00fado \u00c1lgebra Booleana: Tabela Verdade/ Mapa de K./ Soma dos Produtos/ Produtos da Soma/ Simplifica\u00e7\u00e3o Alg\u00e9brica Resistor Transistor Logic (RTL) Dados Digitais: N\u00fameros bin\u00e1rios/ hexadecimal/ octal/ BCD/ ASCII Componentes Digitais: And/ ... / Mux/ Encolders (BCD/ 7seg/ Gray) Aritm\u00e9tica bin\u00e1ria: Complemento de um/ Complemento de Dois/ Soma bin\u00e1ria Aritm\u00e9tica Bin\u00e1ria - HW: Half-Adder/ Full-Adder/ Somadores ULA: Sinais de controle Projetos B - L\u00f3gica Combinacional C - ULA Simulado \u00b6 O simulado inicial liberado n\u00e3o previa que a avalia\u00e7\u00e3o seria online, por conta disso, criamos um outro simulado, com o formato da avalia\u00e7\u00e3o online. Nesse novo simulado, a parte conceitual ser\u00e1 realizado no BlackBoard e a parte de programa\u00e7\u00e3o continua no reposit\u00f3rio. Vers\u00e3o 1 (Antes do Corona): ' https://github.com/Insper/2020-1-Elementos-Simulado-AV1 ' Nessa nova vers\u00e3o da avalia\u00e7\u00e3o, iremos separar em duas partes: Vers\u00e3o 2 (Online): Simulados \u00b6","title":"Avalia\u00e7\u00f5es"},{"location":"Avaliacoes/#avaliacoes","text":"Informa\u00e7\u00f5es sobre as avalia\u00e7\u00f5es (e simulados) da disciplina:","title":"Avalia\u00e7\u00f5es"},{"location":"Avaliacoes/#calendario-das-avaliacoes","text":"AV1: 27/3 AV2: 29/4 (n\u00e3o vai ser durante a AI) AV3: 27/5 AV4: 19/6 (durante AF)","title":"Calend\u00e1rio das avalia\u00e7\u00f5es"},{"location":"Avaliacoes/#av1","text":"Conte\u00fado \u00c1lgebra Booleana: Tabela Verdade/ Mapa de K./ Soma dos Produtos/ Produtos da Soma/ Simplifica\u00e7\u00e3o Alg\u00e9brica Resistor Transistor Logic (RTL) Dados Digitais: N\u00fameros bin\u00e1rios/ hexadecimal/ octal/ BCD/ ASCII Componentes Digitais: And/ ... / Mux/ Encolders (BCD/ 7seg/ Gray) Aritm\u00e9tica bin\u00e1ria: Complemento de um/ Complemento de Dois/ Soma bin\u00e1ria Aritm\u00e9tica Bin\u00e1ria - HW: Half-Adder/ Full-Adder/ Somadores ULA: Sinais de controle Projetos B - L\u00f3gica Combinacional C - ULA","title":"AV1"},{"location":"Avaliacoes/#simulado","text":"O simulado inicial liberado n\u00e3o previa que a avalia\u00e7\u00e3o seria online, por conta disso, criamos um outro simulado, com o formato da avalia\u00e7\u00e3o online. Nesse novo simulado, a parte conceitual ser\u00e1 realizado no BlackBoard e a parte de programa\u00e7\u00e3o continua no reposit\u00f3rio. Vers\u00e3o 1 (Antes do Corona): ' https://github.com/Insper/2020-1-Elementos-Simulado-AV1 ' Nessa nova vers\u00e3o da avalia\u00e7\u00e3o, iremos separar em duas partes: Vers\u00e3o 2 (Online):","title":"Simulado"},{"location":"Avaliacoes/#simulados","text":"","title":"Simulados"},{"location":"Bulas_bck/","text":"Resumo Aulas \u00b6 CPU \u00b6 Laborat\u00f3rios G CPU Lab 14 Projeto associado G CPU Projeto Dicas testando Dicas rubrica B Assembly \u00b6 Sala Sala Casa V\u00eddeo aula Slides Handout Lista Conte\u00fado Slides Handout Lista Conte\u00fado Laborat\u00f3rios F Assembly Lab 11 F Assembly Lab 12 F Assembly Lab 13 Projeto associado F Assembly Projeto Leitura Cap\u00edtulo 7 - The Elements of Computing Systems https://docs.wixstatic.com/ugd/44046b_f0eaab042ba042dcb58f3e08b46bb4d7.pdf L\u00f3gica Sequencial \u00b6 Sala Sala Casa V\u00eddeo aula Slides Handout Lista Conte\u00fado Laborat\u00f3rio E Sequencial Lab 1 Projeto associado E Sequencial Projeto Leitura Cap\u00edtulo 3 - The Elements of Computing Systems https://docs.wixstatic.com/ugd/44046b_862828b3a3464a809cda6f44d9ad2ec9.pdf Unidade L\u00f3gica Aritm\u00e9tica \u00b6 Sala Sala Casa V\u00eddeo aula Slides Handout Lista Conte\u00fado Laborat\u00f3rios D ULA Lab 2 D ULA Lab 1 Projeto associado D ULA Projeto Leitura Cap\u00edtulo 2 - The Elements of Computing Systems https://docs.wixstatic.com/ugd/44046b_f0eaab042ba042dcb58f3e08b46bb4d7.pdf L\u00f3gica Combinacional \u00b6 Sala Sala Casa V\u00eddeo aula Slides Handout Lista Conte\u00fado Laborat\u00f3rio 4 Laborat\u00f3rio 5 Laborat\u00f3rio 6 Laborat\u00f3rio 7 Transistores e Circuitos Integrados \u00b6 04 - Circuitos Integrados Sala Sala Casa V\u00eddeo aula Slides Handout Lista Conte\u00fado sobre Circuitos Integrados 03 - Transistores Sala Sala Casa V\u00eddeo aula Slides Handout Lista Conte\u00fado Transistores MOSFET V\u00eddeos Extra Transistor Logic Gates Livros [Cap. 8 TOCCI, 2011] [Cap 7. FLOYD, 2007] \u00c1lgebra Booleana \u00b6 Sala Sala Casa V\u00eddeo aula Slides Handout Lista Conte\u00fado de \u00c1lgebra Booleana V\u00eddeos Extra Logic 101 (#11): Truth Tables Logic 101 (#12): Truth Table Practice Livros [Cap1. Cap2. NISAN, 2005] [Cap6. TOCCI, 2011] [Cap1. FLOYD, 2007] [LAING, 2004] Organiza\u00e7\u00e3o de Computadores \u00b6 Sala Sala Casa V\u00eddeo aula Slides Handout Lista V\u00eddeos Extra Khan Academy - Introducing How Computers Work","title":"Resumo Aulas"},{"location":"Bulas_bck/#resumo-aulas","text":"","title":"Resumo Aulas"},{"location":"Bulas_bck/#cpu","text":"Laborat\u00f3rios G CPU Lab 14 Projeto associado G CPU Projeto Dicas testando Dicas rubrica B","title":"CPU"},{"location":"Bulas_bck/#assembly","text":"Sala Sala Casa V\u00eddeo aula Slides Handout Lista Conte\u00fado Slides Handout Lista Conte\u00fado Laborat\u00f3rios F Assembly Lab 11 F Assembly Lab 12 F Assembly Lab 13 Projeto associado F Assembly Projeto Leitura Cap\u00edtulo 7 - The Elements of Computing Systems https://docs.wixstatic.com/ugd/44046b_f0eaab042ba042dcb58f3e08b46bb4d7.pdf","title":"Assembly"},{"location":"Bulas_bck/#logica-sequencial","text":"Sala Sala Casa V\u00eddeo aula Slides Handout Lista Conte\u00fado Laborat\u00f3rio E Sequencial Lab 1 Projeto associado E Sequencial Projeto Leitura Cap\u00edtulo 3 - The Elements of Computing Systems https://docs.wixstatic.com/ugd/44046b_862828b3a3464a809cda6f44d9ad2ec9.pdf","title":"L\u00f3gica Sequencial"},{"location":"Bulas_bck/#unidade-logica-aritmetica","text":"Sala Sala Casa V\u00eddeo aula Slides Handout Lista Conte\u00fado Laborat\u00f3rios D ULA Lab 2 D ULA Lab 1 Projeto associado D ULA Projeto Leitura Cap\u00edtulo 2 - The Elements of Computing Systems https://docs.wixstatic.com/ugd/44046b_f0eaab042ba042dcb58f3e08b46bb4d7.pdf","title":"Unidade L\u00f3gica Aritm\u00e9tica"},{"location":"Bulas_bck/#logica-combinacional","text":"Sala Sala Casa V\u00eddeo aula Slides Handout Lista Conte\u00fado Laborat\u00f3rio 4 Laborat\u00f3rio 5 Laborat\u00f3rio 6 Laborat\u00f3rio 7","title":"L\u00f3gica Combinacional"},{"location":"Bulas_bck/#transistores-e-circuitos-integrados","text":"04 - Circuitos Integrados Sala Sala Casa V\u00eddeo aula Slides Handout Lista Conte\u00fado sobre Circuitos Integrados 03 - Transistores Sala Sala Casa V\u00eddeo aula Slides Handout Lista Conte\u00fado Transistores MOSFET V\u00eddeos Extra Transistor Logic Gates Livros [Cap. 8 TOCCI, 2011] [Cap 7. FLOYD, 2007]","title":"Transistores e  Circuitos Integrados"},{"location":"Bulas_bck/#algebra-booleana","text":"Sala Sala Casa V\u00eddeo aula Slides Handout Lista Conte\u00fado de \u00c1lgebra Booleana V\u00eddeos Extra Logic 101 (#11): Truth Tables Logic 101 (#12): Truth Table Practice Livros [Cap1. Cap2. NISAN, 2005] [Cap6. TOCCI, 2011] [Cap1. FLOYD, 2007] [LAING, 2004]","title":"\u00c1lgebra Booleana"},{"location":"Bulas_bck/#organizacao-de-computadores","text":"Sala Sala Casa V\u00eddeo aula Slides Handout Lista V\u00eddeos Extra Khan Academy - Introducing How Computers Work","title":"Organiza\u00e7\u00e3o de Computadores"},{"location":"Criando-VM-com-HD-Externo-boot%C3%A1vel-no-VirtualBox-%28Mac-OS%29/","text":"Atrav\u00e9s deste guia, voc\u00ea conseguir\u00e1 criar uma m\u00e1quina virtual no VirtualBox que realiza o boot de um HD Externo, este roteiro foi feito e testado no Mac OS Mojave (mas com o devido cuidado funciona no Windows e Linux tamb\u00e9m). Antes, verifique se n\u00e3o h\u00e1 nenhum pendrive ou instalador montado (mostrando como unidade), se sim, ejete eles no Finder. Conecte o HD Externo de tipo A (MBR) no Mac OS, neste momento dever\u00e1 aparecer uma mensagem dizendo que o Mac OS n\u00e3o \u00e9 capaz de ler o disco, aten\u00e7\u00e3o, voc\u00ea deve clicar no bot\u00e3o 'Ignorar' Agora, abra o Disk Utility (Utilit\u00e1rio de Disco), ele pode ser encontrado pelo Spotlight ou pelo Launchpad, conforme imagem. Clique no bot\u00e3o Visualizar e selecione Mostrar todos os dispositivos . Agora no menu lateral, voc\u00ea deve ser capaz de ver o HD Externo conectado, caso contr\u00e1rio, verifique a conex\u00e3o USB e certifique-se que clicou no bot\u00e3o Ignorar ao conecta-lo. Selecione o HD Externo no Disk Utility e nas informa\u00e7\u00f5es exibidas procure por Dispositivo: diskN , sendo que haver\u00e1 um n\u00famero no lugar do N, no caso da foto \u00e9 disk2 . Verifique qual o n\u00famero em seu Mac OS. Agora, abra um Terminal. E execute o seguinte comando, substituindo o diskN pelo disco corresponde visto anteriormente (deve-se manter o /dev/ inicial). Ele ir\u00e1 solicitar a sua senha do Mac OS, por favor digite. sudo VBoxManage internalcommands createrawvmdk -filename Elementos.vmdk -rawdisk /dev/diskN Se tudo ocorrer bem, deve aparecer a mensagem RAW host disk access VMDK file Elementos.vmdk created successfully. Caso sim, continue, caso contr\u00e1rio, verifique o comando digitado. No passo 6, criamos um disco virtual, que na realidade n\u00e3o armazena dados e sim diz ao VirtualBox procurar pelo HD Externo. No entanto, este acesso ao HD Externo em n\u00edvel de parti\u00e7\u00f5es de boot, necessita de acesso de administrador ao computador. Portanto, vamos ter que abrir o VirtualBox como administrador no Mac OS. Primeiro, certifique-se que o VirtualBox est\u00e1 fechado completamente. Em seguida, no terminal novamente, digite o comando sudo /Applications/VirtualBox.app/Contents/MacOS/VirtualBox Com \u00eaxito, a janela do VirtualBox deve aparecer. Clique para criar uma nova m\u00e1quina virtual, clique em seguida no modo Expert , de um nome apropriado a m\u00e1quina virtual, na pasta da m\u00e1quina virtual, sugiro que mude o caminho para /Users/SEU_USUARIO/VirtualBox VMs (crie caso n\u00e3o exista). Ele ir\u00e1 utilizar esta pasta apenas para arquivos de configura\u00e7\u00e3o. Troque o Tipo para Linux e Vers\u00e3o para Ubuntu (64-bits). \u00c9 recomend\u00e1vel que aloque pelo menos 4GB (4096 MB) para o sistema. Na op\u00e7\u00e3o de Disco R\u00edgido, escolha a op\u00e7\u00e3o Utilizar um disco virtual existente, e selecione o arquivo Elementos.vmdk criado no passo 6. Clique em Criar. Clique para executar a m\u00e1quina virtual criada, se tudo ocorrer bem, voc\u00ea deve ver o boot do Ubuntu iniciando, n\u00e3o esque\u00e7a depois de ligar, de verificar a resolu\u00e7\u00e3o da tela e se a acelera\u00e7\u00e3o de v\u00eddeo est\u00e1 habilitada.","title":"Criando VM com HD Externo boot\u00e1vel no VirtualBox (Mac OS)"},{"location":"Exercicio-Algebra-Booleana-1/","text":"\u00c1lgebra Booleana - 1 \u00b6 Vers\u00e3o para impress\u00e3o. Resolu\u00e7\u00e3o Indique o nome dos elementos l\u00f3gicos a seguir: \u00b6 Tabela verdade \u00b6 A tabela verdade a seguir representa qual porta l\u00f3gica? A B OUT 0 0 0 0 1 1 1 0 1 1 1 0 A tabela verdade a seguir representa qual porta l\u00f3gica? A B OUT 0 0 1 0 1 1 1 0 1 1 1 0 \\newpage Aplicando a lei da Distributividade na express\u00e3o A(B+\\bar{C}+D) A(B+\\bar{C}+D) se tem: \u00b6 A . B + A . C + A . D A . B + A . C + A . D A . B . C . D A . B . C . D A + B + C + D A + B + C + D A B + A\\bar{C} + A . D A B + A\\bar{C} + A . D Aplicando o teorema de DeMorgan na express\u00e3o \\overline{ABC} \\overline{ABC} , obtem: \u00b6 \\bar{A}+\\bar{B}+\\bar{C} \\bar{A}+\\bar{B}+\\bar{C} \\overline{A+B+C} \\overline{A+B+C} A + \\bar{B} + C \\bar{C} A + \\bar{B} + C \\bar{C} A . (B+C) A . (B+C) Qual simplifica\u00e7\u00e3o est\u00e1 incorreta: \u00b6 \\overline{(\\bar{x}+\\bar{y})} = \\bar{\\bar{x}}*\\bar{y} = x * \\bar{y} \\overline{(\\bar{x}+\\bar{y})} = \\bar{\\bar{x}}*\\bar{y} = x * \\bar{y} x ( \\bar{x} + y ) = x . \\bar{x} + x . y = 0 + x . y = x . y x ( \\bar{x} + y ) = x . \\bar{x} + x . y = 0 + x . y = x . y x . y + x ( y + z ) = x . y + x . y + z = x . y + z x . y + x ( y + z ) = x . y + x . y + z = x . y + z \\bar{x} . \\bar{y} . z + \\bar{x} . y . z + x . \\bar{y} = \\bar{x} . z (\\bar{y} + y) + x . \\bar{y} = \\bar{x} . z + x . \\bar{y} \\bar{x} . \\bar{y} . z + \\bar{x} . y . z + x . \\bar{y} = \\bar{x} . z (\\bar{y} + y) + x . \\bar{y} = \\bar{x} . z + x . \\bar{y} Qual forma can\u00f4nica est\u00e1 correta? \u00b6 A B Q 0 0 1 0 1 0 1 0 0 1 1 1 Q = A \\bar{B} + A \\bar{B} Q = A \\bar{B} + A \\bar{B} Q = A+B * \\bar{A} \\bar{B} Q = A+B * \\bar{A} \\bar{B} Q = A . B Q = A . B Q = \\bar{A} . \\bar{B} + A . B Q = \\bar{A} . \\bar{B} + A . B Dado a seguinte tabela verdade (entradas A, B e C, e a sa\u00edda Q): \u00b6 A B C Q 0 0 0 1 0 0 1 0 0 1 0 0 0 1 1 1 1 0 0 1 1 0 1 0 1 1 0 0 1 1 1 1 Crie uma f\u00f3rmula em \u00e1lgebra booleana que represente a tabela via SoP e PoS. Simplifique SoP (interprete o resultado!) Desenhe um circuito usando os \u00edcones da \u00e1lgebra booleana. Quantas sa\u00eddas com 1 existem na tabela verdade que resulta na seguinte f\u00f3rmula de soma de produtos: \u00b6 A \\bar{B} \\bar{C} + \\bar{A} B C + \\bar{A} B \\bar{C} + A \\bar{B} \\bar{C} + A B C A \\bar{B} \\bar{C} + \\bar{A} B C + \\bar{A} B \\bar{C} + A \\bar{B} \\bar{C} + A B C Qual das seguintes op\u00e7\u00f5es \u00e9 uma caracter\u00edstica importante da forma can\u00f4nica de soma de produtos? \u00b6 Os circuitos l\u00f3gicos s\u00e3o reduzidos a nada mais do que simples portas AND e OR. Os tempos de atraso s\u00e3o muito reduzidas em rela\u00e7\u00e3o a outras formas. Nenhum sinal deve passar por mais de dois portas l\u00f3gicas, n\u00e3o incluindo inversores. O n\u00famero m\u00e1ximo de portas que qualquer sinal deve passar \u00e9 reduzido por um factor de dois. Qual \u00e9 a express\u00e3o em \u00e1lgebra booleana do seguinte circuito: \u00b6 Gere a Tabela Verdade das equa\u00e7\u00f5es a seguir: \u00b6 A . B + \\overline{B + A} A . B + \\overline{B + A} A \\oplus B A \\oplus B (A and B) or C (A and B) or C Converta a seguinte express\u00e3o em Soma de Produtos para Produto de Somas: \u00b6 A . B . C + A \\bar{B} \\bar{C} + A . \\bar{B} C + A . B . \\bar{C} + \\bar{A} . \\bar{B} . C A . B . C + A \\bar{B} \\bar{C} + A . \\bar{B} C + A . B . \\bar{C} + \\bar{A} . \\bar{B} . C Fa\u00e7a a tabela verdade Encontre o PoS Determine os valores de A, B, C e D que fazem a f\u00f3rmula a seguir ser igual a zero (Z = 0). \u00b6 Z = \\bar{A} + B + \\bar{C} + D Z = \\bar{A} + B + \\bar{C} + D Qual das seguintes propriedades da \u00e1lgebra booleana \u00e9 falsa: \u00b6 A . (\\bar{A} + B)= A . B A . (\\bar{A} + B)= A . B A + (A . B) = A A + (A . B) = A A + \\bar{A} = 1 A + \\bar{A} = 1 A . A = A A . A = A Simplifique a seguinte express\u00e3o: \u00b6 \\bar{A} \\bar{B} \\bar{C} + \\bar{A} B C + \\bar{A} B \\bar{C} + A \\bar{B} \\bar{C} + A B \\bar{C} \\bar{A} \\bar{B} \\bar{C} + \\bar{A} B C + \\bar{A} B \\bar{C} + A \\bar{B} \\bar{C} + A B \\bar{C} Encontre as equa\u00e7\u00f5es para os mapas de Karnaugh a seguir: \u00b6 \\newpage Crie o mapa de Karnaugh e encontre a equa\u00e7\u00e3o da tabela verdade a seguir. \u00b6 A B C OUT 0 0 0 1 0 0 1 1 0 1 0 0 0 1 1 1 1 0 0 0 1 0 1 1 1 1 0 0 1 1 1 0 Crie o mapa de Karnaugh da tabela verdade de quatro entradas. \u00b6 A B C D OUT 0 0 0 0 0 0 0 0 1 1 0 0 1 0 0 0 0 1 1 0 0 1 0 0 0 0 1 0 1 1 0 1 1 0 0 0 1 1 1 0 1 0 0 0 0 1 0 0 1 1 1 0 1 0 1 1 0 1 1 1 1 1 0 0 0 1 1 0 1 1 1 1 1 0 0 1 1 1 1 1 Crie o mapa de Karnaugh para a express\u00e3o a seguir e simplifique: \u00b6 ABC\\bar{D} + \\bar{A}\\bar{B}CD + A \\bar{B}\\bar{C}D + \\bar{A} + \\bar{B} + \\bar{C} + \\bar{D} ABC\\bar{D} + \\bar{A}\\bar{B}CD + A \\bar{B}\\bar{C}D + \\bar{A} + \\bar{B} + \\bar{C} + \\bar{D} A seguinte express\u00e3o foi resultado da forma can\u00f4nica do produto de somas de uma tabela verdade para a produ\u00e7\u00e3o de um circuito l\u00f3gico. O objetivo \u00e9 simplificar a \u00e1lgebra booleana dessa l\u00f3gica para o menor n\u00famero poss\u00edvel de portas, por\u00e9m visivelmente quem fez essa f\u00f3rmula n\u00e3o percebeu que se tivesse feito a soma de produtos j\u00e1 partiria com um n\u00famero menor de termos. Converta essa f\u00f3rmula para a soma de produtos e minimize ela. \u00b6 _ _ _ _ _ (A+B+C) * (A+B+C) * (A+B+C) * (A+B+C) * (A+B+C) Acabou? Os exerc\u00edcios n\u00e3o param por aqui, tem a parte 2!","title":"\u00c1lgebra Booleana - 1"},{"location":"Exercicio-Algebra-Booleana-1/#algebra-booleana-1","text":"Vers\u00e3o para impress\u00e3o. Resolu\u00e7\u00e3o","title":"\u00c1lgebra Booleana - 1"},{"location":"Exercicio-Algebra-Booleana-1/#indique-o-nome-dos-elementos-logicos-a-seguir","text":"","title":"Indique o nome dos elementos l\u00f3gicos a seguir:"},{"location":"Exercicio-Algebra-Booleana-1/#tabela-verdade","text":"A tabela verdade a seguir representa qual porta l\u00f3gica? A B OUT 0 0 0 0 1 1 1 0 1 1 1 0 A tabela verdade a seguir representa qual porta l\u00f3gica? A B OUT 0 0 1 0 1 1 1 0 1 1 1 0 \\newpage","title":"Tabela verdade"},{"location":"Exercicio-Algebra-Booleana-1/#aplicando-a-lei-da-distributividade-na-expressao-abbarcdabbarcd-se-tem","text":"A . B + A . C + A . D A . B + A . C + A . D A . B . C . D A . B . C . D A + B + C + D A + B + C + D A B + A\\bar{C} + A . D A B + A\\bar{C} + A . D","title":"Aplicando a lei da Distributividade na express\u00e3o A(B+\\bar{C}+D)A(B+\\bar{C}+D)\u00a0se tem:"},{"location":"Exercicio-Algebra-Booleana-1/#aplicando-o-teorema-de-demorgan-na-expressao-overlineabcoverlineabc-obtem","text":"\\bar{A}+\\bar{B}+\\bar{C} \\bar{A}+\\bar{B}+\\bar{C} \\overline{A+B+C} \\overline{A+B+C} A + \\bar{B} + C \\bar{C} A + \\bar{B} + C \\bar{C} A . (B+C) A . (B+C)","title":"Aplicando o teorema de DeMorgan na express\u00e3o\u00a0\\overline{ABC}\\overline{ABC}, obtem:"},{"location":"Exercicio-Algebra-Booleana-1/#qual-simplificacao-esta-incorreta","text":"\\overline{(\\bar{x}+\\bar{y})} = \\bar{\\bar{x}}*\\bar{y} = x * \\bar{y} \\overline{(\\bar{x}+\\bar{y})} = \\bar{\\bar{x}}*\\bar{y} = x * \\bar{y} x ( \\bar{x} + y ) = x . \\bar{x} + x . y = 0 + x . y = x . y x ( \\bar{x} + y ) = x . \\bar{x} + x . y = 0 + x . y = x . y x . y + x ( y + z ) = x . y + x . y + z = x . y + z x . y + x ( y + z ) = x . y + x . y + z = x . y + z \\bar{x} . \\bar{y} . z + \\bar{x} . y . z + x . \\bar{y} = \\bar{x} . z (\\bar{y} + y) + x . \\bar{y} = \\bar{x} . z + x . \\bar{y} \\bar{x} . \\bar{y} . z + \\bar{x} . y . z + x . \\bar{y} = \\bar{x} . z (\\bar{y} + y) + x . \\bar{y} = \\bar{x} . z + x . \\bar{y}","title":"Qual simplifica\u00e7\u00e3o est\u00e1 incorreta:"},{"location":"Exercicio-Algebra-Booleana-1/#qual-forma-canonica-esta-correta","text":"A B Q 0 0 1 0 1 0 1 0 0 1 1 1 Q = A \\bar{B} + A \\bar{B} Q = A \\bar{B} + A \\bar{B} Q = A+B * \\bar{A} \\bar{B} Q = A+B * \\bar{A} \\bar{B} Q = A . B Q = A . B Q = \\bar{A} . \\bar{B} + A . B Q = \\bar{A} . \\bar{B} + A . B","title":"Qual forma can\u00f4nica est\u00e1 correta?"},{"location":"Exercicio-Algebra-Booleana-1/#dado-a-seguinte-tabela-verdade-entradas-a-b-e-c-e-a-saida-q","text":"A B C Q 0 0 0 1 0 0 1 0 0 1 0 0 0 1 1 1 1 0 0 1 1 0 1 0 1 1 0 0 1 1 1 1 Crie uma f\u00f3rmula em \u00e1lgebra booleana que represente a tabela via SoP e PoS. Simplifique SoP (interprete o resultado!) Desenhe um circuito usando os \u00edcones da \u00e1lgebra booleana.","title":"Dado a seguinte tabela verdade (entradas A, B e C, e a sa\u00edda Q):"},{"location":"Exercicio-Algebra-Booleana-1/#quantas-saidas-com-1-existem-na-tabela-verdade-que-resulta-na-seguinte-formula-de-soma-de-produtos","text":"A \\bar{B} \\bar{C} + \\bar{A} B C + \\bar{A} B \\bar{C} + A \\bar{B} \\bar{C} + A B C A \\bar{B} \\bar{C} + \\bar{A} B C + \\bar{A} B \\bar{C} + A \\bar{B} \\bar{C} + A B C","title":"Quantas sa\u00eddas com 1 existem na tabela verdade que resulta na seguinte f\u00f3rmula de soma de produtos:"},{"location":"Exercicio-Algebra-Booleana-1/#qual-das-seguintes-opcoes-e-uma-caracteristica-importante-da-forma-canonica-de-soma-de-produtos","text":"Os circuitos l\u00f3gicos s\u00e3o reduzidos a nada mais do que simples portas AND e OR. Os tempos de atraso s\u00e3o muito reduzidas em rela\u00e7\u00e3o a outras formas. Nenhum sinal deve passar por mais de dois portas l\u00f3gicas, n\u00e3o incluindo inversores. O n\u00famero m\u00e1ximo de portas que qualquer sinal deve passar \u00e9 reduzido por um factor de dois.","title":"Qual das seguintes op\u00e7\u00f5es \u00e9 uma caracter\u00edstica importante da forma can\u00f4nica de soma de produtos?"},{"location":"Exercicio-Algebra-Booleana-1/#qual-e-a-expressao-em-algebra-booleana-do-seguinte-circuito","text":"","title":"Qual \u00e9 a express\u00e3o em \u00e1lgebra booleana do seguinte circuito:"},{"location":"Exercicio-Algebra-Booleana-1/#gere-a-tabela-verdade-das-equacoes-a-seguir","text":"A . B + \\overline{B + A} A . B + \\overline{B + A} A \\oplus B A \\oplus B (A and B) or C (A and B) or C","title":"Gere a Tabela Verdade das equa\u00e7\u00f5es a seguir:"},{"location":"Exercicio-Algebra-Booleana-1/#converta-a-seguinte-expressao-em-soma-de-produtos-para-produto-de-somas","text":"A . B . C + A \\bar{B} \\bar{C} + A . \\bar{B} C + A . B . \\bar{C} + \\bar{A} . \\bar{B} . C A . B . C + A \\bar{B} \\bar{C} + A . \\bar{B} C + A . B . \\bar{C} + \\bar{A} . \\bar{B} . C Fa\u00e7a a tabela verdade Encontre o PoS","title":"Converta a seguinte express\u00e3o em Soma de Produtos para Produto de Somas:"},{"location":"Exercicio-Algebra-Booleana-1/#determine-os-valores-de-a-b-c-e-d-que-fazem-a-formula-a-seguir-ser-igual-a-zero-z-0","text":"Z = \\bar{A} + B + \\bar{C} + D Z = \\bar{A} + B + \\bar{C} + D","title":"Determine os valores de A, B, C e D que fazem a f\u00f3rmula a seguir ser igual a zero (Z = 0)."},{"location":"Exercicio-Algebra-Booleana-1/#qual-das-seguintes-propriedades-da-algebra-booleana-e-falsa","text":"A . (\\bar{A} + B)= A . B A . (\\bar{A} + B)= A . B A + (A . B) = A A + (A . B) = A A + \\bar{A} = 1 A + \\bar{A} = 1 A . A = A A . A = A","title":"Qual das seguintes propriedades da \u00e1lgebra booleana \u00e9 falsa:"},{"location":"Exercicio-Algebra-Booleana-1/#simplifique-a-seguinte-expressao","text":"\\bar{A} \\bar{B} \\bar{C} + \\bar{A} B C + \\bar{A} B \\bar{C} + A \\bar{B} \\bar{C} + A B \\bar{C} \\bar{A} \\bar{B} \\bar{C} + \\bar{A} B C + \\bar{A} B \\bar{C} + A \\bar{B} \\bar{C} + A B \\bar{C}","title":"Simplifique a seguinte express\u00e3o:"},{"location":"Exercicio-Algebra-Booleana-1/#encontre-as-equacoes-para-os-mapas-de-karnaugh-a-seguir","text":"\\newpage","title":"Encontre as equa\u00e7\u00f5es para os mapas de Karnaugh a seguir:"},{"location":"Exercicio-Algebra-Booleana-1/#crie-o-mapa-de-karnaugh-e-encontre-a-equacao-da-tabela-verdade-a-seguir","text":"A B C OUT 0 0 0 1 0 0 1 1 0 1 0 0 0 1 1 1 1 0 0 0 1 0 1 1 1 1 0 0 1 1 1 0","title":"Crie o mapa de Karnaugh e encontre a equa\u00e7\u00e3o da tabela verdade a seguir."},{"location":"Exercicio-Algebra-Booleana-1/#crie-o-mapa-de-karnaugh-da-tabela-verdade-de-quatro-entradas","text":"A B C D OUT 0 0 0 0 0 0 0 0 1 1 0 0 1 0 0 0 0 1 1 0 0 1 0 0 0 0 1 0 1 1 0 1 1 0 0 0 1 1 1 0 1 0 0 0 0 1 0 0 1 1 1 0 1 0 1 1 0 1 1 1 1 1 0 0 0 1 1 0 1 1 1 1 1 0 0 1 1 1 1 1","title":"Crie o mapa de Karnaugh da tabela verdade de quatro entradas."},{"location":"Exercicio-Algebra-Booleana-1/#crie-o-mapa-de-karnaugh-para-a-expressao-a-seguir-e-simplifique","text":"ABC\\bar{D} + \\bar{A}\\bar{B}CD + A \\bar{B}\\bar{C}D + \\bar{A} + \\bar{B} + \\bar{C} + \\bar{D} ABC\\bar{D} + \\bar{A}\\bar{B}CD + A \\bar{B}\\bar{C}D + \\bar{A} + \\bar{B} + \\bar{C} + \\bar{D}","title":"Crie o mapa de Karnaugh para a express\u00e3o a seguir e simplifique:"},{"location":"Exercicio-Algebra-Booleana-1/#a-seguinte-expressao-foi-resultado-da-forma-canonica-do-produto-de-somas-de-uma-tabela-verdade-para-a-producao-de-um-circuito-logico-o-objetivo-e-simplificar-a-algebra-booleana-dessa-logica-para-o-menor-numero-possivel-de-portas-porem-visivelmente-quem-fez-essa-formula-nao-percebeu-que-se-tivesse-feito-a-soma-de-produtos-ja-partiria-com-um-numero-menor-de-termos-converta-essa-formula-para-a-soma-de-produtos-e-minimize-ela","text":"_ _ _ _ _ (A+B+C) * (A+B+C) * (A+B+C) * (A+B+C) * (A+B+C) Acabou? Os exerc\u00edcios n\u00e3o param por aqui, tem a parte 2!","title":"A seguinte express\u00e3o foi resultado da forma can\u00f4nica do produto de somas de uma tabela verdade para a produ\u00e7\u00e3o de um circuito l\u00f3gico. O objetivo \u00e9 simplificar a \u00e1lgebra booleana dessa l\u00f3gica para o menor n\u00famero poss\u00edvel de portas, por\u00e9m visivelmente quem fez essa f\u00f3rmula n\u00e3o percebeu que se tivesse feito a soma de produtos j\u00e1 partiria com um n\u00famero menor de termos. Converta essa f\u00f3rmula para a soma de produtos e minimize ela."},{"location":"Exercicio-Algebra-Booleana-2/","text":"\u00c1lgebra Booleana - 2 \u00b6 Vers\u00e3o para impress\u00e3o. Simplifique o circuito a seguir: \u00b6 (desenhe o circuito simplificado) Econtre a equa\u00e7\u00e3o dos mapas de K. a seguir: \u00b6 (TOCCCI - pg. 178) X representa: Tanto faz, pode assumir 1 ou 0 . Voc\u00ea deve decidir o que for melhor para a simplifica\u00e7\u00e3o. \\newpage Detector de moedas \u00b6 Um detector de moedas em uma m\u00e1quina de venda aceita quarters, dimes e nickels e ativa o sinal correspondente (Q,D,N) apenas com a moeda correta. \u00c9 fisicamente imposs\u00edvel m\u00faltiplas moedas estarem presentes ao mesmo tempo. Um circuito digital utiliza os sinais Q,D e N como entradas e produz um n\u00famero bin\u00e1rio representando o valor da moeda, como mostrado no circuito a seguir. Desenvolva um circuito (diagrama l\u00f3gico) que resolva o problema (dica: use um MUX) Moeda Valor Quarter 25 Dime 10 Nickel 5 \\newpage Impressora \u00b6 A fig. a seguir mostra quatro chaves que fazem parte do circuito de controle em uma m\u00e1quina copiadora. As chaves est\u00e3o posicionadas ao longo da trajet\u00f3ria do papel dentro da m\u00e1quina. Cada chave est\u00e1 no estado normal aberta e, quando o papel passa sobre a chave, ela \u00e9 fechada. \u00c9 imposs\u00edvel o fechamento simult\u00e2neo das chaves SW1 e SW4. Projete um circuito l\u00f3gico que gere em sa\u00edda em n\u00edvel ALTO sempre que duas ou mais chaves estiverem fechadas ao mesmo tempo. Utilize o mapa de Karnaught. (TOCCI - pg. 179) \\newpage SevenSeg \u00b6 Encontre as equa\u00e7\u00f5es que regem os segmentos 0 e 6 de um display de 7 segmento. Warning A l\u00f3gica de acender um display \u00e9 invertida (por ser do tipo ando comum), para acender um segmento \u00e9 necess\u00e1rio colocar 0 na linha e para apagar 1 .","title":"\u00c1lgebra Booleana - 2"},{"location":"Exercicio-Algebra-Booleana-2/#algebra-booleana-2","text":"Vers\u00e3o para impress\u00e3o.","title":"\u00c1lgebra Booleana - 2"},{"location":"Exercicio-Algebra-Booleana-2/#simplifique-o-circuito-a-seguir","text":"(desenhe o circuito simplificado)","title":"Simplifique o circuito a seguir:"},{"location":"Exercicio-Algebra-Booleana-2/#econtre-a-equacao-dos-mapas-de-k-a-seguir","text":"(TOCCCI - pg. 178) X representa: Tanto faz, pode assumir 1 ou 0 . Voc\u00ea deve decidir o que for melhor para a simplifica\u00e7\u00e3o. \\newpage","title":"Econtre a equa\u00e7\u00e3o dos mapas de K. a seguir:"},{"location":"Exercicio-Algebra-Booleana-2/#detector-de-moedas","text":"Um detector de moedas em uma m\u00e1quina de venda aceita quarters, dimes e nickels e ativa o sinal correspondente (Q,D,N) apenas com a moeda correta. \u00c9 fisicamente imposs\u00edvel m\u00faltiplas moedas estarem presentes ao mesmo tempo. Um circuito digital utiliza os sinais Q,D e N como entradas e produz um n\u00famero bin\u00e1rio representando o valor da moeda, como mostrado no circuito a seguir. Desenvolva um circuito (diagrama l\u00f3gico) que resolva o problema (dica: use um MUX) Moeda Valor Quarter 25 Dime 10 Nickel 5 \\newpage","title":"Detector de moedas"},{"location":"Exercicio-Algebra-Booleana-2/#impressora","text":"A fig. a seguir mostra quatro chaves que fazem parte do circuito de controle em uma m\u00e1quina copiadora. As chaves est\u00e3o posicionadas ao longo da trajet\u00f3ria do papel dentro da m\u00e1quina. Cada chave est\u00e1 no estado normal aberta e, quando o papel passa sobre a chave, ela \u00e9 fechada. \u00c9 imposs\u00edvel o fechamento simult\u00e2neo das chaves SW1 e SW4. Projete um circuito l\u00f3gico que gere em sa\u00edda em n\u00edvel ALTO sempre que duas ou mais chaves estiverem fechadas ao mesmo tempo. Utilize o mapa de Karnaught. (TOCCI - pg. 179) \\newpage","title":"Impressora"},{"location":"Exercicio-Algebra-Booleana-2/#sevenseg","text":"Encontre as equa\u00e7\u00f5es que regem os segmentos 0 e 6 de um display de 7 segmento. Warning A l\u00f3gica de acender um display \u00e9 invertida (por ser do tipo ando comum), para acender um segmento \u00e9 necess\u00e1rio colocar 0 na linha e para apagar 1 .","title":"SevenSeg"},{"location":"Exercicio-Dados-1/","text":"Dados Digitais - 1 \u00b6 Vers\u00e3o para impress\u00e3o. Resolu\u00e7\u00e3o Conte\u00fado: N\u00famerio bin\u00e1rios; Hexadecimal; Octal; Convers\u00e3o entre as diferentes bases; BCD; ASCII; Bits \u00b6 Quantos bit possuem em um ... ? nibble: byte: halfword: word: Converta de decimal para bin\u00e1rio, indicar a quantidade de bits \u00b6 \\large Decimal bin\u00e1rio bits 0 0b000 (exemplo) . 3 1 2 3 4 5 6 7 8 9 10 115 256 1027 \\newpage Converta de bin\u00e1rio para decimal \u00b6 Bin\u00e1rio Decimal 0b100 4 (exemplo) 0b0 0b10011 0b11111 0b01010 Preencha a tabela referente a n\u00fameros em hexadecimal \u00b6 Decimal Hexadecimal 0 0x0000 (exemplo) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 \\newpage Converta de bin\u00e1rio para Hexadecimal \u00b6 Bin\u00e1rio Decimal 0b0001 0x1 (exemplo) 0b1111 0b10100011 0b11010 Converta de hexa para decimal \u00b6 Hexadecimal Bin\u00e1rio 0x0003 0x1 (exemplo) 0xA 0x55 0x0101 Converta de decimal para octal \u00b6 Decimal octal 0 0o0 (exemplo) 1 2 3 4 5 6 7 8 9 10 11 \\normalsize \\newpage Converta de decimal para BCD \u00b6 Decimal BCD 50 0101 0000 (exemplo) 1 103 904","title":"Dados Digitais - 1"},{"location":"Exercicio-Dados-1/#dados-digitais-1","text":"Vers\u00e3o para impress\u00e3o. Resolu\u00e7\u00e3o Conte\u00fado: N\u00famerio bin\u00e1rios; Hexadecimal; Octal; Convers\u00e3o entre as diferentes bases; BCD; ASCII;","title":"Dados Digitais - 1"},{"location":"Exercicio-Dados-1/#bits","text":"Quantos bit possuem em um ... ? nibble: byte: halfword: word:","title":"Bits"},{"location":"Exercicio-Dados-1/#converta-de-decimal-para-binario-indicar-a-quantidade-de-bits","text":"\\large Decimal bin\u00e1rio bits 0 0b000 (exemplo) . 3 1 2 3 4 5 6 7 8 9 10 115 256 1027 \\newpage","title":"Converta de decimal para bin\u00e1rio, indicar a quantidade de bits"},{"location":"Exercicio-Dados-1/#converta-de-binario-para-decimal","text":"Bin\u00e1rio Decimal 0b100 4 (exemplo) 0b0 0b10011 0b11111 0b01010","title":"Converta de bin\u00e1rio para decimal"},{"location":"Exercicio-Dados-1/#preencha-a-tabela-referente-a-numeros-em-hexadecimal","text":"Decimal Hexadecimal 0 0x0000 (exemplo) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 \\newpage","title":"Preencha a tabela referente a n\u00fameros em hexadecimal"},{"location":"Exercicio-Dados-1/#converta-de-binario-para-hexadecimal","text":"Bin\u00e1rio Decimal 0b0001 0x1 (exemplo) 0b1111 0b10100011 0b11010","title":"Converta de bin\u00e1rio para Hexadecimal"},{"location":"Exercicio-Dados-1/#converta-de-hexa-para-decimal","text":"Hexadecimal Bin\u00e1rio 0x0003 0x1 (exemplo) 0xA 0x55 0x0101","title":"Converta de hexa para decimal"},{"location":"Exercicio-Dados-1/#converta-de-decimal-para-octal","text":"Decimal octal 0 0o0 (exemplo) 1 2 3 4 5 6 7 8 9 10 11 \\normalsize \\newpage","title":"Converta de decimal para octal"},{"location":"Exercicio-Dados-1/#converta-de-decimal-para-bcd","text":"Decimal BCD 50 0101 0000 (exemplo) 1 103 904","title":"Converta de decimal para BCD"},{"location":"Exercicio-Dados-2/","text":"Dados Digitais - 2 \u00b6 Vers\u00e3o para impress\u00e3o. Mem\u00f3ria 1 \u00b6 Mem\u00f3ria 2 \u00b6 Voc\u00ea est\u00e1 debugando uma comunica\u00e7\u00e3o serial entre dois equipamentos e foi capaz de capturar a seguinte sequ\u00eancia de dados: Qual foi a mensagem enviada? Voc\u00ea sabe que a mensagem enviada est\u00e1 codificada em ASCII. 7 Segmentos \u00b6 O display de sete segmentos \u00e9 um componente muito utilizado em sistemas eletr\u00f4nicos, com ele conseguimos exibir valor d\u00edgitos num\u00e9ricos: Fonte: https://www.sunfounder.com/media/wysiwyg/swatches/super-kit-v2-for-Arduino/10_7_seg_display/ Por exemplo, para exibir o valor 7 \u00e9 necess\u00e1rio acionar os segmentos: a , b , c : Utilize o site: http://www.uize.com/examples/seven-segment-display.html para brincar um pouco. Os segmentos normalmente formam um vetor do tipo g , f , e , d , c , b , a . O Valor 7 seria codificado em: 0b0000111 -> 0x07 . Voc\u00ea est\u00e1 fazendo um projeto que possui um display de 7 segmentos, mas infelizmente ele est\u00e1 queimado (pois \u00e9, essas coisas acontecem), voc\u00ea foi incumbido de descobrir quais valores estavam sendo enviados para ele. Para isso voc\u00ea plugou um analisador de sinais nas trilhas que iam para o display, e foi capaz de obter a seguinte forma de onda: Voc\u00ea deve descobrir quais s\u00e3o os tr\u00eas valores (fachas) que estariam sendo exibidos no display! Octal \u00b6 Voc\u00ea quer modificar as permiss\u00f5es de um arquivo no seu Linux para: Usu\u00e1rio: Leitura/Escrita e execu\u00e7\u00e3o Grupo: Escrita e Leitura Outros: Leitura Preencha o comando a seguir, com os valores corretos (em octal) para isso: $ chmod ________ FILE.py Tip Consulte a teoria.","title":"Dados Digitais - 2"},{"location":"Exercicio-Dados-2/#dados-digitais-2","text":"Vers\u00e3o para impress\u00e3o.","title":"Dados Digitais - 2"},{"location":"Exercicio-Dados-2/#memoria-1","text":"","title":"Mem\u00f3ria 1"},{"location":"Exercicio-Dados-2/#memoria-2","text":"Voc\u00ea est\u00e1 debugando uma comunica\u00e7\u00e3o serial entre dois equipamentos e foi capaz de capturar a seguinte sequ\u00eancia de dados: Qual foi a mensagem enviada? Voc\u00ea sabe que a mensagem enviada est\u00e1 codificada em ASCII.","title":"Mem\u00f3ria 2"},{"location":"Exercicio-Dados-2/#7-segmentos","text":"O display de sete segmentos \u00e9 um componente muito utilizado em sistemas eletr\u00f4nicos, com ele conseguimos exibir valor d\u00edgitos num\u00e9ricos: Fonte: https://www.sunfounder.com/media/wysiwyg/swatches/super-kit-v2-for-Arduino/10_7_seg_display/ Por exemplo, para exibir o valor 7 \u00e9 necess\u00e1rio acionar os segmentos: a , b , c : Utilize o site: http://www.uize.com/examples/seven-segment-display.html para brincar um pouco. Os segmentos normalmente formam um vetor do tipo g , f , e , d , c , b , a . O Valor 7 seria codificado em: 0b0000111 -> 0x07 . Voc\u00ea est\u00e1 fazendo um projeto que possui um display de 7 segmentos, mas infelizmente ele est\u00e1 queimado (pois \u00e9, essas coisas acontecem), voc\u00ea foi incumbido de descobrir quais valores estavam sendo enviados para ele. Para isso voc\u00ea plugou um analisador de sinais nas trilhas que iam para o display, e foi capaz de obter a seguinte forma de onda: Voc\u00ea deve descobrir quais s\u00e3o os tr\u00eas valores (fachas) que estariam sendo exibidos no display!","title":"7 Segmentos"},{"location":"Exercicio-Dados-2/#octal","text":"Voc\u00ea quer modificar as permiss\u00f5es de um arquivo no seu Linux para: Usu\u00e1rio: Leitura/Escrita e execu\u00e7\u00e3o Grupo: Escrita e Leitura Outros: Leitura Preencha o comando a seguir, com os valores corretos (em octal) para isso: $ chmod ________ FILE.py Tip Consulte a teoria.","title":"Octal"},{"location":"F-Assembly-Dicas/","text":"F - Assembly - Dicas \u00b6 A seguir algumas dicas para atingir os conceitos B e A nessa entrega. Rubrica - B \u00b6 Fa\u00e7a um programa em python que gere automaticamente um c\u00f3digo em assembly de um texto. Existem v\u00e1rias alternativas: A entrada do programa \u00e9 um .png e a sa\u00edda \u00e9 um c\u00f3digo em nasm A entrada do programa \u00e9 uma tabela do excel e a sa\u00edda \u00e9 um c\u00f3digo em nasm Rubrica - A \u00b6 N\u00e3o precisa ser um jogo complexo, pode ser algo como um \"Genius\" com os LEDs e bot\u00f5es.","title":"F - Assembly - Dicas"},{"location":"F-Assembly-Dicas/#f-assembly-dicas","text":"A seguir algumas dicas para atingir os conceitos B e A nessa entrega.","title":"F - Assembly - Dicas"},{"location":"F-Assembly-Dicas/#rubrica-b","text":"Fa\u00e7a um programa em python que gere automaticamente um c\u00f3digo em assembly de um texto. Existem v\u00e1rias alternativas: A entrada do programa \u00e9 um .png e a sa\u00edda \u00e9 um c\u00f3digo em nasm A entrada do programa \u00e9 uma tabela do excel e a sa\u00edda \u00e9 um c\u00f3digo em nasm","title":"Rubrica - B"},{"location":"F-Assembly-Dicas/#rubrica-a","text":"N\u00e3o precisa ser um jogo complexo, pode ser algo como um \"Genius\" com os LEDs e bot\u00f5es.","title":"Rubrica - A"},{"location":"F-Assembly-Lab-1/","text":"Ao final desse lab voc\u00ea deve ser capaz de: Usar o simulador gr\u00e1fico Fazer pequenas modifica\u00e7\u00f5es em um c\u00f3digo assembly Executar script de teste do projeto F - Assembly Antes de come\u00e7ar o Scrum deve atualizar o fork e todos devem atualizar o Z01-tools. Voc\u00ea \u00e9 Scrum Master e n\u00e3o sabe por onde come\u00e7ar? De uma olhada nessas dicas: Vixi! Sou Scrum Master Atualizem o Z01-Tools! submodule antes de come\u00e7ar (TODOS DEVEM FAZER) (realizar em dupla/ individual) Simulador \u00b6 Nosso c\u00f3digo assembly pode ser executado em hardware de verdade (FPGA) por\u00e9m nesse primeiro momento iremos trabalhar em um ambiente simulado que nos dar\u00e1 maior facilidade de programa\u00e7\u00e3o e depura\u00e7\u00e3o. Um pouco de contexto: O livro texto (The Elements Of Computer System) disponibiliza um simulador da CPU original todo escrito em java, esse c\u00f3digo \u00e9 fechado e n\u00e3o permite nenhuma customiza\u00e7\u00e3o. Em 2017 o Prof. Luciano Pereiro iniciou a cria\u00e7\u00e3o de um simulador Z0 (vers\u00e3o anterior) tamb\u00e9m em Java, onde ter\u00edamos controle total do software, o simulador funcionava. Percebemos alguns pontos negativos de utilizar um simulador em Java (ou qualquer outra linguagem) sendo o principal: Qualquer altera\u00e7\u00e3o no Hardware iria demandar uma altera\u00e7\u00e3o no simulador, sendo necess\u00e1rio mantermos dois projetos independentes e sincronizados. Nesse curso, iremos utilizar um simulador que utiliza o nosso pr\u00f3prio c\u00f3digo VHDL como descri\u00e7\u00e3o da CPU (e de tudo envolvido), uma altera\u00e7\u00e3o no hardware (VHDL) ir\u00e1 automaticamente alterar o simulador e o comportamento do computador. Para isso, fazemos uso do ModelSim, um software da Mentor Graphics que executa simula\u00e7\u00f2es em VHDL (o mesmo utilizado nos projetos anterios), desenvolvemos uma s\u00e9rie de APIs e configura\u00e7\u00f5es desse simulador para funcionar para a disciplina. As APIS de interface do simulador foram desenvolvidas por mim (vhdl/ tcl/ python) e a interface gr\u00e1fica pelo Prof. Eduardo Marossi (python/ qt5). O simulador possui a estrutura ilustrada a seguir: O simulador possui como entradas (para cada simula\u00e7\u00e3o): a arquitetura do computador (hardware); o conte\u00fado da mem\u00f3ria RAMl o conte\u00fado da mem\u00f3ria ROM e um tempo de execu\u00e7\u00e3o. Ap\u00f3s o t\u00e9rmino da simula\u00e7\u00e3o \u00e9 exportado diversos sinais internos da CPU, o estado final da mem\u00f3ria RAM e ROM. Esses sinais s\u00e3o ent\u00e3o lidos pela interface gr\u00e1fica e exibida de uma forma amig\u00e1vel. Arquivos \u00b6 O simulador est\u00e1 localizado nas pastas Z01-tools/ : Z01-Simulator-GUI : Parte gr\u00e1fica do simulador Z01-Simulator-RTL : Hardware a ser executado no modelsim para executar o programa. Para inicializar o simulador basta executar o script localizado na pasta do projeto F: ./F-Assembly/Z01simulador.py Interface do Simulador \u00b6 O simulador possui a interface a seguir, onde a coluna da esquerda \u00e9 referente a mem\u00f3ria ROM (programa), a coluna da direita referente a mem\u00f3ria RAM (dados). Toda vez que houver uma altera\u00e7\u00e3o em algum dos par\u00e2metros do simulador (RAM/ROM/Instru\u00e7\u00f5es,...) o programa ser\u00e1 novamente executado no simulador para obtermos um resultado atualizado. Isso pode dar a sensa\u00e7\u00e3o de \"lerdeza\" mas lembre da complexidade do sistema: estamos executando um programa em um hardware inteiramente simulado no computador de voc\u00eas. Programando \u00b6 Abra o simulador e insira o seguinte c\u00f3digo nasm (na parte referente a ROM), uma instru\u00e7\u00e3o por linha: leaw $ R1 , % A movw ( % A ), % D leaw $ R0 , % A addw ( % A ), % D , % S leaw $ R2 , % A movw % S , ( % A ) Esse c\u00f3digo soma o valor que est\u00e1 salvo na mem\u00f3ria RAM endere\u00e7o 0 com o valor da mem\u00f3ria RAM endere\u00e7o 1 e salva no endere\u00e7o 0: RAM[2] = RAM[0] + RAM[1] R0, R1, ... ? \u00b6 R0**, ** R0**, ** R1 , ... s\u00e3o nomes pr\u00e9 definidos de endere\u00e7os de mem\u00f3ria. O R0 indica o endere\u00e7o de mem\u00f3ria 0, R1 o endere\u00e7o de mem\u00f3ria 1 e assim por diante at\u00e9 o R15 . O mesmo c\u00f3digo pode ser escrito como: leaw $ 1 , % A movw ( % A ), % D leaw $ 0 , % A addw ( % A ), % D , % S leaw $ 2 , % A movw % S , ( % A ) - N\u00e3o continue caso n\u00e3o entendeu o c\u00f3digo ! Agora ser\u00e1 necess\u00e1rio colocarmos valores iniciais na mem\u00f3ria RAM para validarmos o nosso c\u00f3digo, para isso altere a mem\u00f3ria RAM como demonstrado a seguir: Endere\u00e7o 0 = 5 Endere\u00e7o 1 = 8 + Com a mem\u00f3ria alterada voc\u00ea pode agora executar a simula\u00e7\u00e3o, + verifique se o valor da mem\u00f3ria 2 \u00e9 a soma dos endere\u00e7os 0 e 1. Treinando \u00b6 USE O RESUMO DAS INSTRU\u00c7\u00d5ES: AssemblyZ1 - Altere o c\u00f3digo para armazenar o resultado no endere\u00e7o RAM[5] - Altere o c\u00f3digo para n\u00e3o usar o registrador %S Script autom\u00e1tico de testes \u00b6 Al\u00e9m da interface gr\u00e1fica do simulador, possu\u00edmos um script de teste automatizado (similar ao do VHDL), esse script: F-Assembly/testeAssembly.py compila os c\u00f3digos que est\u00e3o na pasta F-Assembly/src/nasm para a pasta F-Assembly/bin/hack e executa os testes localizados em F-Assembly/tst/ . Somente os arquivos configurados no config.txt ser\u00e3o testados. config.txt \u00b6 O arquivo de configura\u00e7\u00e3o dos testes \u00e9 um pouco diferente, possui al\u00e9m do nome do m\u00f3dulo que ser\u00e1 testado um segundo par\u00e2metro que indica quantos testes ser\u00e3o executados para esse m\u00f3dulo e quantos microsegundos ele ficar\u00e1 na simula\u00e7\u00e3o (microsegundos suposto de um sistema real). Exemplo do config.txt # nome | quantidade de testes | us de execucao #add 1 1000 + Remova o coment\u00e1rio do m\u00f3dulo add Implementando o add.nasm \u00b6 Os arquivos a serem implementando est\u00e3o na pasta F-Assembly/src/nasm/ l\u00e1 voc\u00ea vai encontrar todos os c\u00f3digos fontes que dever\u00e3o ser feitos nesse projeto. + Edite o arquivo add.nasm com a implementa\u00e7\u00e3o do add anterior Agora com o m\u00f3dulo implementando podemos testar seu funcionamento. Para isso execute o script testeAssembly.py . Esse script ir\u00e1 compilar o nasm e gerar os arquivos .hack e .mif (salvos no /bin/hack/ ) que ser\u00e3o carregados no simulador junto com uma configura\u00e7\u00e3o inicial da mem\u00f3ria RAM (como no gui do simulador), ao t\u00e9rmino da simula\u00e7\u00e3o um arquivo com o estado final da RAM \u00e9 salvo na pasta /tests/tst/add/add0_end.mif . Executamos um script que compara o estado final da RAM com o um esperado ( add0_tst.mif ), em caso de algum erro, o scripr ir\u00e1 reportar falha. Se tudo ocorrer bem voc\u00ea dever\u00e1 ter a seguinte sa\u00edda : - Testando .... ------------------------- Starting add0 .... pass add0 ==== Summary =================================== + pass add teste: 0 Formato de arquivos \u00b6 A seguir uma lista dos principais formatos de arquivos utilizados : .nasm : Arquivo assembly .hack : Linguagem de m\u00e1quina (arquivo com zeros e uns) .mif : Arquivo .hack que pode ser salvo na mem\u00f3ria da FPGA .lst : sa\u00edda do simulador com os estados da CPU","title":"F Assembly Lab 1"},{"location":"F-Assembly-Lab-1/#simulador","text":"Nosso c\u00f3digo assembly pode ser executado em hardware de verdade (FPGA) por\u00e9m nesse primeiro momento iremos trabalhar em um ambiente simulado que nos dar\u00e1 maior facilidade de programa\u00e7\u00e3o e depura\u00e7\u00e3o. Um pouco de contexto: O livro texto (The Elements Of Computer System) disponibiliza um simulador da CPU original todo escrito em java, esse c\u00f3digo \u00e9 fechado e n\u00e3o permite nenhuma customiza\u00e7\u00e3o. Em 2017 o Prof. Luciano Pereiro iniciou a cria\u00e7\u00e3o de um simulador Z0 (vers\u00e3o anterior) tamb\u00e9m em Java, onde ter\u00edamos controle total do software, o simulador funcionava. Percebemos alguns pontos negativos de utilizar um simulador em Java (ou qualquer outra linguagem) sendo o principal: Qualquer altera\u00e7\u00e3o no Hardware iria demandar uma altera\u00e7\u00e3o no simulador, sendo necess\u00e1rio mantermos dois projetos independentes e sincronizados. Nesse curso, iremos utilizar um simulador que utiliza o nosso pr\u00f3prio c\u00f3digo VHDL como descri\u00e7\u00e3o da CPU (e de tudo envolvido), uma altera\u00e7\u00e3o no hardware (VHDL) ir\u00e1 automaticamente alterar o simulador e o comportamento do computador. Para isso, fazemos uso do ModelSim, um software da Mentor Graphics que executa simula\u00e7\u00f2es em VHDL (o mesmo utilizado nos projetos anterios), desenvolvemos uma s\u00e9rie de APIs e configura\u00e7\u00f5es desse simulador para funcionar para a disciplina. As APIS de interface do simulador foram desenvolvidas por mim (vhdl/ tcl/ python) e a interface gr\u00e1fica pelo Prof. Eduardo Marossi (python/ qt5). O simulador possui a estrutura ilustrada a seguir: O simulador possui como entradas (para cada simula\u00e7\u00e3o): a arquitetura do computador (hardware); o conte\u00fado da mem\u00f3ria RAMl o conte\u00fado da mem\u00f3ria ROM e um tempo de execu\u00e7\u00e3o. Ap\u00f3s o t\u00e9rmino da simula\u00e7\u00e3o \u00e9 exportado diversos sinais internos da CPU, o estado final da mem\u00f3ria RAM e ROM. Esses sinais s\u00e3o ent\u00e3o lidos pela interface gr\u00e1fica e exibida de uma forma amig\u00e1vel.","title":"Simulador"},{"location":"F-Assembly-Lab-1/#arquivos","text":"O simulador est\u00e1 localizado nas pastas Z01-tools/ : Z01-Simulator-GUI : Parte gr\u00e1fica do simulador Z01-Simulator-RTL : Hardware a ser executado no modelsim para executar o programa. Para inicializar o simulador basta executar o script localizado na pasta do projeto F: ./F-Assembly/Z01simulador.py","title":"Arquivos"},{"location":"F-Assembly-Lab-1/#interface-do-simulador","text":"O simulador possui a interface a seguir, onde a coluna da esquerda \u00e9 referente a mem\u00f3ria ROM (programa), a coluna da direita referente a mem\u00f3ria RAM (dados). Toda vez que houver uma altera\u00e7\u00e3o em algum dos par\u00e2metros do simulador (RAM/ROM/Instru\u00e7\u00f5es,...) o programa ser\u00e1 novamente executado no simulador para obtermos um resultado atualizado. Isso pode dar a sensa\u00e7\u00e3o de \"lerdeza\" mas lembre da complexidade do sistema: estamos executando um programa em um hardware inteiramente simulado no computador de voc\u00eas.","title":"Interface do Simulador"},{"location":"F-Assembly-Lab-1/#programando","text":"Abra o simulador e insira o seguinte c\u00f3digo nasm (na parte referente a ROM), uma instru\u00e7\u00e3o por linha: leaw $ R1 , % A movw ( % A ), % D leaw $ R0 , % A addw ( % A ), % D , % S leaw $ R2 , % A movw % S , ( % A ) Esse c\u00f3digo soma o valor que est\u00e1 salvo na mem\u00f3ria RAM endere\u00e7o 0 com o valor da mem\u00f3ria RAM endere\u00e7o 1 e salva no endere\u00e7o 0: RAM[2] = RAM[0] + RAM[1]","title":"Programando"},{"location":"F-Assembly-Lab-1/#r0-r1","text":"R0**, ** R0**, ** R1 , ... s\u00e3o nomes pr\u00e9 definidos de endere\u00e7os de mem\u00f3ria. O R0 indica o endere\u00e7o de mem\u00f3ria 0, R1 o endere\u00e7o de mem\u00f3ria 1 e assim por diante at\u00e9 o R15 . O mesmo c\u00f3digo pode ser escrito como: leaw $ 1 , % A movw ( % A ), % D leaw $ 0 , % A addw ( % A ), % D , % S leaw $ 2 , % A movw % S , ( % A ) - N\u00e3o continue caso n\u00e3o entendeu o c\u00f3digo ! Agora ser\u00e1 necess\u00e1rio colocarmos valores iniciais na mem\u00f3ria RAM para validarmos o nosso c\u00f3digo, para isso altere a mem\u00f3ria RAM como demonstrado a seguir: Endere\u00e7o 0 = 5 Endere\u00e7o 1 = 8 + Com a mem\u00f3ria alterada voc\u00ea pode agora executar a simula\u00e7\u00e3o, + verifique se o valor da mem\u00f3ria 2 \u00e9 a soma dos endere\u00e7os 0 e 1.","title":"R0, R1, ... ?"},{"location":"F-Assembly-Lab-1/#treinando","text":"USE O RESUMO DAS INSTRU\u00c7\u00d5ES: AssemblyZ1 - Altere o c\u00f3digo para armazenar o resultado no endere\u00e7o RAM[5] - Altere o c\u00f3digo para n\u00e3o usar o registrador %S","title":"Treinando"},{"location":"F-Assembly-Lab-1/#script-automatico-de-testes","text":"Al\u00e9m da interface gr\u00e1fica do simulador, possu\u00edmos um script de teste automatizado (similar ao do VHDL), esse script: F-Assembly/testeAssembly.py compila os c\u00f3digos que est\u00e3o na pasta F-Assembly/src/nasm para a pasta F-Assembly/bin/hack e executa os testes localizados em F-Assembly/tst/ . Somente os arquivos configurados no config.txt ser\u00e3o testados.","title":"Script autom\u00e1tico de testes"},{"location":"F-Assembly-Lab-1/#configtxt","text":"O arquivo de configura\u00e7\u00e3o dos testes \u00e9 um pouco diferente, possui al\u00e9m do nome do m\u00f3dulo que ser\u00e1 testado um segundo par\u00e2metro que indica quantos testes ser\u00e3o executados para esse m\u00f3dulo e quantos microsegundos ele ficar\u00e1 na simula\u00e7\u00e3o (microsegundos suposto de um sistema real). Exemplo do config.txt # nome | quantidade de testes | us de execucao #add 1 1000 + Remova o coment\u00e1rio do m\u00f3dulo add","title":"config.txt"},{"location":"F-Assembly-Lab-1/#implementando-o-addnasm","text":"Os arquivos a serem implementando est\u00e3o na pasta F-Assembly/src/nasm/ l\u00e1 voc\u00ea vai encontrar todos os c\u00f3digos fontes que dever\u00e3o ser feitos nesse projeto. + Edite o arquivo add.nasm com a implementa\u00e7\u00e3o do add anterior Agora com o m\u00f3dulo implementando podemos testar seu funcionamento. Para isso execute o script testeAssembly.py . Esse script ir\u00e1 compilar o nasm e gerar os arquivos .hack e .mif (salvos no /bin/hack/ ) que ser\u00e3o carregados no simulador junto com uma configura\u00e7\u00e3o inicial da mem\u00f3ria RAM (como no gui do simulador), ao t\u00e9rmino da simula\u00e7\u00e3o um arquivo com o estado final da RAM \u00e9 salvo na pasta /tests/tst/add/add0_end.mif . Executamos um script que compara o estado final da RAM com o um esperado ( add0_tst.mif ), em caso de algum erro, o scripr ir\u00e1 reportar falha. Se tudo ocorrer bem voc\u00ea dever\u00e1 ter a seguinte sa\u00edda : - Testando .... ------------------------- Starting add0 .... pass add0 ==== Summary =================================== + pass add teste: 0","title":"Implementando o add.nasm"},{"location":"F-Assembly-Lab-1/#formato-de-arquivos","text":"A seguir uma lista dos principais formatos de arquivos utilizados : .nasm : Arquivo assembly .hack : Linguagem de m\u00e1quina (arquivo com zeros e uns) .mif : Arquivo .hack que pode ser salvo na mem\u00f3ria da FPGA .lst : sa\u00edda do simulador com os estados da CPU","title":"Formato de arquivos"},{"location":"F-Assembly-Lab-2/","text":"Ao final desse lab voc\u00ea deve ser capaz de: Conectar o LCD na FPGA Programar a FPGA com o Z01.1 Programar um programa em nasm no Z01.1 Conectando o LCD \u00b6 Programando a FPGA \u00b6 A FPGA \u00e9 um hardware que pode sr configur\u00e1vel para implementar 'qualquer' sistema digital, incluindo um computador. Iremos primeiramente prograr a FPGA com o Hardware do Z01 para ent\u00e3o podermos programar o nosso c\u00f3digo em assembly. Para isso, execute o script python: $ ./programFPGA.pt Esse script ir\u00e1 carregar na FPGA o hardware do Z01.1 - Nossa FPGA \u00e9 dita do tipo vol\u00e1til - ela perde a configura\u00e7\u00e3o sempre que for - desligada! - Essa etapa deve ser refeita sempre - que plugar a placa no PC. Programando o Z01.1 \u00b6 Agora com o Z01.1 configurado na FPGA podemos executar nosso programa no hardware, basta chamar o script programSoftware.py com o par\u00e2metro -n e o caminho para o c\u00f3digo nasm . Como no exemplo a seguir: ./programSoftware -b src/nasm/examples/R-LCD.nasm O mesmo deve executar um c\u00f3digo no Z01 que escreve a letra R no LCD. Programe os exemplos a seguir: pxLCD.nasm : Escreve apenas 16 pixels no LCD (um ponto) testeLED.nasm : Um programa que exibe um contador bin\u00e1rio nos LEDs da FPGA testeSW.nasm : Um programa que l\u00ea as chaves da FPGA e aciona os LEDs com base no seus resultados. Treinando \u00b6 Grave na FPGA o programa testeSW.nasm Mexa nas chaves SW e veja o que acontece com os LEDS. Altere o programa para ser o inverso do que foi programado. Quando as chaves estiverem para baixo, o respectivo LED acende e quando a chave estiver para cima o LED apaga. - Valide na FPGA! Chame um professor - para mostrar.","title":"F Assembly Lab 2"},{"location":"F-Assembly-Lab-2/#conectando-o-lcd","text":"","title":"Conectando o LCD"},{"location":"F-Assembly-Lab-2/#programando-a-fpga","text":"A FPGA \u00e9 um hardware que pode sr configur\u00e1vel para implementar 'qualquer' sistema digital, incluindo um computador. Iremos primeiramente prograr a FPGA com o Hardware do Z01 para ent\u00e3o podermos programar o nosso c\u00f3digo em assembly. Para isso, execute o script python: $ ./programFPGA.pt Esse script ir\u00e1 carregar na FPGA o hardware do Z01.1 - Nossa FPGA \u00e9 dita do tipo vol\u00e1til - ela perde a configura\u00e7\u00e3o sempre que for - desligada! - Essa etapa deve ser refeita sempre - que plugar a placa no PC.","title":"Programando a FPGA"},{"location":"F-Assembly-Lab-2/#programando-o-z011","text":"Agora com o Z01.1 configurado na FPGA podemos executar nosso programa no hardware, basta chamar o script programSoftware.py com o par\u00e2metro -n e o caminho para o c\u00f3digo nasm . Como no exemplo a seguir: ./programSoftware -b src/nasm/examples/R-LCD.nasm O mesmo deve executar um c\u00f3digo no Z01 que escreve a letra R no LCD. Programe os exemplos a seguir: pxLCD.nasm : Escreve apenas 16 pixels no LCD (um ponto) testeLED.nasm : Um programa que exibe um contador bin\u00e1rio nos LEDs da FPGA testeSW.nasm : Um programa que l\u00ea as chaves da FPGA e aciona os LEDs com base no seus resultados.","title":"Programando o Z01.1"},{"location":"F-Assembly-Lab-2/#treinando","text":"Grave na FPGA o programa testeSW.nasm Mexa nas chaves SW e veja o que acontece com os LEDS. Altere o programa para ser o inverso do que foi programado. Quando as chaves estiverem para baixo, o respectivo LED acende e quando a chave estiver para cima o LED apaga. - Valide na FPGA! Chame um professor - para mostrar.","title":"Treinando"},{"location":"F-Assembly-Lab-3/","text":"Lab 8: ULA \u00b6 Ao final desse lab voc\u00ea deve ser capaz de: Fazer programas simples em assembly com saltos Entender ainda mais a linguagem Entender ainda mias o hardawre Para todos os programas: Trabalhe com o grupo! Fa\u00e7a primeiramente na LOUSA, chame seu professor para validar Alterne quem vai para a lousa Fa\u00e7a no simulador GUI Lembre de iniciar a mem\u00f3ria RAM para validar o teste! Descomente no arquivo test/conf.txt Sempre use a descri\u00e7\u00e3o do hardware. Pequenos problemas (que j\u00e1 contam na entrega) \u00b6 Com auxilio do exemplo do add e das instru\u00e7\u00f5es dispon\u00edveis no nosso hardware ( AssemblyZ1 ) fa\u00e7a na LOUSA e depois no Simulador GUI um programa que: sub \u00b6 Arquivo: sub.nasm Faz uma subtra\u00e7\u00e3o binaria do valor de: RAM[1] - RAM[0] gravando em RAM[2]. - FA\u00c7A NA LOUSA PRIMEIRO! CHAME UM PROF. PARA VALIDAR - SIMULE NO GUI - RODE O TESTE (descomente tests/conf.txt) mov \u00b6 Arquivo: mov.nasm Movimenta\u00e7\u00e3o de dados da memoria RAM. tmp = RAM[0] RAM[0] = RAM[1] RAM[1] = tmp RAM[3] = 1 - FA\u00c7A NA LOUSA PRIMEIRO! CHAME UM PROF. PARA VALIDAR - SIMULE NO GUI - RODE O TESTE (descomente tests/conf.txt) SW e LED \u00b6 Arquivo: SWeLED.nasm Fa\u00e7a os LEDs exibirem o resultado da soma entre as chaves da FPGA: LEDR = SW[9..6] + SW[3..0]. - Valide no hardawre - Fa\u00e7a um v\u00eddeo!","title":"Lab 8: ULA"},{"location":"F-Assembly-Lab-3/#lab-8-ula","text":"Ao final desse lab voc\u00ea deve ser capaz de: Fazer programas simples em assembly com saltos Entender ainda mais a linguagem Entender ainda mias o hardawre Para todos os programas: Trabalhe com o grupo! Fa\u00e7a primeiramente na LOUSA, chame seu professor para validar Alterne quem vai para a lousa Fa\u00e7a no simulador GUI Lembre de iniciar a mem\u00f3ria RAM para validar o teste! Descomente no arquivo test/conf.txt Sempre use a descri\u00e7\u00e3o do hardware.","title":"Lab 8: ULA"},{"location":"F-Assembly-Lab-3/#pequenos-problemas-que-ja-contam-na-entrega","text":"Com auxilio do exemplo do add e das instru\u00e7\u00f5es dispon\u00edveis no nosso hardware ( AssemblyZ1 ) fa\u00e7a na LOUSA e depois no Simulador GUI um programa que:","title":"Pequenos problemas (que j\u00e1 contam na entrega)"},{"location":"F-Assembly-Lab-3/#sub","text":"Arquivo: sub.nasm Faz uma subtra\u00e7\u00e3o binaria do valor de: RAM[1] - RAM[0] gravando em RAM[2]. - FA\u00c7A NA LOUSA PRIMEIRO! CHAME UM PROF. PARA VALIDAR - SIMULE NO GUI - RODE O TESTE (descomente tests/conf.txt)","title":"sub"},{"location":"F-Assembly-Lab-3/#mov","text":"Arquivo: mov.nasm Movimenta\u00e7\u00e3o de dados da memoria RAM. tmp = RAM[0] RAM[0] = RAM[1] RAM[1] = tmp RAM[3] = 1 - FA\u00c7A NA LOUSA PRIMEIRO! CHAME UM PROF. PARA VALIDAR - SIMULE NO GUI - RODE O TESTE (descomente tests/conf.txt)","title":"mov"},{"location":"F-Assembly-Lab-3/#sw-e-led","text":"Arquivo: SWeLED.nasm Fa\u00e7a os LEDs exibirem o resultado da soma entre as chaves da FPGA: LEDR = SW[9..6] + SW[3..0]. - Valide no hardawre - Fa\u00e7a um v\u00eddeo!","title":"SW e LED"},{"location":"F-Assembly-Projeto/","text":"F - Assembly \u00b6 Nesse projeto cada grupo ter\u00e1 que implementar diversos c\u00f3digos em assembly a fim de entendermos a linguagem e as limita\u00e7\u00f5es do hardware propostos. Instru\u00e7\u00f5es \u00b6 Seguir as intru\u00e7\u00f5es a seguir para desenvolvimento do projeto. Entendendo a Organiza\u00e7\u00e3o do Projeto \u00b6 A pasta do projeto D, no reposit\u00f3rio Z01, possui a seguinte estrutura: F-Assembly/ testeAssembly.py Z01simulator.py /Quartus /src /nasm *.nasm /tests /tst /abs /add .... Quartus : Projeto Quartus para gravar o computador na FPGA *.py : Scripts em python que automatizam a execu\u00e7\u00e3o dos testes; src/nasm/*.nasm : Arquivos ASSEMBLY que ser\u00e3o implementados pelo grupo; tests/tst/* : Arquivos que realizam o teste nos arquivos c\u00f3digos do rtl. Executando o Script de Teste \u00b6 Abra o terminal na pasta F-Assembly/ e execute o script python localizado nessa pasta: $ ./testeAssembly.py O mesmo ir\u00e1 compilar os arquivos src/rtl/*.nasm e executar os testes unit\u00e1rios em cada um deles. Nesse momento do teste, como os m\u00f3dulos n\u00e3o est\u00e3o implementados, o resultado dever\u00e1 ser falho. Esse comando executa um teste unit\u00e1rio em cada um dos m\u00f3dulos, verificando se sua implementa\u00e7\u00e3o est\u00e1 correta. O resultado \u00e9 exibido na tela como : pass ou fail . Tip Lembrando que o arquivo tests/config.txt define quais testes ser\u00e3o executados. Projeto \u00b6 Deve-se implementar diversos programas na linguagem de m\u00e1quina do Z01 que ir\u00e3o manipular a mem\u00f3ria RAM a fim de implementar o que \u00e9 pedido. A descri\u00e7\u00e3o a seguir est\u00e1 classificada em ordem de dificuldade, come\u00e7ando pelos mais simples. M\u00f3dulos \u00b6 Esses arquivos est\u00e3o localizados em F-Assembly/src/nasm/ A descri\u00e7\u00e3o de cada m\u00f3dulo est\u00e1 localizada no cabe\u00e7alho do arquivo. mov Arquivo : mov.nasm add Arquivo : add.nasm sub Arquivo : sub.nasm abs Arquivo : abs.nasm pow Arquivo : pow.nasm fatorial Arquivo : fatorial.nasm mod Arquivo : mod.nasm Chaves e Leds Arquivo : SWeLED.nasm Linha Arquivo : line.nasm Quadrado Arquivo : quadrado.nasm Letra Grupo Arquivo : LCDletraGrupo.nasm Conceito B \u00b6 String length Arquivo : stringLength.nasm \u00c9 par Arquivo : isEven.nasm Palindromo Arquivo : palindromo.nasm Nome grupo Arquivo : LCDnomeGrupo.nasm Conceito A \u00b6 Nome grupo Arquivo : jogo.nasm Rubricas para avalia\u00e7\u00e3o de projetos \u00b6 Cada integrante do grupo ir\u00e1 receber duas notas: uma referente ao desenvolvimento total do projeto (Projeto) e outra referente a sua participa\u00e7\u00e3o individual no grupo (que depende do seu papel). Projeto \u00b6 Conceito I - Menos da metade dos m\u00f3dulos funcionando D - Ao menos um m\u00f3dulo n\u00e3o est\u00e1 feito e n\u00e3o passa no testes. C - Configurou o travis para operar com o novo projeto. - Todos os m\u00f3dulos sendo testados no Travis. - Todos os m\u00f3dulos passam nos testes. - Programa que desenha a letra do grupo no LCD B - Escreve o nome do grupo no LCD (grava v\u00eddeo) - Implementa os m\u00f3dulos extras ( stringLength.nasm , ... ) A - Faz algum jogo com o Z01.1 ( jogo.nasm ) (grava v\u00eddeo) Dicas rubrica A/B Veja a dicas para as rubricas A e B","title":"F - Assembly"},{"location":"F-Assembly-Projeto/#f-assembly","text":"Nesse projeto cada grupo ter\u00e1 que implementar diversos c\u00f3digos em assembly a fim de entendermos a linguagem e as limita\u00e7\u00f5es do hardware propostos.","title":"F - Assembly"},{"location":"F-Assembly-Projeto/#instrucoes","text":"Seguir as intru\u00e7\u00f5es a seguir para desenvolvimento do projeto.","title":"Instru\u00e7\u00f5es"},{"location":"F-Assembly-Projeto/#entendendo-a-organizacao-do-projeto","text":"A pasta do projeto D, no reposit\u00f3rio Z01, possui a seguinte estrutura: F-Assembly/ testeAssembly.py Z01simulator.py /Quartus /src /nasm *.nasm /tests /tst /abs /add .... Quartus : Projeto Quartus para gravar o computador na FPGA *.py : Scripts em python que automatizam a execu\u00e7\u00e3o dos testes; src/nasm/*.nasm : Arquivos ASSEMBLY que ser\u00e3o implementados pelo grupo; tests/tst/* : Arquivos que realizam o teste nos arquivos c\u00f3digos do rtl.","title":"Entendendo a Organiza\u00e7\u00e3o do Projeto"},{"location":"F-Assembly-Projeto/#executando-o-script-de-teste","text":"Abra o terminal na pasta F-Assembly/ e execute o script python localizado nessa pasta: $ ./testeAssembly.py O mesmo ir\u00e1 compilar os arquivos src/rtl/*.nasm e executar os testes unit\u00e1rios em cada um deles. Nesse momento do teste, como os m\u00f3dulos n\u00e3o est\u00e3o implementados, o resultado dever\u00e1 ser falho. Esse comando executa um teste unit\u00e1rio em cada um dos m\u00f3dulos, verificando se sua implementa\u00e7\u00e3o est\u00e1 correta. O resultado \u00e9 exibido na tela como : pass ou fail . Tip Lembrando que o arquivo tests/config.txt define quais testes ser\u00e3o executados.","title":"Executando o Script de Teste"},{"location":"F-Assembly-Projeto/#projeto","text":"Deve-se implementar diversos programas na linguagem de m\u00e1quina do Z01 que ir\u00e3o manipular a mem\u00f3ria RAM a fim de implementar o que \u00e9 pedido. A descri\u00e7\u00e3o a seguir est\u00e1 classificada em ordem de dificuldade, come\u00e7ando pelos mais simples.","title":"Projeto"},{"location":"F-Assembly-Projeto/#modulos","text":"Esses arquivos est\u00e3o localizados em F-Assembly/src/nasm/ A descri\u00e7\u00e3o de cada m\u00f3dulo est\u00e1 localizada no cabe\u00e7alho do arquivo. mov Arquivo : mov.nasm add Arquivo : add.nasm sub Arquivo : sub.nasm abs Arquivo : abs.nasm pow Arquivo : pow.nasm fatorial Arquivo : fatorial.nasm mod Arquivo : mod.nasm Chaves e Leds Arquivo : SWeLED.nasm Linha Arquivo : line.nasm Quadrado Arquivo : quadrado.nasm Letra Grupo Arquivo : LCDletraGrupo.nasm","title":"M\u00f3dulos"},{"location":"F-Assembly-Projeto/#conceito-b","text":"String length Arquivo : stringLength.nasm \u00c9 par Arquivo : isEven.nasm Palindromo Arquivo : palindromo.nasm Nome grupo Arquivo : LCDnomeGrupo.nasm","title":"Conceito B"},{"location":"F-Assembly-Projeto/#conceito-a","text":"Nome grupo Arquivo : jogo.nasm","title":"Conceito A"},{"location":"F-Assembly-Projeto/#rubricas-para-avaliacao-de-projetos","text":"Cada integrante do grupo ir\u00e1 receber duas notas: uma referente ao desenvolvimento total do projeto (Projeto) e outra referente a sua participa\u00e7\u00e3o individual no grupo (que depende do seu papel).","title":"Rubricas para avalia\u00e7\u00e3o de projetos"},{"location":"F-Assembly-Projeto/#projeto_1","text":"Conceito I - Menos da metade dos m\u00f3dulos funcionando D - Ao menos um m\u00f3dulo n\u00e3o est\u00e1 feito e n\u00e3o passa no testes. C - Configurou o travis para operar com o novo projeto. - Todos os m\u00f3dulos sendo testados no Travis. - Todos os m\u00f3dulos passam nos testes. - Programa que desenha a letra do grupo no LCD B - Escreve o nome do grupo no LCD (grava v\u00eddeo) - Implementa os m\u00f3dulos extras ( stringLength.nasm , ... ) A - Faz algum jogo com o Z01.1 ( jogo.nasm ) (grava v\u00eddeo) Dicas rubrica A/B Veja a dicas para as rubricas A e B","title":"Projeto"},{"location":"G-CPU-Dicas-Conceito-B-e-A/","text":"Inserindo display HEX \u00b6 Para inserir o display sete segmentos (7s) ser\u00e1 necess\u00e1rio: Modificar o memoryIO Adicionar novas sa\u00eddas na entity Adicionar perif\u00e9rico que recebe vetor de bits e converte para sinais do 7s Decoder Modificar Computador.vhd Deve-se agora rotear os novos sinais do memoryIO para os pinos da FPGA, para isso modifique a entity do Computador.vhd para entity Computador is generic( IS_SIMULATION : std_logic := '0' ); port( -- Sistema CLOCK_50 : in std_logic; RESET_N : in std_logic; LEDR : out std_logic_vector(9 downto 0); SW : in std_logic_vector(9 downto 0); -- LCD EXTERNAL I/OS LCD_CS_N : out std_logic; LCD_D : inout std_logic_vector(15 downto 0); LCD_RD_N : out std_logic; LCD_RESET_N : out std_logic; LCD_RS : out std_logic; LCD_WR_N : out std_logic; LCD_ON : out std_logic; + --- Seven Seg + HEX0 : out std_logic_vector(6 downto 0); -- 7seg0 + HEX1 : out std_logic_vector(6 downto 0); -- 7seg1 + HEX2 : out std_logic_vector(6 downto 0); -- 7seg2 + HEX3 : out std_logic_vector(6 downto 0) -- 7seg3 ); end entity; Programando ROM com linguagem de m\u00e1quina \u00b6 Uma vez implementando as modifica\u00e7\u00f5es no HW n\u00e3o temos mais como realizar os testes l\u00f3gicos na CPU ( testeHW e testeAssemblyMyCPU ), j\u00e1 que o nosso Assembler n\u00e3o est\u00e1 adequado para essas modifica\u00e7\u00f5es. Uma alternativa para verificarmos se a altera\u00e7\u00e3o est\u00e1 certa \u00e9: 1. Compilar no Quartus o novo computador 1. Programar a FPGA com o novo HW ./programMyFPGA.py 1. Escreva um programa em linguagem de m\u00e1quina (adequado ao novo Instruction Set) que teste as novas funcionalidades. - Programa j\u00e1 em bin\u00e1rio, extens\u00e3o: .mif - Exemplo na pasta: Projeto/G-CPU/testeComputador.mif 1. Programar a mem\u00f3ria da ROM com arquivo .mif : ./programSoftware -m Arquivo.mif 1. Verificar a funcionalidade das modifica\u00e7\u00f5es. Arquivo .mif \u00b6 O .mif \u00e9 um formato de arquivo que possibilita carregarmos uma mem\u00f3ria na FPGA, ele possui a seguinte estrutura: WIDTH=18; DEPTH=5; ADDRESS_RADIX=UNS; DATA_RADIX=BIN; CONTENT BEGIN 0 : 000000000000000101; 1 : 100101100000010000; 2 : 000000000000000001; 3 : 100000000000100000; 4 : 000000000000001011; END; Voc\u00ea deve editar a linha DEPTH=5; para a quantidade de linhas que seu programa possui! Esse arquivo \u00e9 geralmente gerado pelo Assembler : assembler .nasm ---------> .mif v |---------> FPGA |---------> SIMULADOR Teclado como perif\u00e9rico \u00b6 Adicionar os seguintes sinais na entidade do Computador.vhd e do memoryIO.vhd PS2_CLK : in std_logic; PS2_DAT : in std_logic; E implementar a leitura das teclas no memoryIO . Dica: https://www.digikey.com/eewiki/pages/viewpage.action?pageId=28278929","title":"Inserindo display HEX"},{"location":"G-CPU-Dicas-Conceito-B-e-A/#inserindo-display-hex","text":"Para inserir o display sete segmentos (7s) ser\u00e1 necess\u00e1rio: Modificar o memoryIO Adicionar novas sa\u00eddas na entity Adicionar perif\u00e9rico que recebe vetor de bits e converte para sinais do 7s Decoder Modificar Computador.vhd Deve-se agora rotear os novos sinais do memoryIO para os pinos da FPGA, para isso modifique a entity do Computador.vhd para entity Computador is generic( IS_SIMULATION : std_logic := '0' ); port( -- Sistema CLOCK_50 : in std_logic; RESET_N : in std_logic; LEDR : out std_logic_vector(9 downto 0); SW : in std_logic_vector(9 downto 0); -- LCD EXTERNAL I/OS LCD_CS_N : out std_logic; LCD_D : inout std_logic_vector(15 downto 0); LCD_RD_N : out std_logic; LCD_RESET_N : out std_logic; LCD_RS : out std_logic; LCD_WR_N : out std_logic; LCD_ON : out std_logic; + --- Seven Seg + HEX0 : out std_logic_vector(6 downto 0); -- 7seg0 + HEX1 : out std_logic_vector(6 downto 0); -- 7seg1 + HEX2 : out std_logic_vector(6 downto 0); -- 7seg2 + HEX3 : out std_logic_vector(6 downto 0) -- 7seg3 ); end entity;","title":"Inserindo display HEX"},{"location":"G-CPU-Dicas-Conceito-B-e-A/#programando-rom-com-linguagem-de-maquina","text":"Uma vez implementando as modifica\u00e7\u00f5es no HW n\u00e3o temos mais como realizar os testes l\u00f3gicos na CPU ( testeHW e testeAssemblyMyCPU ), j\u00e1 que o nosso Assembler n\u00e3o est\u00e1 adequado para essas modifica\u00e7\u00f5es. Uma alternativa para verificarmos se a altera\u00e7\u00e3o est\u00e1 certa \u00e9: 1. Compilar no Quartus o novo computador 1. Programar a FPGA com o novo HW ./programMyFPGA.py 1. Escreva um programa em linguagem de m\u00e1quina (adequado ao novo Instruction Set) que teste as novas funcionalidades. - Programa j\u00e1 em bin\u00e1rio, extens\u00e3o: .mif - Exemplo na pasta: Projeto/G-CPU/testeComputador.mif 1. Programar a mem\u00f3ria da ROM com arquivo .mif : ./programSoftware -m Arquivo.mif 1. Verificar a funcionalidade das modifica\u00e7\u00f5es.","title":"Programando ROM com linguagem de m\u00e1quina"},{"location":"G-CPU-Dicas-Conceito-B-e-A/#arquivo-mif","text":"O .mif \u00e9 um formato de arquivo que possibilita carregarmos uma mem\u00f3ria na FPGA, ele possui a seguinte estrutura: WIDTH=18; DEPTH=5; ADDRESS_RADIX=UNS; DATA_RADIX=BIN; CONTENT BEGIN 0 : 000000000000000101; 1 : 100101100000010000; 2 : 000000000000000001; 3 : 100000000000100000; 4 : 000000000000001011; END; Voc\u00ea deve editar a linha DEPTH=5; para a quantidade de linhas que seu programa possui! Esse arquivo \u00e9 geralmente gerado pelo Assembler : assembler .nasm ---------> .mif v |---------> FPGA |---------> SIMULADOR","title":"Arquivo .mif"},{"location":"G-CPU-Dicas-Conceito-B-e-A/#teclado-como-periferico","text":"Adicionar os seguintes sinais na entidade do Computador.vhd e do memoryIO.vhd PS2_CLK : in std_logic; PS2_DAT : in std_logic; E implementar a leitura das teclas no memoryIO . Dica: https://www.digikey.com/eewiki/pages/viewpage.action?pageId=28278929","title":"Teclado como perif\u00e9rico"},{"location":"G-CPU-Projeto/","text":"G - CPU \u00b6 Nesse projeto cada grupo ter\u00e1 que implementar diversos codigos em assembly a fim de entendermos a linguagem e as limita\u00e7\u00f5es do hardware propostos. Instru\u00e7\u00f5es \u00b6 Seguir as intru\u00e7\u00f5es a seguir para desenvolvimento do projeto. Entendendo a Organiza\u00e7\u00e3o do Projeto \u00b6 A pasta do projeto G no reposit\u00f3rio Z01, possui a seguinte estrutura: G-Computador/ testeHW.py testeAssemblyMyCPU.py Z01SimuladorMyCPU.py generateMySOF.py programMySOF.py programNASM.py Quartus/ ... Z01-Simulator-RTL/ ... testeHW.py : Testa o controlUnit.vhd e memoryIO.vhd testeAssemblyMyCPU.py : Testa todo o HW do computador ( CPU.vhd ) Z01SimuladorMyCPU.py : Abre o simulador gr\u00e1fico do Z01.1 com o HW do grupo programMySOF.py : Programa a FPGA com o HW do grupo programNASM.PY : Programa a ROM do Z01.1 da FPGA com um nasm passado Z01-Simulator-RTL : Pasta com o simulador do computador (usa o hardware criado por voc\u00eas) Testando HW (ControlUnit e MemoryIO) \u00b6 Abra o terminal na pasta G-CPU e execute o script python localizado nessa pasta: $ ./testeHW.py Warning Esse script testa apenas uma pequena parte do Control Uniy e do MemoryIO! Passar nesse teste n\u00e3o indica 100% que o projeto est\u00e1 correto. \u00c9 poss\u00edvel testar apenas o controlUnit ou MemoryIO, execute o comando com: lib.tb_controlunit.all ou lib.tb_memoryio.all para testar apenas um m\u00f3dulo. $ ./testeHW.py lib.tb_memoryio.all $ ./testeHW.py lib.tb_controlunit.all Testando o projeto completo \u00b6 Para testar se o computador est\u00e1 correto, iremos executar alguns programas realizados na etapa F-Assembly por\u00e9m agora no Harware que voc\u00eas montaram. Para isso execute. $ ./testeAssemblyMyCPU.py Esse script ir\u00e1 compilar todos os m\u00f3dulos (desde o projeto C) e executar o top level Computador.vhd , iremos comparar se a resposta (mem\u00f3ria RAM) possui o resultado esperado. Como os programas s\u00e3o complexos, esperamos com isso conseguir testar a totalidade do projeto. Travis \u00b6 Adicione ao Travis os dois testes, separando o memoryIO e o controlUnit: testeHW.py lib.tb_memoryio.all testeHW.py lib.tb_controlunit.all testeAssemblyMyCPU.py Projeto \u00b6 Deve-se implementar o Control Unit e integrar os m\u00f3dulos: MemoryIO e CPU . O HDL que descreve o Computador j\u00e1 foi fornecido pronto. M\u00f3dulos \u00b6 Note Esses arquivos est\u00e3o localizados em G-Computador/src/rtl/ Os m\u00f3dulos est\u00e3o listados de maneira Top - Down Computador (j\u00e1 est\u00e1 pronto!) Arquivo : computador.vhd Descri\u00e7\u00e3o : TopLevel do projeto, entidade que integra a mem\u00f3ria ROM o MemoryIO, CPU e PLL Depend\u00eancias : Dispositivos/ROM/ROM32K.vhd : ROM a ser utilizada no projeto (j\u00e1 foi dado pronto) Dispositivos/PLL/PLL.vhd : PLL a ser utilizada no projeto (j\u00e1 foi dado pronto) MemoryIO Arquivo : MemoryIO.vhd Descri\u00e7\u00e3o : Faz o mapa de mem\u00f3ria para a CPU. Depend\u00eancias : Dispositivos/RAM/RAM16K.vhd : RAM a ser utilizada no projeto (j\u00e1 foi dado pronto) Dispositivos/Screen/Screen.vhd : Controlador do LCD a ser utilizada no projeto (j\u00e1 foi dado pronto) CPU Arquivo : CPU.vhd Descri\u00e7\u00e3o : CPU do Z01 integra registradores, controlUnit, ULA e PC. Depend\u00eancias : ControlUnit.vhd : Unidade de controle a ser implementada ULA.vhd : Unidade l\u00f3gica desenvolvida no projeto D PC.vhd : Program counter do projeto E register16.vhd , mux16.vhd : Componentes do projeto C e D ControlUnit Arquivo : ControlUnit.vhd Descri\u00e7\u00e3o : Unidade de controle da CPU do Z01. Depend\u00eancias : n\u00e3o h\u00e1 Diagramas \u00b6 ControlUnit Rubricas para avalia\u00e7\u00e3o de projetos \u00b6 Cada integrante do grupo ir\u00e1 receber duas notas: uma referente ao desenvolvimento total do projeto (Projeto) e outra referente a sua participa\u00e7\u00e3o individual no grupo (que depende do seu papel). Projeto \u00b6 Conceito I - Menos da metade dos m\u00f3dulos funcionando D - Ao menos um m\u00f3dulo n\u00e3o est\u00e1 feito e n\u00e3o passa no testes. C - Construiu com os m\u00f3dulos do grupo o seu pr\u00f3prio computador - Todos os m\u00f3dulos sendo testados no Travis. - Todos os m\u00f3dulos passam nos testes. - Executa o escreve a letra do grupo no LCD usando o seu computador B - Adiciona um novo registrador a CPU - Adiciona os displays de Sete Segmentos aos perif\u00e9ricos do Computador (memoryIO) - Faz um c\u00f3digo e um v\u00eddeo que demonstra que ambos est\u00e3o funcionando A - Possibilita realizar carregamento efetivo em %D ( leaw $5, %D ) OU - Adiciona um teclado (externo) como um novo perif\u00e9rico - Faz um c\u00f3digo e um v\u00eddeo que demonstrando seu funcionamento Conceito A Para o conceito A \u00e9 necess\u00e1rio realizar apenas um item da lista.","title":"G - CPU"},{"location":"G-CPU-Projeto/#g-cpu","text":"Nesse projeto cada grupo ter\u00e1 que implementar diversos codigos em assembly a fim de entendermos a linguagem e as limita\u00e7\u00f5es do hardware propostos.","title":"G - CPU"},{"location":"G-CPU-Projeto/#instrucoes","text":"Seguir as intru\u00e7\u00f5es a seguir para desenvolvimento do projeto.","title":"Instru\u00e7\u00f5es"},{"location":"G-CPU-Projeto/#entendendo-a-organizacao-do-projeto","text":"A pasta do projeto G no reposit\u00f3rio Z01, possui a seguinte estrutura: G-Computador/ testeHW.py testeAssemblyMyCPU.py Z01SimuladorMyCPU.py generateMySOF.py programMySOF.py programNASM.py Quartus/ ... Z01-Simulator-RTL/ ... testeHW.py : Testa o controlUnit.vhd e memoryIO.vhd testeAssemblyMyCPU.py : Testa todo o HW do computador ( CPU.vhd ) Z01SimuladorMyCPU.py : Abre o simulador gr\u00e1fico do Z01.1 com o HW do grupo programMySOF.py : Programa a FPGA com o HW do grupo programNASM.PY : Programa a ROM do Z01.1 da FPGA com um nasm passado Z01-Simulator-RTL : Pasta com o simulador do computador (usa o hardware criado por voc\u00eas)","title":"Entendendo a Organiza\u00e7\u00e3o do Projeto"},{"location":"G-CPU-Projeto/#testando-hw-controlunit-e-memoryio","text":"Abra o terminal na pasta G-CPU e execute o script python localizado nessa pasta: $ ./testeHW.py Warning Esse script testa apenas uma pequena parte do Control Uniy e do MemoryIO! Passar nesse teste n\u00e3o indica 100% que o projeto est\u00e1 correto. \u00c9 poss\u00edvel testar apenas o controlUnit ou MemoryIO, execute o comando com: lib.tb_controlunit.all ou lib.tb_memoryio.all para testar apenas um m\u00f3dulo. $ ./testeHW.py lib.tb_memoryio.all $ ./testeHW.py lib.tb_controlunit.all","title":"Testando HW (ControlUnit e MemoryIO)"},{"location":"G-CPU-Projeto/#testando-o-projeto-completo","text":"Para testar se o computador est\u00e1 correto, iremos executar alguns programas realizados na etapa F-Assembly por\u00e9m agora no Harware que voc\u00eas montaram. Para isso execute. $ ./testeAssemblyMyCPU.py Esse script ir\u00e1 compilar todos os m\u00f3dulos (desde o projeto C) e executar o top level Computador.vhd , iremos comparar se a resposta (mem\u00f3ria RAM) possui o resultado esperado. Como os programas s\u00e3o complexos, esperamos com isso conseguir testar a totalidade do projeto.","title":"Testando o projeto completo"},{"location":"G-CPU-Projeto/#travis","text":"Adicione ao Travis os dois testes, separando o memoryIO e o controlUnit: testeHW.py lib.tb_memoryio.all testeHW.py lib.tb_controlunit.all testeAssemblyMyCPU.py","title":"Travis"},{"location":"G-CPU-Projeto/#projeto","text":"Deve-se implementar o Control Unit e integrar os m\u00f3dulos: MemoryIO e CPU . O HDL que descreve o Computador j\u00e1 foi fornecido pronto.","title":"Projeto"},{"location":"G-CPU-Projeto/#modulos","text":"Note Esses arquivos est\u00e3o localizados em G-Computador/src/rtl/ Os m\u00f3dulos est\u00e3o listados de maneira Top - Down Computador (j\u00e1 est\u00e1 pronto!) Arquivo : computador.vhd Descri\u00e7\u00e3o : TopLevel do projeto, entidade que integra a mem\u00f3ria ROM o MemoryIO, CPU e PLL Depend\u00eancias : Dispositivos/ROM/ROM32K.vhd : ROM a ser utilizada no projeto (j\u00e1 foi dado pronto) Dispositivos/PLL/PLL.vhd : PLL a ser utilizada no projeto (j\u00e1 foi dado pronto) MemoryIO Arquivo : MemoryIO.vhd Descri\u00e7\u00e3o : Faz o mapa de mem\u00f3ria para a CPU. Depend\u00eancias : Dispositivos/RAM/RAM16K.vhd : RAM a ser utilizada no projeto (j\u00e1 foi dado pronto) Dispositivos/Screen/Screen.vhd : Controlador do LCD a ser utilizada no projeto (j\u00e1 foi dado pronto) CPU Arquivo : CPU.vhd Descri\u00e7\u00e3o : CPU do Z01 integra registradores, controlUnit, ULA e PC. Depend\u00eancias : ControlUnit.vhd : Unidade de controle a ser implementada ULA.vhd : Unidade l\u00f3gica desenvolvida no projeto D PC.vhd : Program counter do projeto E register16.vhd , mux16.vhd : Componentes do projeto C e D ControlUnit Arquivo : ControlUnit.vhd Descri\u00e7\u00e3o : Unidade de controle da CPU do Z01. Depend\u00eancias : n\u00e3o h\u00e1","title":"M\u00f3dulos"},{"location":"G-CPU-Projeto/#diagramas","text":"ControlUnit","title":"Diagramas"},{"location":"G-CPU-Projeto/#rubricas-para-avaliacao-de-projetos","text":"Cada integrante do grupo ir\u00e1 receber duas notas: uma referente ao desenvolvimento total do projeto (Projeto) e outra referente a sua participa\u00e7\u00e3o individual no grupo (que depende do seu papel).","title":"Rubricas para avalia\u00e7\u00e3o de projetos"},{"location":"G-CPU-Projeto/#projeto_1","text":"Conceito I - Menos da metade dos m\u00f3dulos funcionando D - Ao menos um m\u00f3dulo n\u00e3o est\u00e1 feito e n\u00e3o passa no testes. C - Construiu com os m\u00f3dulos do grupo o seu pr\u00f3prio computador - Todos os m\u00f3dulos sendo testados no Travis. - Todos os m\u00f3dulos passam nos testes. - Executa o escreve a letra do grupo no LCD usando o seu computador B - Adiciona um novo registrador a CPU - Adiciona os displays de Sete Segmentos aos perif\u00e9ricos do Computador (memoryIO) - Faz um c\u00f3digo e um v\u00eddeo que demonstra que ambos est\u00e3o funcionando A - Possibilita realizar carregamento efetivo em %D ( leaw $5, %D ) OU - Adiciona um teclado (externo) como um novo perif\u00e9rico - Faz um c\u00f3digo e um v\u00eddeo que demonstrando seu funcionamento Conceito A Para o conceito A \u00e9 necess\u00e1rio realizar apenas um item da lista.","title":"Projeto"},{"location":"G-CPU-Testando/","text":"G - CPU - Testando \u00b6 Para testar o projeto G-CPU \u00e9 necess\u00e1rio: Testar o controUnit e o memoryIo : $ ./testeHW.py lib.tb_memoryio.all $ ./testeHW.py lib.tb_controlunit.all Somente ap\u00f3s passar os testes anteriores e com a CPU implementada: Testar o computador ( CPU , controlUnit e memoryIo ) com a execu\u00e7\u00e3o de c\u00f3digos em assembly: $ ./testeAssemblyMyCPU.py Tip SE O TESTE TRAVAR, VERIFICAR DICAS AO FINAL DESSA P\u00c1GINA Testar o Computador na FPGA Abrir Quartus e compilar projeto Executar programMyFPGA.py Executar o programa letra / nome : $ ./programSoftware.py -n ../F-Assembly/src/nasm/LCDnomeGrupo.nasm Rubrica B \u00b6 N\u00e3o vamos ter o teste do memoryIO nem do controlUnit adequados para as mudan\u00e7as, ser\u00e1 necess\u00e1rio testar direto no Hardware: Abrir Quartus e compilar projeto Executar programMyFPGA.py Como voc\u00eas alteraram o InstructionSet, ser\u00e1 necess\u00e1rio escrever um programa em linguagem de m\u00e1quina, para isso: Altere o arquivo: testeComputador.mif com suas opera\u00e7\u00f5es Execute ./programSoftware.py -m testeComputador.mif para programar a ROM do Z01.1 com seu programa. Note que o arquivo testeComputador.mif possui um campo que \u00e9 DEPTH=30; Voc\u00ea deve alterar esse valor para a quantidade de linhas que seu programa possui! Se o testeAssemblyMyCPU.py travar \u00b6 Se por algum motivo o teste testeAssemblyMyCPU.py travar no primeiro teste, isso \u00e9 sin\u00f4nimo de que algo est\u00e1 errado com o seu HDL. Esse teste faz o seguinte para cada arquivo .nasm incluso no arquivo de configura\u00e7\u00e3o do Projeto F : Compila o .nasm gerando o bin\u00e1rio .mif Carrega na ROM do seu computador ( Projeto G ) o bin\u00e1rio Executa o c\u00f3digo Verifica se o resultado est\u00e1 certo Se por algum motivo algum m\u00f3dulo estiver com problema esse teste pode falhar, o que \u00e9 aconselhado fazer: Comente todos os teste do Projeto F no arquivo de configura\u00e7\u00e3o ( F-Assembly/tests/config.txt ) com exce\u00e7\u00e3o o mov.nasm Esse m\u00f3dulo testa todos os registradores Execute o teste com a parte do waveform: ./testeAssemblyMyCPU.py -g An\u00e1lise o transcript em busca de erros! Inclua os sinais do Computador no waveform e execute o vunit_run Analise o que est\u00e1 acontecendo com o seu hardware, verifique a instru\u00e7\u00e3o que est\u00e1 entrando e o que deveria acontecer. Corrija o HW quando encontrar o problema, teste novamente. Descomente os m\u00f3dulos: abs.nasm e teste para saber se est\u00e1 :ok Esse m\u00f3dulo testa o loadPC e sa\u00eddas da ULA (ng e zr) Descomente os demais m\u00f3dulos e teste tudo.","title":"G - CPU - Testando"},{"location":"G-CPU-Testando/#g-cpu-testando","text":"Para testar o projeto G-CPU \u00e9 necess\u00e1rio: Testar o controUnit e o memoryIo : $ ./testeHW.py lib.tb_memoryio.all $ ./testeHW.py lib.tb_controlunit.all Somente ap\u00f3s passar os testes anteriores e com a CPU implementada: Testar o computador ( CPU , controlUnit e memoryIo ) com a execu\u00e7\u00e3o de c\u00f3digos em assembly: $ ./testeAssemblyMyCPU.py Tip SE O TESTE TRAVAR, VERIFICAR DICAS AO FINAL DESSA P\u00c1GINA Testar o Computador na FPGA Abrir Quartus e compilar projeto Executar programMyFPGA.py Executar o programa letra / nome : $ ./programSoftware.py -n ../F-Assembly/src/nasm/LCDnomeGrupo.nasm","title":"G - CPU - Testando"},{"location":"G-CPU-Testando/#rubrica-b","text":"N\u00e3o vamos ter o teste do memoryIO nem do controlUnit adequados para as mudan\u00e7as, ser\u00e1 necess\u00e1rio testar direto no Hardware: Abrir Quartus e compilar projeto Executar programMyFPGA.py Como voc\u00eas alteraram o InstructionSet, ser\u00e1 necess\u00e1rio escrever um programa em linguagem de m\u00e1quina, para isso: Altere o arquivo: testeComputador.mif com suas opera\u00e7\u00f5es Execute ./programSoftware.py -m testeComputador.mif para programar a ROM do Z01.1 com seu programa. Note que o arquivo testeComputador.mif possui um campo que \u00e9 DEPTH=30; Voc\u00ea deve alterar esse valor para a quantidade de linhas que seu programa possui!","title":"Rubrica B"},{"location":"G-CPU-Testando/#se-o-testeassemblymycpupy-travar","text":"Se por algum motivo o teste testeAssemblyMyCPU.py travar no primeiro teste, isso \u00e9 sin\u00f4nimo de que algo est\u00e1 errado com o seu HDL. Esse teste faz o seguinte para cada arquivo .nasm incluso no arquivo de configura\u00e7\u00e3o do Projeto F : Compila o .nasm gerando o bin\u00e1rio .mif Carrega na ROM do seu computador ( Projeto G ) o bin\u00e1rio Executa o c\u00f3digo Verifica se o resultado est\u00e1 certo Se por algum motivo algum m\u00f3dulo estiver com problema esse teste pode falhar, o que \u00e9 aconselhado fazer: Comente todos os teste do Projeto F no arquivo de configura\u00e7\u00e3o ( F-Assembly/tests/config.txt ) com exce\u00e7\u00e3o o mov.nasm Esse m\u00f3dulo testa todos os registradores Execute o teste com a parte do waveform: ./testeAssemblyMyCPU.py -g An\u00e1lise o transcript em busca de erros! Inclua os sinais do Computador no waveform e execute o vunit_run Analise o que est\u00e1 acontecendo com o seu hardware, verifique a instru\u00e7\u00e3o que est\u00e1 entrando e o que deveria acontecer. Corrija o HW quando encontrar o problema, teste novamente. Descomente os m\u00f3dulos: abs.nasm e teste para saber se est\u00e1 :ok Esse m\u00f3dulo testa o loadPC e sa\u00eddas da ULA (ng e zr) Descomente os demais m\u00f3dulos e teste tudo.","title":"Se o testeAssemblyMyCPU.py travar"},{"location":"H-Assembler-Dicas-Macro/","text":"H - Assembler - Dica Macro \u00b6 Suponha o seguinte arquivo .nasm : % macro name nPar ... .. % endmacro name : Nome do macro nPar : Quantidade de par\u00e2metros (0, 1, 2), acess\u00edvel via : par0, par1 O macro serve para facilitar o reaproveitamento de c\u00f3digos, diferente de uma fun\u00e7\u00e3o que altera o fluxo de execu\u00e7\u00e3o do c\u00f3digo para o endere\u00e7o que a fun\u00e7\u00e3o est\u00e1 salva, o macro funciona copiando o macro para a onde ele foi chamado, como no exemplo a seguir: C\u00f3digo sem macro : ; carrega 5 em D leaw $5 , %A movw %A , %D ; salva valor em RAM8 leaw $8 , %A movw %D , ( %A ) C\u00f3digo com 2 macros definidos : movCntToReg : Move uma constante (par0) para uma registrador (par1) movRegtoRAM : Move um registrador (par0) para o endere\u00e7o de mem\u00f3ria (par1). % macro movCntToReg 2 leaw par0 , %A movw %A , par1 % endmacro % macro movRegtoRAM 2 leaw par0 , %A movw par1 , ( %A ) % endmacro ; carrega 5 em D movCntToReg $D , % 5 ; chama macro para salvar em RAM 8 movRegtoRAM %D , $8","title":"H - Assembler - Dica Macro"},{"location":"H-Assembler-Dicas-Macro/#h-assembler-dica-macro","text":"Suponha o seguinte arquivo .nasm : % macro name nPar ... .. % endmacro name : Nome do macro nPar : Quantidade de par\u00e2metros (0, 1, 2), acess\u00edvel via : par0, par1 O macro serve para facilitar o reaproveitamento de c\u00f3digos, diferente de uma fun\u00e7\u00e3o que altera o fluxo de execu\u00e7\u00e3o do c\u00f3digo para o endere\u00e7o que a fun\u00e7\u00e3o est\u00e1 salva, o macro funciona copiando o macro para a onde ele foi chamado, como no exemplo a seguir: C\u00f3digo sem macro : ; carrega 5 em D leaw $5 , %A movw %A , %D ; salva valor em RAM8 leaw $8 , %A movw %D , ( %A ) C\u00f3digo com 2 macros definidos : movCntToReg : Move uma constante (par0) para uma registrador (par1) movRegtoRAM : Move um registrador (par0) para o endere\u00e7o de mem\u00f3ria (par1). % macro movCntToReg 2 leaw par0 , %A movw %A , par1 % endmacro % macro movRegtoRAM 2 leaw par0 , %A movw par1 , ( %A ) % endmacro ; carrega 5 em D movCntToReg $D , % 5 ; chama macro para salvar em RAM 8 movRegtoRAM %D , $8","title":"H - Assembler - Dica Macro"},{"location":"H-Assembler-Dicas-SymbolTable/","text":"Tabela de S\u00edmbolos \u00b6 O Z01 possui alguns s\u00edmbolos definidos para facilitar o desenvolvimento de um programa em assembly, por exemplo, n\u00e3o \u00e9 preciso saber de cor que o LCD come\u00e7a no endere\u00e7o 16384, basta usarmos o s\u00edmbolo SCREEN no c\u00f3digo que o mesmo ser\u00e1 substitu\u00eddo pelo valor 16384. Al\u00e9m de facilitar o desenvolvimento, possibilita uma maior portabilidade j\u00e1 que o compilador que \u00e9 encarregado de substituir o valor, se o endere\u00e7o uma maior portabilidade do c\u00f3digo. S\u00edmbolos padr\u00f5es \u00b6 Esse s\u00e3o os s\u00edmbolos que s\u00e3o definidos estaticamente, sempre devem existir. Eles indicam um endere\u00e7o da mem\u00f3ria RAM. Exemplo : leaw $LED , %A movd %D , ( %A ) Simb Endere\u00e7o R0-R15 0-15 SP 0 LCL 1 ARG 2 THIS 3 THAT 4 SCREEN 16384 LED 21184 SW 21185 Labels \u00b6 S\u00e3o os s\u00edmbolos que indicam um endere\u00e7o da mem\u00f3ria ROM, s\u00e3o utilizados pelas opera\u00e7\u00f5es de salto para indicar o seu destino : LOOP: leaw $LOOP , %A jmp Endere\u00e7os de mem\u00f3ria \u00b6 S\u00e3o endere\u00e7os de mem\u00f3ria criados automaticamente pelo assembler, ser\u00e1 utilizado pela VM e futuramente pelo compilador para alocar vari\u00e1veis noSTART_RAM_ADDRESS computador. Funciona da seguinte maneira : leaw $var , %A movw %D , ( %A ) O Assembler deve alocar um endere\u00e7o automaticamente ainda n\u00e3o utilizado para var0 , o valor a ser alocado \u00e9 a partir do endere\u00e7o 16 da RAM. Simb valor var0 16 O nome da vari\u00e1vel pode ser qualquer uma, desde que n\u00e3o repita um nome de label. Exemplo \u00b6 Vamos supor o c\u00f3digo (que n\u00e3o faz nada coerente) a seguir: 0: leaw $x, %A 1: movw $1, (%A) 2: LOOP: 3: leaw $UPDATE, %A 4: je %D 5: nop 6: leaw $temp, %A 7: movw (%A), %A 8: addw %A, %S, %S 9: decw %D 10: leaw $LOOP, %A 11: jmp 12: nop 13: UPDATE: 14: leaw $3, %A 15: movw %S, (%A) 16: END: 17: leaw $END, %A 18: jmp 19: nop A tabela de s\u00edmbolos gerada deveria ser: S\u00edmbolos Valor R0 0 R1 1 ... ... R15 15 SP 0 LCL 1 ARG 2 THIS 3 THAT 4 SCREEN 16384 LED 21184 SW 21185 ------------ -------- x 16 y 17 LOOP 2 UPDATE 12 END 14","title":"Tabela de S\u00edmbolos"},{"location":"H-Assembler-Dicas-SymbolTable/#tabela-de-simbolos","text":"O Z01 possui alguns s\u00edmbolos definidos para facilitar o desenvolvimento de um programa em assembly, por exemplo, n\u00e3o \u00e9 preciso saber de cor que o LCD come\u00e7a no endere\u00e7o 16384, basta usarmos o s\u00edmbolo SCREEN no c\u00f3digo que o mesmo ser\u00e1 substitu\u00eddo pelo valor 16384. Al\u00e9m de facilitar o desenvolvimento, possibilita uma maior portabilidade j\u00e1 que o compilador que \u00e9 encarregado de substituir o valor, se o endere\u00e7o uma maior portabilidade do c\u00f3digo.","title":"Tabela de S\u00edmbolos"},{"location":"H-Assembler-Dicas-SymbolTable/#simbolos-padroes","text":"Esse s\u00e3o os s\u00edmbolos que s\u00e3o definidos estaticamente, sempre devem existir. Eles indicam um endere\u00e7o da mem\u00f3ria RAM. Exemplo : leaw $LED , %A movd %D , ( %A ) Simb Endere\u00e7o R0-R15 0-15 SP 0 LCL 1 ARG 2 THIS 3 THAT 4 SCREEN 16384 LED 21184 SW 21185","title":"S\u00edmbolos padr\u00f5es"},{"location":"H-Assembler-Dicas-SymbolTable/#labels","text":"S\u00e3o os s\u00edmbolos que indicam um endere\u00e7o da mem\u00f3ria ROM, s\u00e3o utilizados pelas opera\u00e7\u00f5es de salto para indicar o seu destino : LOOP: leaw $LOOP , %A jmp","title":"Labels"},{"location":"H-Assembler-Dicas-SymbolTable/#enderecos-de-memoria","text":"S\u00e3o endere\u00e7os de mem\u00f3ria criados automaticamente pelo assembler, ser\u00e1 utilizado pela VM e futuramente pelo compilador para alocar vari\u00e1veis noSTART_RAM_ADDRESS computador. Funciona da seguinte maneira : leaw $var , %A movw %D , ( %A ) O Assembler deve alocar um endere\u00e7o automaticamente ainda n\u00e3o utilizado para var0 , o valor a ser alocado \u00e9 a partir do endere\u00e7o 16 da RAM. Simb valor var0 16 O nome da vari\u00e1vel pode ser qualquer uma, desde que n\u00e3o repita um nome de label.","title":"Endere\u00e7os de mem\u00f3ria"},{"location":"H-Assembler-Dicas-SymbolTable/#exemplo","text":"Vamos supor o c\u00f3digo (que n\u00e3o faz nada coerente) a seguir: 0: leaw $x, %A 1: movw $1, (%A) 2: LOOP: 3: leaw $UPDATE, %A 4: je %D 5: nop 6: leaw $temp, %A 7: movw (%A), %A 8: addw %A, %S, %S 9: decw %D 10: leaw $LOOP, %A 11: jmp 12: nop 13: UPDATE: 14: leaw $3, %A 15: movw %S, (%A) 16: END: 17: leaw $END, %A 18: jmp 19: nop A tabela de s\u00edmbolos gerada deveria ser: S\u00edmbolos Valor R0 0 R1 1 ... ... R15 15 SP 0 LCL 1 ARG 2 THIS 3 THAT 4 SCREEN 16384 LED 21184 SW 21185 ------------ -------- x 16 y 17 LOOP 2 UPDATE 12 END 14","title":"Exemplo"},{"location":"H-Assembler-Lab-1-%5Bparte-1%5D/","text":"Agora iremos desenvolver um programa em java que ser\u00e1 capaz de ler nossos programas em .nasm e converter eles para .hack (bin\u00e1rio). Nosso arquivo .hack \u00e9 um arquivo de texto que possui apenas 1 s e 0 s. Cada linha desse arquivo .hack \u00e9 uma instru\u00e7\u00e3o a ser armazenada na mem\u00f3ria. Exemplo de um arquivo .hack : 000000000000000101 100101100000010000 000000000000000001 100000000000100000 000000000000001011 Voc\u00ea pode abrir seus arquivos .hack, basta ir em F-Assembly/bin/hack/ que vai encontrar seus programas em linguagem de m\u00e1quina. O arquivo .hack \u00e9 um formato que n\u00e3o conseguimos fazer o download para a FPGA, \u00e9 necess\u00e1rio convertemos esse formato em um que o Quartus entenda. Esse formato do Quartus \u00e9 chamado de .mif e \u00e9 gerado automaticamente pelos scripts de teste, esse arquivo .mif \u00e9 simular ao .hack salvo um cabe\u00e7alho e a indica\u00e7\u00e3o do endere\u00e7o na qual a linha deve ser salva: WIDTH=18; DEPTH=5; ADDRESS_RADIX=UNS; DATA_RADIX=BIN; CONTENT BEGIN 0 : 000000000000000101; 1 : 100101100000010000; 2 : 000000000000000001; 3 : 100000000000100000; 4 : 000000000000001011; END; O Assembler de voc\u00eas deve gerar um arquivo .hack. A convers\u00e3o para o .mif \u00e9 feita pelos scripts em python j\u00e1 fornecidos assembler script .nasm ---------> .hack --------> .mif v |---------> FPGA |---------> SIMULADOR Assembler \u00b6 O assembler ser\u00e1 um programa escrito em java e que foi estruturado em quatro classes : Assemble Arquivo : Assemble.java Descri\u00e7\u00e3o : Classe respons\u00e1vel por criar o a de programar o Computador na FPGA e executarmos c\u00f3digo de m\u00e1quina, ela que efetivamente faz a varredura do arquivo .nasm de entrada e escreve o arquivo .hack de sa\u00edda, gerando o c\u00f3digo de m\u00e1quina. Depend\u00eancias : Code.java , Parser.java , SymbolTable.java Code Arquivo : Code.java Descri\u00e7\u00e3o : Traduz mnem\u00f4nicos da linguagem assembly para c\u00f3digos bin\u00e1rios da arquitetura Z0. Depend\u00eancias : none Parser Arquivo : Parser.java Descri\u00e7\u00e3o : Encapsula o c\u00f3digo de leitura. Carrega as instru\u00e7\u00f5es na linguagem assembly, analisa, e oferece acesso as partes da instru\u00e7\u00e3o (campos e s\u00edmbolos). Al\u00e9m disso, remove todos os espa\u00e7os em branco e coment\u00e1rios. Depend\u00eancias : none SymbolTable Arquivo : SymbolTable.java Descri\u00e7\u00e3o : Mant\u00e9m uma tabela com a correspond\u00eancia entre os r\u00f3tulos simb\u00f3licos e endere\u00e7os num\u00e9ricos de mem\u00f3ria. Depend\u00eancias : none Note que o 'orquestrador' da montagem (esse \u00e9 o termo em portugu\u00eas utilizado) \u00e9 a classe 'Assemble', nela que estar\u00e1 toda a l\u00f3gica de montagem acessoada pelas demais classes. Pr\u00f3ximos passos \u00b6 Agora vamos come\u00e7ar a trabalhar no c\u00f3digo java. SIGA PARA PARTE 2","title":"H Assembler Lab 1 [parte 1]"},{"location":"H-Assembler-Lab-1-%5Bparte-1%5D/#assembler","text":"O assembler ser\u00e1 um programa escrito em java e que foi estruturado em quatro classes : Assemble Arquivo : Assemble.java Descri\u00e7\u00e3o : Classe respons\u00e1vel por criar o a de programar o Computador na FPGA e executarmos c\u00f3digo de m\u00e1quina, ela que efetivamente faz a varredura do arquivo .nasm de entrada e escreve o arquivo .hack de sa\u00edda, gerando o c\u00f3digo de m\u00e1quina. Depend\u00eancias : Code.java , Parser.java , SymbolTable.java Code Arquivo : Code.java Descri\u00e7\u00e3o : Traduz mnem\u00f4nicos da linguagem assembly para c\u00f3digos bin\u00e1rios da arquitetura Z0. Depend\u00eancias : none Parser Arquivo : Parser.java Descri\u00e7\u00e3o : Encapsula o c\u00f3digo de leitura. Carrega as instru\u00e7\u00f5es na linguagem assembly, analisa, e oferece acesso as partes da instru\u00e7\u00e3o (campos e s\u00edmbolos). Al\u00e9m disso, remove todos os espa\u00e7os em branco e coment\u00e1rios. Depend\u00eancias : none SymbolTable Arquivo : SymbolTable.java Descri\u00e7\u00e3o : Mant\u00e9m uma tabela com a correspond\u00eancia entre os r\u00f3tulos simb\u00f3licos e endere\u00e7os num\u00e9ricos de mem\u00f3ria. Depend\u00eancias : none Note que o 'orquestrador' da montagem (esse \u00e9 o termo em portugu\u00eas utilizado) \u00e9 a classe 'Assemble', nela que estar\u00e1 toda a l\u00f3gica de montagem acessoada pelas demais classes.","title":"Assembler"},{"location":"H-Assembler-Lab-1-%5Bparte-1%5D/#proximos-passos","text":"Agora vamos come\u00e7ar a trabalhar no c\u00f3digo java. SIGA PARA PARTE 2","title":"Pr\u00f3ximos passos"},{"location":"H-Assembler-Lab-1-%5Bparte-2%5D/","text":"Warning Todos do grupo devem realizar de forma individual! Iremos realizar o desenvolvimento do Assembler na IDE do Intellij, para isso precisamos importar um projeto do tipo maven. Com o Intellij instalado : Import Project: Importe a pasta do Projeto H-Assebler/Assembler : Escolha o Maven : Iremos trabalhar com o JDK 8 java-8-oracle . Ser\u00e1 necess\u00e1rio adicionar o mesmo na ferramenta: O caminho normalmente \u00e9 /usr/lib/jvm/","title":"H Assembler Lab 1 [parte 2]"},{"location":"H-Assembler-Lab-1-%5Bparte-3%5D/","text":"Deve ser realizado em dupla Iremos agora implementar um dos m\u00e9todos da classe Code , a parte respons\u00e1vel por gerar os tr\u00eas bits referentes ao jump : No Intellij abra o c\u00f3digo code.java e procure pelo m\u00e9todo jump : /** * Retorna o c\u00f3digo bin\u00e1rio do mnem\u00f4nico para realizar uma opera\u00e7\u00e3o de jump (salto). * @param mnemnonic vetor de mnem\u00f4nicos \"instru\u00e7\u00e3o\" a ser analisada. * @return Opcode (String de 3 bits) com c\u00f3digo em linguagem de m\u00e1quina para a instru\u00e7\u00e3o. */ public static String jump ( String [] mnemnonic ) { return \"\" ; } Note que o input dessa fun\u00e7\u00e3o \u00e9 um array de strings, chamado mnemnonic e seu retorno \u00e9 uma string. No mnemnonic ser\u00e1 passado a instru\u00e7\u00e3o a ser executada da seguinte forma: {\"jmp\"} {\"jge\", \"S\"} {\"jg\", \"%D\"} ... E deve retornar o bin\u00e1rio correspondente aos bits j2, j1 e j0 do comando de jump : 111 , 011 , 010 , .... Note que aesa classe n\u00e3o precisa se preocupar com a origem do jump (%S, %D, ...) apenas com o seu tipo jmp , jge , ... Implementando \u00b6 Vamos implementar algo bem simples que est\u00e1 incompleto, mas vai servir para entendermos o fluxo. Modifique o c\u00f3digo com o exemplo a seguir : public static String jump ( String [] mnemnonic ) { switch ( mnemnonic [ 0 ]){ case \"jmp\" : return \"111\" ; default : return \"000\" ; } } Com a classe implementada, podemos executar o teste unit\u00e1rio dela. No Intellij: Com o bot\u00e3o direito no test/java/assembler/CodeTest Note que o teste falhou, j\u00e1 que a nossa implementa\u00e7\u00e3o est\u00e1 incompleta. terminando \u00b6 Retorne a classe jump e termine sua implementa\u00e7\u00e3o. Execute novamente o teste at\u00e9 passar. Antes de continuar Termine de implementar essa classe","title":"H Assembler Lab 1 [parte 3]"},{"location":"H-Assembler-Lab-1-%5Bparte-3%5D/#implementando","text":"Vamos implementar algo bem simples que est\u00e1 incompleto, mas vai servir para entendermos o fluxo. Modifique o c\u00f3digo com o exemplo a seguir : public static String jump ( String [] mnemnonic ) { switch ( mnemnonic [ 0 ]){ case \"jmp\" : return \"111\" ; default : return \"000\" ; } } Com a classe implementada, podemos executar o teste unit\u00e1rio dela. No Intellij: Com o bot\u00e3o direito no test/java/assembler/CodeTest Note que o teste falhou, j\u00e1 que a nossa implementa\u00e7\u00e3o est\u00e1 incompleta.","title":"Implementando"},{"location":"H-Assembler-Lab-1-%5Bparte-3%5D/#terminando","text":"Retorne a classe jump e termine sua implementa\u00e7\u00e3o. Execute novamente o teste at\u00e9 passar. Antes de continuar Termine de implementar essa classe","title":"terminando"},{"location":"H-Assembler-Lab-1-%5Bparte-4%5D/","text":"Deve ser realizado em dupla```diff Desenvolvimento baseado em testes \u00e9 uma t\u00e9cnica que temos utilizado at\u00e9 agora para os nosso projetos, nesse m\u00e9todo fragmentando o desenvolvimento em pequenos m\u00f3dulos que s\u00e3o testados de forma individual, por testes unit\u00e1rios. O desenvolvimento \u00e9 focado em fazer com que os m\u00f3dulos passem nos testes. Como os testes n\u00e3o s\u00e3o perfeitos e n\u00e3o conseguem cobrir toda a funcionalidade do m\u00f3dulo, \u00e9 necess\u00e1rio realizarmos o teste de integra\u00e7\u00e3o, onde juntamos todas as pe\u00e7as e testamos o sistema como um todo. Utilizaremos o mesmo recurso agora em java, onde cada m\u00f3dulo (m\u00e9todo) possui um teste e quando todos os m\u00f3dulos estivem implementados e funcionando realizamos um teste de integra\u00e7\u00e3o que valida tudo. Os testes unit\u00e1rios foram feitos com o JUnit e est\u00e3o na pasta do projeto: H-Assembler/Assembler/test/java/assembler . Os testes cobrem todas os m\u00e9todos do projeto. Exemplo parser \u00b6 Os testes s\u00e3o uma guia do que cada m\u00e9todo deve fazer, e eles servir\u00e3o como complemento da documenta\u00e7\u00e3o do m\u00f3dulo. Iremos seguir o fluxo: Ler descri\u00e7\u00e3o do m\u00e9todo Abrir teste unit\u00e1rio e entender o que \u00e9 passado e o que \u00e9 esperado Desenvolver m\u00e9todo Testar Falhou? Volte para 1. Vamos pegar como exemplo o m\u00e9todo commandType do parser : /** * Retorna o tipo da instru\u00e7\u00e3o passada no argumento: * A_COMMAND para leaw, por exemplo leaw $1,%A * L_COMMAND para labels, por exemplo Xyz: , onde Xyz \u00e9 um s\u00edmbolo. * C_COMMAND para todos os outros comandos * @param command instru\u00e7\u00e3o a ser analisada. * @return o tipo da instru\u00e7\u00e3o. */ public CommandType commandType ( String command ) { return null ; } E seu teste unit\u00e1rio: /** * Teste para a instru\u00e7\u00e3o commandType */ @Test public void testParser_commandType () { try { assertTrue ( \"leaw $0,%A\" , parser . commandType ( \"leaw $0,%A\" )== Parser . CommandType . A_COMMAND ); assertTrue ( \"abc:\" , parser . commandType ( \"abc:\" )== Parser . CommandType . L_COMMAND ); assertTrue ( \"movw %A,%D\" , parser . commandType ( \"movw %A,%D\" )== Parser . CommandType . C_COMMAND ); assertTrue ( \"movw %A,%S\" , parser . commandType ( \"movw %A,%S\" )== Parser . CommandType . C_COMMAND ); .... .... } } Vamos analisar o primeiro teste: assertTrue ( \"leaw $0,%A\" , parser . commandType ( \"leaw $0,%A\" )== Parser . CommandType . A_COMMAND ); ` Nesse teste \u00e9 passado a string \"leaw $0,%A\" para o m\u00e9todo parser.commandType e esperasse na sa\u00edda A_COMMAND . Com essa informa\u00e7\u00e3o complementar conseguimos inciar o desenvolvimento dessa classe. Antes de continuar Implemente a classe parser.commandType Execute o teste unit\u00e1rio do parser at\u00e9 que o comandType passe nos testes.**","title":"H Assembler Lab 1 [parte 4]"},{"location":"H-Assembler-Lab-1-%5Bparte-4%5D/#exemplo-parser","text":"Os testes s\u00e3o uma guia do que cada m\u00e9todo deve fazer, e eles servir\u00e3o como complemento da documenta\u00e7\u00e3o do m\u00f3dulo. Iremos seguir o fluxo: Ler descri\u00e7\u00e3o do m\u00e9todo Abrir teste unit\u00e1rio e entender o que \u00e9 passado e o que \u00e9 esperado Desenvolver m\u00e9todo Testar Falhou? Volte para 1. Vamos pegar como exemplo o m\u00e9todo commandType do parser : /** * Retorna o tipo da instru\u00e7\u00e3o passada no argumento: * A_COMMAND para leaw, por exemplo leaw $1,%A * L_COMMAND para labels, por exemplo Xyz: , onde Xyz \u00e9 um s\u00edmbolo. * C_COMMAND para todos os outros comandos * @param command instru\u00e7\u00e3o a ser analisada. * @return o tipo da instru\u00e7\u00e3o. */ public CommandType commandType ( String command ) { return null ; } E seu teste unit\u00e1rio: /** * Teste para a instru\u00e7\u00e3o commandType */ @Test public void testParser_commandType () { try { assertTrue ( \"leaw $0,%A\" , parser . commandType ( \"leaw $0,%A\" )== Parser . CommandType . A_COMMAND ); assertTrue ( \"abc:\" , parser . commandType ( \"abc:\" )== Parser . CommandType . L_COMMAND ); assertTrue ( \"movw %A,%D\" , parser . commandType ( \"movw %A,%D\" )== Parser . CommandType . C_COMMAND ); assertTrue ( \"movw %A,%S\" , parser . commandType ( \"movw %A,%S\" )== Parser . CommandType . C_COMMAND ); .... .... } } Vamos analisar o primeiro teste: assertTrue ( \"leaw $0,%A\" , parser . commandType ( \"leaw $0,%A\" )== Parser . CommandType . A_COMMAND ); ` Nesse teste \u00e9 passado a string \"leaw $0,%A\" para o m\u00e9todo parser.commandType e esperasse na sa\u00edda A_COMMAND . Com essa informa\u00e7\u00e3o complementar conseguimos inciar o desenvolvimento dessa classe. Antes de continuar Implemente a classe parser.commandType Execute o teste unit\u00e1rio do parser at\u00e9 que o comandType passe nos testes.**","title":"Exemplo parser"},{"location":"H-Assembler-Lab-1-%5Bparte-5%5D/","text":"+ Deve ser realizado em dupla Implemente o m\u00e9todo initialize da classe SymbolTable utilizando os conceitos visto nos outros labs. Dicas sobre o SymbolTable","title":"H Assembler Lab 1 [parte 5]"},{"location":"H-Assembler-Lab-1/","text":"Esse laborat\u00f3rio introduz uma s\u00e9rie de conceitos e ferramentas e deve ser realizado individualmente ou em dupla (como indicado no come\u00e7o de cada parte). Ao final do laborat\u00f3rio voc\u00ea dever\u00e1: Entender o que \u00e9 um arquivo .hack e .mif Ter um projeto importado no Intellij Ter o m\u00e9todo code.jump implementando Saber como executar os testes unit\u00e1rios Ter o m\u00e9todo parser.commandType implementando Saber como extrair informa\u00e7\u00f5es dos testes unit\u00e1rios Ter o fillSymbolTable.initialize implementando Pr\u00f3ximos passos \u00b6 Voc\u00ea \u00e9 Scrum Master e n\u00e3o sabe por onde come\u00e7ar? De uma olhada nessas dicas: Vixi! Sou Scrum Master Scrum Master atualize o reposit\u00f3rio com o upstream antes de continuar SEGUIR PARA A PRIMEIRA PARTE","title":"H Assembler Lab 1"},{"location":"H-Assembler-Lab-1/#proximos-passos","text":"Voc\u00ea \u00e9 Scrum Master e n\u00e3o sabe por onde come\u00e7ar? De uma olhada nessas dicas: Vixi! Sou Scrum Master Scrum Master atualize o reposit\u00f3rio com o upstream antes de continuar SEGUIR PARA A PRIMEIRA PARTE","title":"Pr\u00f3ximos passos"},{"location":"H-Assembler-Prerequisitos/","text":"(contanto com o restante da infra j\u00e1 esteja funcionando) Java JDK 8 Maven https://maven.apache.org/install.html IDE Intellij Se voc\u00ea est\u00e1 usando o SSD fornecido, precisa apenas executar os comandos a seguir: $ sudo apt install maven $ python3 -m pip install joblib --user $ sudo snap install intellij-idea-community --classic --edge Caso contr\u00e1rio precisa instalar o JAVA 8 oficial (o open n\u00e3o funciona).","title":"H Assembler Prerequisitos"},{"location":"H-Assembler-Projeto/","text":"H - Assembler \u00b6 Nesse projeto iremos criar o programa assembler que \u00e9 respons\u00e1vel por traduzir os c\u00f3digos escrito em Assembly para a linguagem de m\u00e1quina. Instru\u00e7\u00f5es \u00b6 As instru\u00e7\u00f5es t\u00e9cnicas referente ao projeto est\u00e3o no laborat\u00f3rio 1 desse projeto. M\u00f3dulos a serem implementados \u00b6 O projeto no total possui 5 m\u00f3dulos, sendo que o m\u00f3dulo AssemblerZ01.java j\u00e1 est\u00e1 pronto. Tip Os m\u00f3dulos est\u00e3o listados de maneira Top - Down AssemblerZ01 Arquivo : AssemblerZ01.java Descri\u00e7\u00e3o : Main do projeto. Recebe como par\u00e2metro o nome do arquivo .nasm e o nome do arquivo bin\u00e1rio de m\u00e1quina .hack . a ser escrito, passa essas informa\u00e7\u00f5es para a classe Assemble. Essa classe que inicializa a tabela de s\u00edmbolo ( fillSymbolTable ) e chama o m\u00e9todo generateMachineCode para efetivamente gerar o arquivo de sa\u00edda. Depend\u00eancias : Assemble.java Assemble Arquivo : Assemble.java Descri\u00e7\u00e3o : Classe respons\u00e1vel por criar o c\u00f3digo de m\u00e1quina, ela que efetivamente faz a varredura do arquivo .nasm de entrada e escreve o arquivo .hack de sa\u00edda, gerando o c\u00f3digo de m\u00e1quina. Depend\u00eancias : Code.java , Parser.java , SymbolTable.java Code Arquivo : Code.java Descri\u00e7\u00e3o : Traduz mnem\u00f4nicos da linguagem assembly para c\u00f3digos bin\u00e1rios da arquitetura Z0. Depend\u00eancias : none Parser Arquivo : Parser.java Descri\u00e7\u00e3o : Encapsula o c\u00f3digo de leitura. Carrega as instru\u00e7\u00f5es na linguagem assembly, analisa, e oferece acesso as partes da instru\u00e7\u00e3o (campos e s\u00edmbolos). Al\u00e9m disso, remove todos os espa\u00e7os em branco e coment\u00e1rios. Depend\u00eancias : none SymbolTable Arquivo : SymbolTable.java Descri\u00e7\u00e3o : Mant\u00e9m uma tabela com a correspond\u00eancia entre os r\u00f3tulos simb\u00f3licos e endere\u00e7os num\u00e9ricos de mem\u00f3ria. Depend\u00eancias : none Rubricas para avalia\u00e7\u00e3o de projetos \u00b6 Cada integrante do grupo ir\u00e1 receber duas notas: uma referente ao desenvolvimento total do projeto (Projeto) e outra referente a sua participa\u00e7\u00e3o individual no grupo (que depende do seu papel). Projeto \u00b6 Conceito I - Menos da metade dos m\u00f3dulos funcionando D - Teste unit\u00e1rio ou Teste integra\u00e7\u00e3o n\u00e3o passa C - Criado assembler a partir de estrutura de c\u00f3digo disponibilizada - Todos os testes unit\u00e1rios passam no teste - Os testes de integra\u00e7\u00e3o passam nos testes - Travis configurado corretamente B - Implementando modo verbose (-v) que possibilita analisar o assembler e suas etapas - Verifica se instru\u00e7\u00e3o de jump \u00e9 seguida de NOP, caso contr\u00e1rio da erro B+ - Insere automaticamente um NOP ap\u00f3s intru\u00e7\u00e3o de JUMP que n\u00e3o \u00e9 seguida de nop. Imprime mensagem de alerta que isso foi feito. A - Possui macros para facilitar desenvolvimento no assembly* A+ - C\u00f3digo e documenta\u00e7\u00e3o gerada com DoxyGen Dicas Macro - Rubrica A Veja a dica de como implementar Macros","title":"H - Assembler"},{"location":"H-Assembler-Projeto/#h-assembler","text":"Nesse projeto iremos criar o programa assembler que \u00e9 respons\u00e1vel por traduzir os c\u00f3digos escrito em Assembly para a linguagem de m\u00e1quina.","title":"H - Assembler"},{"location":"H-Assembler-Projeto/#instrucoes","text":"As instru\u00e7\u00f5es t\u00e9cnicas referente ao projeto est\u00e3o no laborat\u00f3rio 1 desse projeto.","title":"Instru\u00e7\u00f5es"},{"location":"H-Assembler-Projeto/#modulos-a-serem-implementados","text":"O projeto no total possui 5 m\u00f3dulos, sendo que o m\u00f3dulo AssemblerZ01.java j\u00e1 est\u00e1 pronto. Tip Os m\u00f3dulos est\u00e3o listados de maneira Top - Down AssemblerZ01 Arquivo : AssemblerZ01.java Descri\u00e7\u00e3o : Main do projeto. Recebe como par\u00e2metro o nome do arquivo .nasm e o nome do arquivo bin\u00e1rio de m\u00e1quina .hack . a ser escrito, passa essas informa\u00e7\u00f5es para a classe Assemble. Essa classe que inicializa a tabela de s\u00edmbolo ( fillSymbolTable ) e chama o m\u00e9todo generateMachineCode para efetivamente gerar o arquivo de sa\u00edda. Depend\u00eancias : Assemble.java Assemble Arquivo : Assemble.java Descri\u00e7\u00e3o : Classe respons\u00e1vel por criar o c\u00f3digo de m\u00e1quina, ela que efetivamente faz a varredura do arquivo .nasm de entrada e escreve o arquivo .hack de sa\u00edda, gerando o c\u00f3digo de m\u00e1quina. Depend\u00eancias : Code.java , Parser.java , SymbolTable.java Code Arquivo : Code.java Descri\u00e7\u00e3o : Traduz mnem\u00f4nicos da linguagem assembly para c\u00f3digos bin\u00e1rios da arquitetura Z0. Depend\u00eancias : none Parser Arquivo : Parser.java Descri\u00e7\u00e3o : Encapsula o c\u00f3digo de leitura. Carrega as instru\u00e7\u00f5es na linguagem assembly, analisa, e oferece acesso as partes da instru\u00e7\u00e3o (campos e s\u00edmbolos). Al\u00e9m disso, remove todos os espa\u00e7os em branco e coment\u00e1rios. Depend\u00eancias : none SymbolTable Arquivo : SymbolTable.java Descri\u00e7\u00e3o : Mant\u00e9m uma tabela com a correspond\u00eancia entre os r\u00f3tulos simb\u00f3licos e endere\u00e7os num\u00e9ricos de mem\u00f3ria. Depend\u00eancias : none","title":"M\u00f3dulos a serem implementados"},{"location":"H-Assembler-Projeto/#rubricas-para-avaliacao-de-projetos","text":"Cada integrante do grupo ir\u00e1 receber duas notas: uma referente ao desenvolvimento total do projeto (Projeto) e outra referente a sua participa\u00e7\u00e3o individual no grupo (que depende do seu papel).","title":"Rubricas para avalia\u00e7\u00e3o de projetos"},{"location":"H-Assembler-Projeto/#projeto","text":"Conceito I - Menos da metade dos m\u00f3dulos funcionando D - Teste unit\u00e1rio ou Teste integra\u00e7\u00e3o n\u00e3o passa C - Criado assembler a partir de estrutura de c\u00f3digo disponibilizada - Todos os testes unit\u00e1rios passam no teste - Os testes de integra\u00e7\u00e3o passam nos testes - Travis configurado corretamente B - Implementando modo verbose (-v) que possibilita analisar o assembler e suas etapas - Verifica se instru\u00e7\u00e3o de jump \u00e9 seguida de NOP, caso contr\u00e1rio da erro B+ - Insere automaticamente um NOP ap\u00f3s intru\u00e7\u00e3o de JUMP que n\u00e3o \u00e9 seguida de nop. Imprime mensagem de alerta que isso foi feito. A - Possui macros para facilitar desenvolvimento no assembly* A+ - C\u00f3digo e documenta\u00e7\u00e3o gerada com DoxyGen Dicas Macro - Rubrica A Veja a dica de como implementar Macros","title":"Projeto"},{"location":"H-Assembler-Testando/","text":"A pasta do projeto H, possui a seguinte estrutura: scripts: Scripts em python que automatizam a execu\u00e7\u00e3o dos testes; compileNasmMyAssembler : Compila os nasms do projeto F-Assembly com o assembler do grupo e salva o resultado em bin/hack/ testeAssembler : Compila os nasms com o assembler do grupo e executa a simula\u00e7\u00e3o no Z01.1 ( standard-professor ). testeAssemblerMyCPU : Compila os nasms com o assembler do grupo e executa a simula\u00e7\u00e3o no Z01.1 do grupo ( projeto G-CPU ). genJAR : Gera um Jar que ser\u00e1 utilizado pelos testes anteriores a partir das fontes em Assembler/src/main/ -> Salva em Assembler/Z01-Assembler.jar . Esses scripts de testes utilizam o projeto F-Assembly! bin/hack/*.hack : Arquivos .hack convertidos via Z01-Assembler.jar Assembler/src/main/java/assembler : C\u00f3digo fonte em java do assembler, que deve ser implementando por voc\u00eas! Testes \u00b6 \u00c9 disponibilizado dois tipos de testes: Unit\u00e1rio para as classes em java e de Integra\u00e7\u00e3o para o Assembler como um todo. Os testes unit\u00e1rios das classes est\u00e3o localizados em Assembler/src/tsts/ e pode ser executado de duas maneiras: Via IDE (Intellij) Via maven na gera\u00e7\u00e3o do jar (`genJAR.py**) J\u00e1 o teste de integra\u00e7\u00e3o que considera como as classes foram utilizadas para a gera\u00e7\u00e3o do Assembler \u00e9 executado via script testeAssembler.py , executando os seguintes passos : Gera o jar ( genJAR.py ) input : Assembler/src/main/java/assembler/*.java* output: Z01-Assembler.jar Compila os nasms input: F-Assembly/src/nasm/*.nasm* output: H-Assembler/bin/hack/*.mif* Executa os testes no hardware (usando o hardware de refer\u00eancia) input: F-Assembly/tests/* input: H-Assembler/bin/hack/*.mif* output: F-Assembly/tests/tst/name/*_end.mif* Compara resultado com esperado input : F-Assembly/tests/tst/name/*_tst.mif* output: Terminal","title":"H Assembler Testando"},{"location":"H-Assembler-Testando/#testes","text":"\u00c9 disponibilizado dois tipos de testes: Unit\u00e1rio para as classes em java e de Integra\u00e7\u00e3o para o Assembler como um todo. Os testes unit\u00e1rios das classes est\u00e3o localizados em Assembler/src/tsts/ e pode ser executado de duas maneiras: Via IDE (Intellij) Via maven na gera\u00e7\u00e3o do jar (`genJAR.py**) J\u00e1 o teste de integra\u00e7\u00e3o que considera como as classes foram utilizadas para a gera\u00e7\u00e3o do Assembler \u00e9 executado via script testeAssembler.py , executando os seguintes passos : Gera o jar ( genJAR.py ) input : Assembler/src/main/java/assembler/*.java* output: Z01-Assembler.jar Compila os nasms input: F-Assembly/src/nasm/*.nasm* output: H-Assembler/bin/hack/*.mif* Executa os testes no hardware (usando o hardware de refer\u00eancia) input: F-Assembly/tests/* input: H-Assembler/bin/hack/*.mif* output: F-Assembly/tests/tst/name/*_end.mif* Compara resultado com esperado input : F-Assembly/tests/tst/name/*_tst.mif* output: Terminal","title":"Testes"},{"location":"I-VM-Ferramental-Memoria/","text":"Para a m\u00e1quina virtual funcionar corretamente devemos agora definir regi\u00f5es de mem\u00f3ria que servir\u00e1 para aplica\u00e7\u00f5es espec\u00edficas, tal como armazenar: o topo da pilha ( SP , Stack Pointer), os locais dos par\u00e2metros passados na chamada de fun\u00e7\u00e3o ( ARG , argument), os endere\u00e7os das vari\u00e1veis locais de uma fun\u00e7\u00e3o ( LCL , local) ... A seguir um resumo dos endere\u00e7os de mem\u00f3ria e suas fun\u00e7\u00f5es : Endere\u00e7o (RAM) S\u00edmbolo Nome Uso 0 SP Stack Pointer Ponteiro para o topo da pilha 1 LCL Local Ponteiro para a base das vari\u00e1veis de um fun\u00e7\u00e3o 2 ARG Argument Ponteiro para a base dos argumentos de uma fun\u00e7\u00e3o 3 THIS This Ponteiro para a base do segmento this 4 THAT That Ponteiro para a base do segmento that 5..12 Temp Temporary Endere\u00e7os para armazenar vari\u00e1veis tempor\u00e1rias Al\u00e9m dos endere\u00e7os espec\u00edficos (que possuem papeis especiais), devemos tamb\u00e9m definir regi\u00f5es da mem\u00f3ria que ser\u00e3o utilizadas para armazenar tipos de dados espec\u00edficos, s\u00e3o eles : Endere\u00e7o (RAM) Nome Uso 16-255 Static Vari\u00e1veis est\u00e1ticas (acess\u00edveis por todas as fun\u00e7\u00f5es) 256-2047 Stack Pilha utilizada pela vm (stack pointer) 2048-16383 Heap Usada para armazenar objetos e vetores 16384- I/O Perif\u00e9ricos mapeados em mem\u00f3ria Iremos detalhar um pouco de cada item descrito nesse resumo. Stack \u00b6 A stack \u00e9 a regi\u00e3o de mem\u00f3ria utilizada pela VM para armazenar valores e realizar opera\u00e7\u00f5es, funciona como uma forma de abstra\u00e7\u00e3o do hardware, j\u00e1 que agora toda manipula\u00e7\u00e3o de dados acontece na Stack e n\u00e3o mais nos registradores. \u00c9 claro que essa manipula\u00e7\u00e3o influencia nos registradores do hardware, mas o programador n\u00e3o mais precisa ter todo o conhecimento do hardware nas opera\u00e7\u00f5es. Por exemplo a opera\u00e7\u00e3o : push constant 5 push constant 3 add Adiciona o valor 5 e o 3 para o topo da pilha e os soma, resultando em um \u00fanico valor : 8. Notem que para essa opera\u00e7\u00e3o ser realizada no hardware do Z01 tivemos que usar os registradores para tornar a opera\u00e7\u00e3o vi\u00e1vel, por\u00e9m isso n\u00e3o \u00e9 mais vis\u00edvel do programa VM. Nesse camada de software n\u00e3o interessa mais se o hardware possui 2, 3, ... N registradores o resultado da opera\u00e7\u00e3o ser\u00e1 a mesma. Teremos 8 no topo da pilha. O hardware vai influenciar o VMtranslator que deve traduzir a linguagem de m\u00e1quina virtual por pilha para a linguagem assembly, o n\u00famero de registradores pode influenciar a performance do computador mas n\u00e3o ir\u00e1 mudar o conceito de pilha. A stack \u00e9 utilizada tamb\u00e9m para armazenar os valores passados na chamada de fun\u00e7\u00e3o e tamb\u00e9m para armazenar o resultado (return) de uma fun\u00e7\u00e3o. Stack Pointer \u00b6 \u00c9 um ponteiro que indica a onde est\u00e1 o endere\u00e7o do topo da pilha, como a pilha cresce e diminui dinamicamente (conforme os push, pops e opera\u00e7\u00f5es) necessitamos armazenar em algum local o endere\u00e7o do topo da pilha, conforme figura a seguir : Stack overflow? \u00b6 Agora fica mais claro o significado do site stack overflow ? Indica o estouro da pilha. Imagine a situa\u00e7\u00e3o na qual s\u00f3 oclocamos dados na pilha e nunca tiramos ( pop , em algum momento a pilha ir\u00e1 passar seu valor m\u00e1ximo, que no nosso caso \u00e9 : 2047 - 256 = 1791 endere\u00e7os e come\u00e7ar\u00e1 a escrever na regi\u00e3o reservada peara o Heap, corrompendo os dados ali salvos. Fun\u00e7\u00e3o \u00b6 Os ponteiros LCL e ARG s\u00e3o utilizados somente na execu\u00e7\u00e3o de uma fun\u00e7\u00e3o o ARG indica o endere\u00e7o da stack na qual os par\u00e2metros que ser\u00e3o passados para a fun\u00e7\u00e3o est\u00e3o salvos e o LCL \u00e9 indicado para apontar para o endere\u00e7o na pilha utilizado para armazenar vari\u00e1veis locais. O fluxo de chamada de fun\u00e7\u00e3o, de forma simplificada \u00e9 : Coloca na pilha os argumentos que ser passado para a fun\u00e7\u00e3o a quantidade varia conforme a demanda da fun\u00e7\u00e3o Chama a fun\u00e7\u00e3o ( call ) Aloca na pilha os endere\u00e7os de mem\u00f3ria para armazenar os locals Atualiza os ponteiros : SP, LCL, ARG O fluxo de chamada de fun\u00e7\u00e3o (call) \u00e9 um pouco complexo, pois demanda que salvemos algumas informa\u00e7\u00f5es da pilha antes de executarmos a fun\u00e7\u00e3o (precisamos conseguir ap\u00f3s a execu\u00e7\u00e3o da fun\u00e7\u00e3o retornar para um estado similar antes da execu\u00e7\u00e3o). Para isso \u00e9 salvo na pilha : Endere\u00e7o de retorno LCL (antes da chamada de fun\u00e7\u00e3o) ARG (antes da chamada de fun\u00e7\u00e3o) This (antes da chamada de fun\u00e7\u00e3o) That (antes da chamada de fun\u00e7\u00e3o) LCL - Local \u00b6 Local indica o endere\u00e7o na pilha na qual foi alocado para as vari\u00e1veis locais de uma fun\u00e7\u00e3o, a quantidade de endere\u00e7os alocados varia conforme a declara\u00e7\u00e3o da fun\u00e7\u00e3o, que pode possuir zero ou mais vari\u00e1veis tempor\u00e1rias. Peguemos como exemplo uma fun\u00e7\u00e3o em java : void example(int a, int b){ int aux0; int aux1; aux0 = a; aux1 = b; } Note que essa fun\u00e7\u00e3o possui duas vari\u00e1veis locais : aux0, aux1 , que s\u00e3o vis\u00edveis somente dentro do escopo da fun\u00e7\u00e3o, essas vari\u00e1veis s\u00e3o alocadas quando a fun\u00e7\u00e3o \u00e9 chamada e desalocada quando a fun\u00e7\u00e3o retorna. Essas vari\u00e1veis (aux0, aux1) servem como vari\u00e1veis locais da fun\u00e7\u00e3o, e s\u00e3o salvas na stack, como a ilustra\u00e7\u00e3o a seguir: O exemplo em java anterior seria traduzido para a linguagem VM (de forma imediata) na seguinte maneira : function example 2 push argument 0 // coloca na pilha o valor a pop local 0 // aux0 = a push argument 1 // coloca na pilha o valor b pop local 1 // aux1 = b Note que o que define local 0 e local 1 \u00e9 a ordem na qual as vari\u00e1veis foram declaradas, como a vari\u00e1vel aux0 foi declarada primeiro, ela \u00e9 alocada no local 0 . O LCL aponta apenas para o endere\u00e7o do primeiro local , os demais s\u00e3o inferidos da seguinte maneira: push local n Tip Endere\u00e7o local n = LCL + n ARG - Argumento \u00b6 O ponteiro ARG indica a onde na pilha est\u00e3o salvos os argumentos que a fun\u00e7\u00e3o pode acessar, e segue a mesma l\u00f3gica do LCL, onde o ARG aponta para o primeiro argumento e o endere\u00e7o dos demais s\u00e3o inferidos com base no endere\u00e7o do primeiro. Tip Endere\u00e7o argument n = ARG + n Static variables \u00b6 \u00c9 a regi\u00e3o da mem\u00f3ria utilizada para armazenar vari\u00e1veis compartilhadas entre o mesmo arquivo .vm, conforme figura a seguir : A static n\u00e3o \u00e9 vis\u00edvel entre diferentes arquivos .vm, deixando as vari\u00e1veis limitadas a um escopo. O static ser\u00e1 utilizado para armazenar as vari\u00e1veis est\u00e1ticas de uma determinada classe. Exemplo de acesso ao static : O exemplo a seguir demonstra duas classes (class1.vm e class2.vm) sendo utilizadas com os seus respectivos stacks. Nesse exemplo, a fun\u00e7\u00e3o main inicializa o static da classe 1 em : static[0] = 6, static[1] = 8 e o static ca classe 2 em : static[0] = 23, static[0] = 15. Isso ser\u00e1 bastante utilizado para fazer a implementa\u00e7\u00e3o da estrutura a seguir : public class class1 { static int valor0 ; // alocado no static 0 static int valor1 ; // alocado no static 1 public void set ( int var1 , va2 ){ valor0 = var1 ; valor1 = var2 ; } public void get ( void ){ return ( valor0 - valor1 ); } Note As vari\u00e1veis est\u00e1ticas s\u00e3o compartilhadas entre os objetos inicializados a partir da mesma classe, alocando assim apenas um slot de mem\u00f3ria para todos os objetos criados a partir dessa classe ^1. ^1: https://beginnersbook.com/2013/05/static-variable/ HEAP \u00b6 O HEAP \u00e9 a regi\u00e3o de mem\u00f3ria a ser utilizada para armazenamento objetos e vetores, um objeto ser\u00e1 constru\u00eddo a partir de uma classe e compartilhar\u00e1 as mesma vari\u00e1veis est\u00e1ticas mas n\u00e3o as mesmas vari\u00e1veis locais ao objeto. Vamos tomar como ponto de partida o exemplo a seguir que inicializa dois objetos (terra e lua) do tipo corpoCeleste : void main (){ corpoCeleste terra = new corpoCeletes (); terra . setMassa ( 1200 ); corpoCeleste lua = new corpoCeleste (); lua . setMassa ( 32 ); lua . pi = 314 ; } public class corpoCeleste (){ static int pi ; int raio ; int gravidade ; int massa ; void getMassa (){ return ( this . massa ); } void setMassa ( int m ){ this . massa = m ; } } Esse exemplo aloca no Heap tr\u00eas endere\u00e7os em locais diferentes para cada objeto criado do tipo corpoCeleste, por\u00e9m a vari\u00e1vel pi , que \u00e9 est\u00e1tica \u00e9 comum a todos os objetos criados a partir da mesma classe. A figura a seguir ilustra como essas vari\u00e1veis seriam alocadas em mem\u00f3ria. This \u00b6 This \u00e9 o ponteiro que refer\u00eancia o pr\u00f3prio objeto: objeto na qual o m\u00e9todo ou construtor est\u00e1 sendo chamado. No caso da chamada do m\u00e9todo getMassa() da classe corpoCeleste, o ponteiro This ser\u00e1 ajustado para apontar para o objeto na qual o m\u00e9todo foi chamado. O fluxo da m\u00e1quina virtual ser\u00e1 o seguinte : Ajusta o this para apontar para o in\u00edcio do HEAP pertencente ao objeto chama a fun\u00e7\u00e3o getMassa do arquivo corpoCeleste.vm That \u00b6 O ponteiro That \u00e9 utilizado para referenciar outro objeto, utilizado no exemplo a seguir: M\u00e9todo objeto Celeste: void compareMassa ( corpoCeleste outro ){ if ( this . massa == outro . massa ){ return ( True ); } else { return ( False ); } } C\u00f3digo principal: void main (){ ... rtn = terra . compareMassa ( lua ); } Nesse exemplo, inclu\u00edmos um novo m\u00e9todo (compareMass) na classe corpoCeleste, esse novo m\u00e9todo compara a massa de um outro objeto com a do pr\u00f3prio objeto, retornando verdadeiro ou falso dependendo do resultado. Como esse c\u00f3digo seria traduzido para VM? O objeto em quest\u00e3o ser\u00e1 acessado utilizando o ponteiro this e o objeto a ser comparado ser\u00e1 acessado via o that . O compilador da linguagem de alto n\u00edvel para VM ser\u00e1 respons\u00e1vel por alocar os objetos nos endere\u00e7os certos. function main 0 ... push constant 2048 // endere\u00e7o objeto terra push constant 2051 // endere\u00e7o objeto lua call cortpoCeleste.compare mass 2 function corpoCeleste.compareMass 0 push argument 0 pop pointer 0 // atualiza endere\u00e7o this push argument 1 pop pointer 1 // atualiza endere\u00e7o that push this 2 // this 0 = gravidade; this 1 = raio; this 2 = massa push that 2 // that 0 = gravidade; this 1 = raio; this 2 = massa eq return Note que quando o m\u00e9todo for chamado (no caso da vm o m\u00e9todo ser\u00e1 traduzido para uma fun\u00e7\u00e3o), os ponteiros this e that devem ser passados via a chama da fun\u00e7\u00e3o, e no come\u00e7o da fun\u00e7\u00e3o atualizado os endere\u00e7os RAM[3] - This e RAM[4] - That.","title":"I VM Ferramental Memoria"},{"location":"I-VM-Ferramental-Memoria/#stack","text":"A stack \u00e9 a regi\u00e3o de mem\u00f3ria utilizada pela VM para armazenar valores e realizar opera\u00e7\u00f5es, funciona como uma forma de abstra\u00e7\u00e3o do hardware, j\u00e1 que agora toda manipula\u00e7\u00e3o de dados acontece na Stack e n\u00e3o mais nos registradores. \u00c9 claro que essa manipula\u00e7\u00e3o influencia nos registradores do hardware, mas o programador n\u00e3o mais precisa ter todo o conhecimento do hardware nas opera\u00e7\u00f5es. Por exemplo a opera\u00e7\u00e3o : push constant 5 push constant 3 add Adiciona o valor 5 e o 3 para o topo da pilha e os soma, resultando em um \u00fanico valor : 8. Notem que para essa opera\u00e7\u00e3o ser realizada no hardware do Z01 tivemos que usar os registradores para tornar a opera\u00e7\u00e3o vi\u00e1vel, por\u00e9m isso n\u00e3o \u00e9 mais vis\u00edvel do programa VM. Nesse camada de software n\u00e3o interessa mais se o hardware possui 2, 3, ... N registradores o resultado da opera\u00e7\u00e3o ser\u00e1 a mesma. Teremos 8 no topo da pilha. O hardware vai influenciar o VMtranslator que deve traduzir a linguagem de m\u00e1quina virtual por pilha para a linguagem assembly, o n\u00famero de registradores pode influenciar a performance do computador mas n\u00e3o ir\u00e1 mudar o conceito de pilha. A stack \u00e9 utilizada tamb\u00e9m para armazenar os valores passados na chamada de fun\u00e7\u00e3o e tamb\u00e9m para armazenar o resultado (return) de uma fun\u00e7\u00e3o.","title":"Stack"},{"location":"I-VM-Ferramental-Memoria/#stack-pointer","text":"\u00c9 um ponteiro que indica a onde est\u00e1 o endere\u00e7o do topo da pilha, como a pilha cresce e diminui dinamicamente (conforme os push, pops e opera\u00e7\u00f5es) necessitamos armazenar em algum local o endere\u00e7o do topo da pilha, conforme figura a seguir :","title":"Stack Pointer"},{"location":"I-VM-Ferramental-Memoria/#stack-overflow","text":"Agora fica mais claro o significado do site stack overflow ? Indica o estouro da pilha. Imagine a situa\u00e7\u00e3o na qual s\u00f3 oclocamos dados na pilha e nunca tiramos ( pop , em algum momento a pilha ir\u00e1 passar seu valor m\u00e1ximo, que no nosso caso \u00e9 : 2047 - 256 = 1791 endere\u00e7os e come\u00e7ar\u00e1 a escrever na regi\u00e3o reservada peara o Heap, corrompendo os dados ali salvos.","title":"Stack overflow?"},{"location":"I-VM-Ferramental-Memoria/#funcao","text":"Os ponteiros LCL e ARG s\u00e3o utilizados somente na execu\u00e7\u00e3o de uma fun\u00e7\u00e3o o ARG indica o endere\u00e7o da stack na qual os par\u00e2metros que ser\u00e3o passados para a fun\u00e7\u00e3o est\u00e3o salvos e o LCL \u00e9 indicado para apontar para o endere\u00e7o na pilha utilizado para armazenar vari\u00e1veis locais. O fluxo de chamada de fun\u00e7\u00e3o, de forma simplificada \u00e9 : Coloca na pilha os argumentos que ser passado para a fun\u00e7\u00e3o a quantidade varia conforme a demanda da fun\u00e7\u00e3o Chama a fun\u00e7\u00e3o ( call ) Aloca na pilha os endere\u00e7os de mem\u00f3ria para armazenar os locals Atualiza os ponteiros : SP, LCL, ARG O fluxo de chamada de fun\u00e7\u00e3o (call) \u00e9 um pouco complexo, pois demanda que salvemos algumas informa\u00e7\u00f5es da pilha antes de executarmos a fun\u00e7\u00e3o (precisamos conseguir ap\u00f3s a execu\u00e7\u00e3o da fun\u00e7\u00e3o retornar para um estado similar antes da execu\u00e7\u00e3o). Para isso \u00e9 salvo na pilha : Endere\u00e7o de retorno LCL (antes da chamada de fun\u00e7\u00e3o) ARG (antes da chamada de fun\u00e7\u00e3o) This (antes da chamada de fun\u00e7\u00e3o) That (antes da chamada de fun\u00e7\u00e3o)","title":"Fun\u00e7\u00e3o"},{"location":"I-VM-Ferramental-Memoria/#lcl-local","text":"Local indica o endere\u00e7o na pilha na qual foi alocado para as vari\u00e1veis locais de uma fun\u00e7\u00e3o, a quantidade de endere\u00e7os alocados varia conforme a declara\u00e7\u00e3o da fun\u00e7\u00e3o, que pode possuir zero ou mais vari\u00e1veis tempor\u00e1rias. Peguemos como exemplo uma fun\u00e7\u00e3o em java : void example(int a, int b){ int aux0; int aux1; aux0 = a; aux1 = b; } Note que essa fun\u00e7\u00e3o possui duas vari\u00e1veis locais : aux0, aux1 , que s\u00e3o vis\u00edveis somente dentro do escopo da fun\u00e7\u00e3o, essas vari\u00e1veis s\u00e3o alocadas quando a fun\u00e7\u00e3o \u00e9 chamada e desalocada quando a fun\u00e7\u00e3o retorna. Essas vari\u00e1veis (aux0, aux1) servem como vari\u00e1veis locais da fun\u00e7\u00e3o, e s\u00e3o salvas na stack, como a ilustra\u00e7\u00e3o a seguir: O exemplo em java anterior seria traduzido para a linguagem VM (de forma imediata) na seguinte maneira : function example 2 push argument 0 // coloca na pilha o valor a pop local 0 // aux0 = a push argument 1 // coloca na pilha o valor b pop local 1 // aux1 = b Note que o que define local 0 e local 1 \u00e9 a ordem na qual as vari\u00e1veis foram declaradas, como a vari\u00e1vel aux0 foi declarada primeiro, ela \u00e9 alocada no local 0 . O LCL aponta apenas para o endere\u00e7o do primeiro local , os demais s\u00e3o inferidos da seguinte maneira: push local n Tip Endere\u00e7o local n = LCL + n","title":"LCL - Local"},{"location":"I-VM-Ferramental-Memoria/#arg-argumento","text":"O ponteiro ARG indica a onde na pilha est\u00e3o salvos os argumentos que a fun\u00e7\u00e3o pode acessar, e segue a mesma l\u00f3gica do LCL, onde o ARG aponta para o primeiro argumento e o endere\u00e7o dos demais s\u00e3o inferidos com base no endere\u00e7o do primeiro. Tip Endere\u00e7o argument n = ARG + n","title":"ARG - Argumento"},{"location":"I-VM-Ferramental-Memoria/#static-variables","text":"\u00c9 a regi\u00e3o da mem\u00f3ria utilizada para armazenar vari\u00e1veis compartilhadas entre o mesmo arquivo .vm, conforme figura a seguir : A static n\u00e3o \u00e9 vis\u00edvel entre diferentes arquivos .vm, deixando as vari\u00e1veis limitadas a um escopo. O static ser\u00e1 utilizado para armazenar as vari\u00e1veis est\u00e1ticas de uma determinada classe. Exemplo de acesso ao static : O exemplo a seguir demonstra duas classes (class1.vm e class2.vm) sendo utilizadas com os seus respectivos stacks. Nesse exemplo, a fun\u00e7\u00e3o main inicializa o static da classe 1 em : static[0] = 6, static[1] = 8 e o static ca classe 2 em : static[0] = 23, static[0] = 15. Isso ser\u00e1 bastante utilizado para fazer a implementa\u00e7\u00e3o da estrutura a seguir : public class class1 { static int valor0 ; // alocado no static 0 static int valor1 ; // alocado no static 1 public void set ( int var1 , va2 ){ valor0 = var1 ; valor1 = var2 ; } public void get ( void ){ return ( valor0 - valor1 ); } Note As vari\u00e1veis est\u00e1ticas s\u00e3o compartilhadas entre os objetos inicializados a partir da mesma classe, alocando assim apenas um slot de mem\u00f3ria para todos os objetos criados a partir dessa classe ^1. ^1: https://beginnersbook.com/2013/05/static-variable/","title":"Static variables"},{"location":"I-VM-Ferramental-Memoria/#heap","text":"O HEAP \u00e9 a regi\u00e3o de mem\u00f3ria a ser utilizada para armazenamento objetos e vetores, um objeto ser\u00e1 constru\u00eddo a partir de uma classe e compartilhar\u00e1 as mesma vari\u00e1veis est\u00e1ticas mas n\u00e3o as mesmas vari\u00e1veis locais ao objeto. Vamos tomar como ponto de partida o exemplo a seguir que inicializa dois objetos (terra e lua) do tipo corpoCeleste : void main (){ corpoCeleste terra = new corpoCeletes (); terra . setMassa ( 1200 ); corpoCeleste lua = new corpoCeleste (); lua . setMassa ( 32 ); lua . pi = 314 ; } public class corpoCeleste (){ static int pi ; int raio ; int gravidade ; int massa ; void getMassa (){ return ( this . massa ); } void setMassa ( int m ){ this . massa = m ; } } Esse exemplo aloca no Heap tr\u00eas endere\u00e7os em locais diferentes para cada objeto criado do tipo corpoCeleste, por\u00e9m a vari\u00e1vel pi , que \u00e9 est\u00e1tica \u00e9 comum a todos os objetos criados a partir da mesma classe. A figura a seguir ilustra como essas vari\u00e1veis seriam alocadas em mem\u00f3ria.","title":"HEAP"},{"location":"I-VM-Ferramental-Memoria/#this","text":"This \u00e9 o ponteiro que refer\u00eancia o pr\u00f3prio objeto: objeto na qual o m\u00e9todo ou construtor est\u00e1 sendo chamado. No caso da chamada do m\u00e9todo getMassa() da classe corpoCeleste, o ponteiro This ser\u00e1 ajustado para apontar para o objeto na qual o m\u00e9todo foi chamado. O fluxo da m\u00e1quina virtual ser\u00e1 o seguinte : Ajusta o this para apontar para o in\u00edcio do HEAP pertencente ao objeto chama a fun\u00e7\u00e3o getMassa do arquivo corpoCeleste.vm","title":"This"},{"location":"I-VM-Ferramental-Memoria/#that","text":"O ponteiro That \u00e9 utilizado para referenciar outro objeto, utilizado no exemplo a seguir: M\u00e9todo objeto Celeste: void compareMassa ( corpoCeleste outro ){ if ( this . massa == outro . massa ){ return ( True ); } else { return ( False ); } } C\u00f3digo principal: void main (){ ... rtn = terra . compareMassa ( lua ); } Nesse exemplo, inclu\u00edmos um novo m\u00e9todo (compareMass) na classe corpoCeleste, esse novo m\u00e9todo compara a massa de um outro objeto com a do pr\u00f3prio objeto, retornando verdadeiro ou falso dependendo do resultado. Como esse c\u00f3digo seria traduzido para VM? O objeto em quest\u00e3o ser\u00e1 acessado utilizando o ponteiro this e o objeto a ser comparado ser\u00e1 acessado via o that . O compilador da linguagem de alto n\u00edvel para VM ser\u00e1 respons\u00e1vel por alocar os objetos nos endere\u00e7os certos. function main 0 ... push constant 2048 // endere\u00e7o objeto terra push constant 2051 // endere\u00e7o objeto lua call cortpoCeleste.compare mass 2 function corpoCeleste.compareMass 0 push argument 0 pop pointer 0 // atualiza endere\u00e7o this push argument 1 pop pointer 1 // atualiza endere\u00e7o that push this 2 // this 0 = gravidade; this 1 = raio; this 2 = massa push that 2 // that 0 = gravidade; this 1 = raio; this 2 = massa eq return Note que quando o m\u00e9todo for chamado (no caso da vm o m\u00e9todo ser\u00e1 traduzido para uma fun\u00e7\u00e3o), os ponteiros this e that devem ser passados via a chama da fun\u00e7\u00e3o, e no come\u00e7o da fun\u00e7\u00e3o atualizado os endere\u00e7os RAM[3] - This e RAM[4] - That.","title":"That"},{"location":"I-VM-Lab-1/","text":"Descri\u00e7\u00e3o \u00b6 Nesse lab iremos criar programas em VM para o nosso Z01.1, essa entrega \u00e9 individual e n\u00e3o vale nota, mas ser\u00e1 cobrado em prova e servir\u00e1 para voc\u00eas entenderem o pr\u00f3ximo projeto: F-VMTranslator . M\u00f3dulos a serem implementados \u00b6 Os m\u00f3dulos est\u00e3o na pasta Projetos/I-VM/src/vm/ e est\u00e3o organizados por ordem de dificuldade: 1a-Add 1b-Add 2a-Calculadora 1c-Dic 2b-Calculadora 2c-Calculadora 2d-Calculadora Para testar, basta editar o arquivo tests/config.txt com os m\u00f3dulos que deseja executar e ent\u00e3o executar o script: testeVM.py localizado na pasta do projeto. Exemplos \u00b6 Existem diversos exemplos de programas escritos em linguagem VM, eles est\u00e3o na pasta src/vmExamples/ Linguagem VM \u00b6 A linguagem VM proposta para o curso \u00e9 baseada em pilha (assim como tantas outras), as opera\u00e7\u00f5es nesse n\u00edvel n\u00e3o mais lidam com registradores do computador mas sim com dados que s\u00e3o colocados e tirados de uma pilha (stack). Uma grande vantagem disso \u00e9 a abstra\u00e7\u00e3o do hardware, agora n\u00e3o precisamos mais nos preocuparmos com a manipula\u00e7\u00e3o dos dados em baixo n\u00edvel (o VMTranslator ser\u00e1 encarregado disso). Um c\u00f3digo escrito em VM passa pelas seguintes etapas antes de ser executado em m\u00e1quina : VMTranslator Assembler .vm -------------> .nasm -------------> .hack O c\u00f3digo vm \u00e9 traduzido para linguagem nasm pelo VMTranslator (voc\u00eas v\u00e3o ter que fazer esse programa), e ent\u00e3o \u00e9 montado pelo Assembler para linguagem de m\u00e1quina. Temos diversas vantagens quando programamos em linguagem virtual : a. Abstra\u00e7\u00e3o de Hardware - (j\u00e1 n\u00e3o mais lidamos com o hardware diretamente) c. Portabilidade b. C\u00f3digo mais alto n\u00edvel - (chamada de fun\u00e7\u00f5es, linguagem mais pr\u00f3xima do que estamos acostumados, ...) Pilha \u00b6 A linguagem VM \u00e9 baseada em pilha, ou seja, todas as opera\u00e7\u00f5es que ser\u00e3o realizadas ser\u00e3o feitas na pilha. A pilha \u00e9 uma regi\u00e3o da mem\u00f3ria RAM (come\u00e7ando no endere\u00e7o 256) reservada para armazenar os dados que est\u00e3o sendo manipulados. A pilha cresce conforme opera\u00e7\u00f5es de push (envio de dados para a pilha) v\u00e3o sendo executados, e decresce conforme opera\u00e7\u00f5es de pull (retirar dados da pilha) s\u00e3o executadas. Stack Pointer (SP) \u00b6 O Stack Pointer \u00e9 o endere\u00e7o de mem\u00f3ria (RAM[0]) reservado por apontar o topo da pilha, ou seja, a pr\u00f3xima posi\u00e7\u00e3o vazia da pilha. O SP \u00e9 salvo na RAM 0 (R0), e deve ser incrementado/decrementado conforme a pilha vai sendo manipulada. Opera\u00e7\u00e3o \u00b6 Considerando a seguinte disposi\u00e7\u00e3o na pilha : ... ... X Y SP -> S\u00e3o suportadas as seguintes opera\u00e7\u00f5es aritm\u00e9ticas na pilha: add executa: X + Y sub executa: X - Y neg executa: - Y - Y (complemento de dois) eq compara X == Y True : resulta em b\"11111111111111111\", 0xFFFF False: resulta em b\"0000000000000000\"\", 0x0000 gt compara X > Y True : resulta em b\"11111111111111111\", 0xFFFF False: resulta em b\"0000000000000000\"\", 0x0000 lt compara X < Y True : resulta em b\"11111111111111111\", 0xFFFF False: resulta em b\"0000000000000000\"\", 0x0000 and executa: X and Y (bit a bit) or executa: X or Y (bit a bit) not executa: not Y (bit a bit) Note que as opera\u00e7\u00f5es de compara\u00e7\u00e3o (eq, gt, lt) resulta em um True e False e esse resultado \u00e9 salvo na pilha, considere o exemplo a seguir (em hexa) que possui inicialmente na pilha os valores 2 3 e 5, e ap\u00f3s a opera\u00e7\u00e3o de eq os valores 3 e 5 s\u00e3o comparados e resulta em um valor True ou False (0xFFFF ou 0x0000). -> eq -> -> gt -> 0x2 0x2 0xFFFF 0x3 0x0 SP-> 0x5 SP-> SP-> As opera\u00e7\u00f5es na pilha n\u00e3o apagam o resultado que j\u00e1 estava na pilha, se olharmos a mem\u00f3ria real do exemplo anterior seria a seguinte: -> eq -> -> gt -> 0x2 0x2 0xFFFF 0x3 0x0 SP-> 0x0 0x5 SP-> 0x5 0x5 SP-> 0x0 0x0 0x0 O mesmo acontece com arquivos que s\u00e3o deletados do seu computador, o sistema operacional n\u00e3o \"limpa a mem\u00f3ria\" sempre que um arquivo \u00e9 exclu\u00eddo, apenas apaga o ponteiro para aquele arquivo. Acesso a mem\u00f3ria \u00b6 Os comandos push e pop s\u00e3o a \u00fanica maneira que temos de acessar/manipular a mem\u00f3ria. O comando push traz para a pilha um valor da mem\u00f3ria (RAM ou ROM) e o comando pop salva na mem\u00f3ria um valor da pila (RAM). Os comandos possuem a seguinte sintaxe : push segment index pop segment index Onde index \u00e9 um n\u00famero inteiro positivo e segment pode ser um dos casos a seguir: segment Uso Index Coment\u00e1rio argument Local onde o argumento da fun\u00e7\u00e3o est\u00e1 salvo 0 .. Alocado dinamicamente pelo VMTranslator quando a fun\u00e7\u00e3o \u00e9 chamada local Local das vari\u00e1veis locais da fun\u00e7\u00e3o 0 .. Alocado dinamicamente pelo VMTranslator quando a fun\u00e7\u00e3o \u00e9 chamada static Local onde as vari\u00e1veis do objeto est\u00e3o salvos 0 .. Essas vari\u00e1veis s\u00e3o compartilhadas por todas as fun\u00e7\u00f5es do mesmo .vm, assim como em um objeto constant Carrega uma constante na pilha 0 .. 32767 Mesmo uso do leaw (carrega da ROM um valor na RAM) this/that Segmentos de uso geral, pode apontar para qualquer lugar 0 .. Usado para ler e escrever de endere\u00e7os da mem\u00f3ria, por exemplo, acessar o LCD pointer Altera os valores do this e do that 0, 1 Usado para modificar a onde o this e o that apontam temp Local para uso de vari\u00e1veis tempor\u00e1rias 0 .. 7 Acessado por qualquer fun\u00e7\u00e3o, \u00e9 armazenado nos endere\u00e7os R5 .. R12 da RAM Exemplo, acessando o temp \u00b6 Por exemplo, para trazermos para a pilha uma constante realizamos a seguinte opera\u00e7\u00e3o: push constant 15 nesse caso o segmento acessado \u00e9 o constant e o par\u00e2metro \u00e9 o 15. Para salvarmos o valor 15 no temp 3 (endere\u00e7o da RAM 7), basta: push constant 15 pop temp 3 Podemos tamb\u00e9m trazer o temp 3 para a pilha: push temp 3 PROGRAMANDO \u00b6 Implemente os programas a seguir e teste com testeVm.py . Projetos/I-VM/src/vm/1a-Add Projetos/I-VM/src/vm/1b-Add Projetos/I-VM/src/vm/2a-Calculadora Antes de Continuar S\u00f3 Continue ap\u00f3s implementar e testar todos os programas! Escrevendo um pixel no LCD \u00b6 Para atualizarmos o LCD via VM ser\u00e1 necess\u00e1rio primeiro atualizarmos para onde o that aponta, that \u00e9 a maneira que possu\u00edmos de escrever em qualquer endere\u00e7o da mem\u00f3ria. O exemplo a seguir ilustra como usamos o segmento that para escrever nos pixels centrais do LCD, supondo que gostar\u00edamos de realizar a seguinte opera\u00e7\u00e3o em C. int * pLCD = 16384 * ( pLCD + 1200 ) = 0xFFFF Nesse pequeno c\u00f3digo em C o que est\u00e1 acontecendo \u00e9 que primeiramente definimos um ponteiro pLCD que aponta para 16384, depois fazemos com que o endere\u00e7o desse ponteiro + 1200 receba 0xFFFF, o mesmo c\u00f3digo em VM \u00e9 realizado da seguinte maneira : push constant 16384 -- carrega 16384 para a pilha pop pointer 1 -- atualiza para onde that aponta (int *pLCD = 16384) push contant 1 -- carrega 1 para a pilha neg -- nega o 1 para obter o valor 0xFFFF -- poderia ter realizado o push contant 4095 no lugar -- dessas duas opera\u00e7\u00f5es pop that 1200 -- faz com que o endere\u00e7o da mem\u00f3ria 16384 + 1200 = 0xFFFF GOTO \u00b6 Goto \u00e9 a maneira de desviarmos uma execu\u00e7\u00e3o em .vm, e possui a seguinte sintaxe: goto LABEL if-goto LABEL podemos utilizar dois tipos : goto : incondicional , salta sem condi\u00e7\u00e3o if-goto : condiconal, salta se o \u00faltimo valor da pilha for True Exemplo: Salto para igual se 3 = 2 push constant 3 push constant 2 eq if-goto IGUAL .. .. label IGUAL .. .. Exemplo: Contador utilizando for utilizando goto // for(i=0; i<10; i++) // x = x+1; push constant 0 pop temp 0 push constant 1 pop temp 1 label LOOP_START push temp 0 push constant 10 eq if-goto END // se temp0 = 10 salta para o fim push temp 0 push constant 1 add pop temp 0 push temp 1 push temp 1 add pop temp 1 goto LOOP_START // If counter > 0, goto LOOP_START label END labels \u00b6 Os labels s\u00e3o definidos pela keyword label + nome : label nome PROGRAMANDO \u00b6 Implemente os programas a seguir e teste com testeVm.py . Projetos/I-VM/src/vm/1c-div Antes de Continuar S\u00f3 Continue ap\u00f3s implementar e testar todos o programa! Fun\u00e7\u00f5es \u00b6 A linguagem VM possibilita o uso de fun\u00e7\u00f5es, as fun\u00e7\u00f5es s\u00e3o definidas em novos arquivos .vm na mesma pasta do arquivo Main.vm. Por exemplo : Nesse projeto SimpleFunction possu\u00edmos duas fun\u00e7\u00f5es : O Main.vm e a SimpleFunction.vm . A fun\u00e7\u00e3o main deve sempre existir no projeto, e ser\u00e1 a primeira chamada na inicializa\u00e7\u00e3o do sistema (assim como no python e C). Para definirmos uma fun\u00e7\u00e3o em VM basta criarmos um arquivo com a extens\u00e3o .vm (que precisa ter o mesmo nome da fun\u00e7\u00e3o) que ser\u00e1 como uma classe do nosso projeto, podendo conter mais que um m\u00e9todo/fun\u00e7\u00e3o. Note Olhe o exemplo src/vmExamples/StatiTest/ para ver como isso funciona. Uma fun\u00e7\u00e3o \u00e9 definida pela seguinte estrutura : function functionName numberOfVars Onde : function: \u00e9 uma palavra reservado (keyword) para definir fun\u00e7\u00f5es functionName: \u00e9 o nome da fun\u00e7\u00e3o numberOfVars: a quantidade de vari\u00e1veis locais que essa fun\u00e7\u00e3o possui. Como exemplo, vamos transformar a seguinte fun\u00e7\u00e3o em python para vm : def SimpleFunction ( a , b ): aux0 = a + b aux1 = a - b return ( aux1 + aux0 ) Em vm: function SimpleFunction 2 push argument 0 push argument 1 add pop local 0 // aux0 = a + b push argument 0 push argument 1 sub pop local 1 // aux1 = a - b push local 0 push local 1 add // aux0 + aux1 return Essa fun\u00e7\u00e3o possui duas vari\u00e1veis locais, que pode ser acessada pelo segmento local , os par\u00e2metros passados para a fun\u00e7\u00e3o (a e b) s\u00e3o acess\u00edveis pelo segmento argument : push argument 0 acessa o primeiro argumento da fun\u00e7\u00e3o ( a ), trazendo o dado para a pilha. push argument 1 acessa o primeiro argumento da fun\u00e7\u00e3o ( b ), trazendo o dado para a pilha. push/pop temp 0 acessa ou grava na primeiro vari\u00e1vel local da fun\u00e7\u00e3o ( aux0 ). push/pop temp 1 acessa ou grava na primeiro vari\u00e1vel local da fun\u00e7\u00e3o ( aux1 ). Note que os par\u00e2metros devem ser apenas leitura, n\u00e3o devendo escrever nesses segmentos. return \u00b6 A fun\u00e7\u00e3o considera como retorno o \u00faltimo valor da pilha, e sempre retorna um \u00fanico Chamada de fun\u00e7\u00e3o \u00b6 A chamada de fun\u00e7\u00e3o ocorre na pr\u00f3pria pilha, para isso \u00e9 necess\u00e1rio colocar na pilha os par\u00e2metros da fun\u00e7\u00e3o, no exemplo anterior : a b SP-> e em seguida fazer a chamada de fun\u00e7\u00e3o que possui a seguinte estrutura: call functionName numberOfParameters Onde : call : palavra reservada para chamada de fun\u00e7\u00f5es functioName : nome da fun\u00e7\u00e3o a ser chamada numberOfPar : quantidade de par\u00e2metros que essa fun\u00e7\u00e3o recebe. O exemplo a seguir chama a fun\u00e7\u00e3o SimpleFunction com os valores 5 e 8 function Main.main 0 push constant 5 push constant 8 call SimpleFunction 2 Graficamente \u00b6 PROGRAMANDO \u00b6 Implemente os programas a seguir e teste com testeVm.py . Projetos/I-VM/src/vm/2b-Calculadora Projetos/I-VM/src/vm/2c-Calculadora Projetos/I-VM/src/vm/2d-Calculadora Antes de continuar Escreva os programas e teste.","title":"Descri\u00e7\u00e3o"},{"location":"I-VM-Lab-1/#descricao","text":"Nesse lab iremos criar programas em VM para o nosso Z01.1, essa entrega \u00e9 individual e n\u00e3o vale nota, mas ser\u00e1 cobrado em prova e servir\u00e1 para voc\u00eas entenderem o pr\u00f3ximo projeto: F-VMTranslator .","title":"Descri\u00e7\u00e3o"},{"location":"I-VM-Lab-1/#modulos-a-serem-implementados","text":"Os m\u00f3dulos est\u00e3o na pasta Projetos/I-VM/src/vm/ e est\u00e3o organizados por ordem de dificuldade: 1a-Add 1b-Add 2a-Calculadora 1c-Dic 2b-Calculadora 2c-Calculadora 2d-Calculadora Para testar, basta editar o arquivo tests/config.txt com os m\u00f3dulos que deseja executar e ent\u00e3o executar o script: testeVM.py localizado na pasta do projeto.","title":"M\u00f3dulos a serem implementados"},{"location":"I-VM-Lab-1/#exemplos","text":"Existem diversos exemplos de programas escritos em linguagem VM, eles est\u00e3o na pasta src/vmExamples/","title":"Exemplos"},{"location":"I-VM-Lab-1/#linguagem-vm","text":"A linguagem VM proposta para o curso \u00e9 baseada em pilha (assim como tantas outras), as opera\u00e7\u00f5es nesse n\u00edvel n\u00e3o mais lidam com registradores do computador mas sim com dados que s\u00e3o colocados e tirados de uma pilha (stack). Uma grande vantagem disso \u00e9 a abstra\u00e7\u00e3o do hardware, agora n\u00e3o precisamos mais nos preocuparmos com a manipula\u00e7\u00e3o dos dados em baixo n\u00edvel (o VMTranslator ser\u00e1 encarregado disso). Um c\u00f3digo escrito em VM passa pelas seguintes etapas antes de ser executado em m\u00e1quina : VMTranslator Assembler .vm -------------> .nasm -------------> .hack O c\u00f3digo vm \u00e9 traduzido para linguagem nasm pelo VMTranslator (voc\u00eas v\u00e3o ter que fazer esse programa), e ent\u00e3o \u00e9 montado pelo Assembler para linguagem de m\u00e1quina. Temos diversas vantagens quando programamos em linguagem virtual : a. Abstra\u00e7\u00e3o de Hardware - (j\u00e1 n\u00e3o mais lidamos com o hardware diretamente) c. Portabilidade b. C\u00f3digo mais alto n\u00edvel - (chamada de fun\u00e7\u00f5es, linguagem mais pr\u00f3xima do que estamos acostumados, ...)","title":"Linguagem VM"},{"location":"I-VM-Lab-1/#pilha","text":"A linguagem VM \u00e9 baseada em pilha, ou seja, todas as opera\u00e7\u00f5es que ser\u00e3o realizadas ser\u00e3o feitas na pilha. A pilha \u00e9 uma regi\u00e3o da mem\u00f3ria RAM (come\u00e7ando no endere\u00e7o 256) reservada para armazenar os dados que est\u00e3o sendo manipulados. A pilha cresce conforme opera\u00e7\u00f5es de push (envio de dados para a pilha) v\u00e3o sendo executados, e decresce conforme opera\u00e7\u00f5es de pull (retirar dados da pilha) s\u00e3o executadas.","title":"Pilha"},{"location":"I-VM-Lab-1/#stack-pointer-sp","text":"O Stack Pointer \u00e9 o endere\u00e7o de mem\u00f3ria (RAM[0]) reservado por apontar o topo da pilha, ou seja, a pr\u00f3xima posi\u00e7\u00e3o vazia da pilha. O SP \u00e9 salvo na RAM 0 (R0), e deve ser incrementado/decrementado conforme a pilha vai sendo manipulada.","title":"Stack Pointer (SP)"},{"location":"I-VM-Lab-1/#operacao","text":"Considerando a seguinte disposi\u00e7\u00e3o na pilha : ... ... X Y SP -> S\u00e3o suportadas as seguintes opera\u00e7\u00f5es aritm\u00e9ticas na pilha: add executa: X + Y sub executa: X - Y neg executa: - Y - Y (complemento de dois) eq compara X == Y True : resulta em b\"11111111111111111\", 0xFFFF False: resulta em b\"0000000000000000\"\", 0x0000 gt compara X > Y True : resulta em b\"11111111111111111\", 0xFFFF False: resulta em b\"0000000000000000\"\", 0x0000 lt compara X < Y True : resulta em b\"11111111111111111\", 0xFFFF False: resulta em b\"0000000000000000\"\", 0x0000 and executa: X and Y (bit a bit) or executa: X or Y (bit a bit) not executa: not Y (bit a bit) Note que as opera\u00e7\u00f5es de compara\u00e7\u00e3o (eq, gt, lt) resulta em um True e False e esse resultado \u00e9 salvo na pilha, considere o exemplo a seguir (em hexa) que possui inicialmente na pilha os valores 2 3 e 5, e ap\u00f3s a opera\u00e7\u00e3o de eq os valores 3 e 5 s\u00e3o comparados e resulta em um valor True ou False (0xFFFF ou 0x0000). -> eq -> -> gt -> 0x2 0x2 0xFFFF 0x3 0x0 SP-> 0x5 SP-> SP-> As opera\u00e7\u00f5es na pilha n\u00e3o apagam o resultado que j\u00e1 estava na pilha, se olharmos a mem\u00f3ria real do exemplo anterior seria a seguinte: -> eq -> -> gt -> 0x2 0x2 0xFFFF 0x3 0x0 SP-> 0x0 0x5 SP-> 0x5 0x5 SP-> 0x0 0x0 0x0 O mesmo acontece com arquivos que s\u00e3o deletados do seu computador, o sistema operacional n\u00e3o \"limpa a mem\u00f3ria\" sempre que um arquivo \u00e9 exclu\u00eddo, apenas apaga o ponteiro para aquele arquivo.","title":"Opera\u00e7\u00e3o"},{"location":"I-VM-Lab-1/#acesso-a-memoria","text":"Os comandos push e pop s\u00e3o a \u00fanica maneira que temos de acessar/manipular a mem\u00f3ria. O comando push traz para a pilha um valor da mem\u00f3ria (RAM ou ROM) e o comando pop salva na mem\u00f3ria um valor da pila (RAM). Os comandos possuem a seguinte sintaxe : push segment index pop segment index Onde index \u00e9 um n\u00famero inteiro positivo e segment pode ser um dos casos a seguir: segment Uso Index Coment\u00e1rio argument Local onde o argumento da fun\u00e7\u00e3o est\u00e1 salvo 0 .. Alocado dinamicamente pelo VMTranslator quando a fun\u00e7\u00e3o \u00e9 chamada local Local das vari\u00e1veis locais da fun\u00e7\u00e3o 0 .. Alocado dinamicamente pelo VMTranslator quando a fun\u00e7\u00e3o \u00e9 chamada static Local onde as vari\u00e1veis do objeto est\u00e3o salvos 0 .. Essas vari\u00e1veis s\u00e3o compartilhadas por todas as fun\u00e7\u00f5es do mesmo .vm, assim como em um objeto constant Carrega uma constante na pilha 0 .. 32767 Mesmo uso do leaw (carrega da ROM um valor na RAM) this/that Segmentos de uso geral, pode apontar para qualquer lugar 0 .. Usado para ler e escrever de endere\u00e7os da mem\u00f3ria, por exemplo, acessar o LCD pointer Altera os valores do this e do that 0, 1 Usado para modificar a onde o this e o that apontam temp Local para uso de vari\u00e1veis tempor\u00e1rias 0 .. 7 Acessado por qualquer fun\u00e7\u00e3o, \u00e9 armazenado nos endere\u00e7os R5 .. R12 da RAM","title":"Acesso a mem\u00f3ria"},{"location":"I-VM-Lab-1/#exemplo-acessando-o-temp","text":"Por exemplo, para trazermos para a pilha uma constante realizamos a seguinte opera\u00e7\u00e3o: push constant 15 nesse caso o segmento acessado \u00e9 o constant e o par\u00e2metro \u00e9 o 15. Para salvarmos o valor 15 no temp 3 (endere\u00e7o da RAM 7), basta: push constant 15 pop temp 3 Podemos tamb\u00e9m trazer o temp 3 para a pilha: push temp 3","title":"Exemplo, acessando o temp"},{"location":"I-VM-Lab-1/#programando","text":"Implemente os programas a seguir e teste com testeVm.py . Projetos/I-VM/src/vm/1a-Add Projetos/I-VM/src/vm/1b-Add Projetos/I-VM/src/vm/2a-Calculadora Antes de Continuar S\u00f3 Continue ap\u00f3s implementar e testar todos os programas!","title":"PROGRAMANDO"},{"location":"I-VM-Lab-1/#escrevendo-um-pixel-no-lcd","text":"Para atualizarmos o LCD via VM ser\u00e1 necess\u00e1rio primeiro atualizarmos para onde o that aponta, that \u00e9 a maneira que possu\u00edmos de escrever em qualquer endere\u00e7o da mem\u00f3ria. O exemplo a seguir ilustra como usamos o segmento that para escrever nos pixels centrais do LCD, supondo que gostar\u00edamos de realizar a seguinte opera\u00e7\u00e3o em C. int * pLCD = 16384 * ( pLCD + 1200 ) = 0xFFFF Nesse pequeno c\u00f3digo em C o que est\u00e1 acontecendo \u00e9 que primeiramente definimos um ponteiro pLCD que aponta para 16384, depois fazemos com que o endere\u00e7o desse ponteiro + 1200 receba 0xFFFF, o mesmo c\u00f3digo em VM \u00e9 realizado da seguinte maneira : push constant 16384 -- carrega 16384 para a pilha pop pointer 1 -- atualiza para onde that aponta (int *pLCD = 16384) push contant 1 -- carrega 1 para a pilha neg -- nega o 1 para obter o valor 0xFFFF -- poderia ter realizado o push contant 4095 no lugar -- dessas duas opera\u00e7\u00f5es pop that 1200 -- faz com que o endere\u00e7o da mem\u00f3ria 16384 + 1200 = 0xFFFF","title":"Escrevendo um pixel no LCD"},{"location":"I-VM-Lab-1/#goto","text":"Goto \u00e9 a maneira de desviarmos uma execu\u00e7\u00e3o em .vm, e possui a seguinte sintaxe: goto LABEL if-goto LABEL podemos utilizar dois tipos : goto : incondicional , salta sem condi\u00e7\u00e3o if-goto : condiconal, salta se o \u00faltimo valor da pilha for True Exemplo: Salto para igual se 3 = 2 push constant 3 push constant 2 eq if-goto IGUAL .. .. label IGUAL .. .. Exemplo: Contador utilizando for utilizando goto // for(i=0; i<10; i++) // x = x+1; push constant 0 pop temp 0 push constant 1 pop temp 1 label LOOP_START push temp 0 push constant 10 eq if-goto END // se temp0 = 10 salta para o fim push temp 0 push constant 1 add pop temp 0 push temp 1 push temp 1 add pop temp 1 goto LOOP_START // If counter > 0, goto LOOP_START label END","title":"GOTO"},{"location":"I-VM-Lab-1/#labels","text":"Os labels s\u00e3o definidos pela keyword label + nome : label nome","title":"labels"},{"location":"I-VM-Lab-1/#programando_1","text":"Implemente os programas a seguir e teste com testeVm.py . Projetos/I-VM/src/vm/1c-div Antes de Continuar S\u00f3 Continue ap\u00f3s implementar e testar todos o programa!","title":"PROGRAMANDO"},{"location":"I-VM-Lab-1/#funcoes","text":"A linguagem VM possibilita o uso de fun\u00e7\u00f5es, as fun\u00e7\u00f5es s\u00e3o definidas em novos arquivos .vm na mesma pasta do arquivo Main.vm. Por exemplo : Nesse projeto SimpleFunction possu\u00edmos duas fun\u00e7\u00f5es : O Main.vm e a SimpleFunction.vm . A fun\u00e7\u00e3o main deve sempre existir no projeto, e ser\u00e1 a primeira chamada na inicializa\u00e7\u00e3o do sistema (assim como no python e C). Para definirmos uma fun\u00e7\u00e3o em VM basta criarmos um arquivo com a extens\u00e3o .vm (que precisa ter o mesmo nome da fun\u00e7\u00e3o) que ser\u00e1 como uma classe do nosso projeto, podendo conter mais que um m\u00e9todo/fun\u00e7\u00e3o. Note Olhe o exemplo src/vmExamples/StatiTest/ para ver como isso funciona. Uma fun\u00e7\u00e3o \u00e9 definida pela seguinte estrutura : function functionName numberOfVars Onde : function: \u00e9 uma palavra reservado (keyword) para definir fun\u00e7\u00f5es functionName: \u00e9 o nome da fun\u00e7\u00e3o numberOfVars: a quantidade de vari\u00e1veis locais que essa fun\u00e7\u00e3o possui. Como exemplo, vamos transformar a seguinte fun\u00e7\u00e3o em python para vm : def SimpleFunction ( a , b ): aux0 = a + b aux1 = a - b return ( aux1 + aux0 ) Em vm: function SimpleFunction 2 push argument 0 push argument 1 add pop local 0 // aux0 = a + b push argument 0 push argument 1 sub pop local 1 // aux1 = a - b push local 0 push local 1 add // aux0 + aux1 return Essa fun\u00e7\u00e3o possui duas vari\u00e1veis locais, que pode ser acessada pelo segmento local , os par\u00e2metros passados para a fun\u00e7\u00e3o (a e b) s\u00e3o acess\u00edveis pelo segmento argument : push argument 0 acessa o primeiro argumento da fun\u00e7\u00e3o ( a ), trazendo o dado para a pilha. push argument 1 acessa o primeiro argumento da fun\u00e7\u00e3o ( b ), trazendo o dado para a pilha. push/pop temp 0 acessa ou grava na primeiro vari\u00e1vel local da fun\u00e7\u00e3o ( aux0 ). push/pop temp 1 acessa ou grava na primeiro vari\u00e1vel local da fun\u00e7\u00e3o ( aux1 ). Note que os par\u00e2metros devem ser apenas leitura, n\u00e3o devendo escrever nesses segmentos.","title":"Fun\u00e7\u00f5es"},{"location":"I-VM-Lab-1/#return","text":"A fun\u00e7\u00e3o considera como retorno o \u00faltimo valor da pilha, e sempre retorna um \u00fanico","title":"return"},{"location":"I-VM-Lab-1/#chamada-de-funcao","text":"A chamada de fun\u00e7\u00e3o ocorre na pr\u00f3pria pilha, para isso \u00e9 necess\u00e1rio colocar na pilha os par\u00e2metros da fun\u00e7\u00e3o, no exemplo anterior : a b SP-> e em seguida fazer a chamada de fun\u00e7\u00e3o que possui a seguinte estrutura: call functionName numberOfParameters Onde : call : palavra reservada para chamada de fun\u00e7\u00f5es functioName : nome da fun\u00e7\u00e3o a ser chamada numberOfPar : quantidade de par\u00e2metros que essa fun\u00e7\u00e3o recebe. O exemplo a seguir chama a fun\u00e7\u00e3o SimpleFunction com os valores 5 e 8 function Main.main 0 push constant 5 push constant 8 call SimpleFunction 2","title":"Chamada de fun\u00e7\u00e3o"},{"location":"I-VM-Lab-1/#graficamente","text":"","title":"Graficamente"},{"location":"I-VM-Lab-1/#programando_2","text":"Implemente os programas a seguir e teste com testeVm.py . Projetos/I-VM/src/vm/2b-Calculadora Projetos/I-VM/src/vm/2c-Calculadora Projetos/I-VM/src/vm/2d-Calculadora Antes de continuar Escreva os programas e teste.","title":"PROGRAMANDO"},{"location":"I-VM-Projeto/","text":"I - VM \u00b6 Nesse projeto iremos criar programas em VM para o nosso Z01.1, essa entrega \u00e9 individual e n\u00e3o vale nota, mas ser\u00e1 cobrado em prova e servir\u00e1 para voc\u00eas entenderem o pr\u00f3ximo projeto: F-VMTranslator . Instru\u00e7\u00f5es \u00b6 As instru\u00e7\u00f5es t\u00e9cnicas referente ao projeto est\u00e3o no laborat\u00f3rio I-VM-Lab-1 . M\u00f3dulos a serem implementados \u00b6 Os m\u00f3dulos est\u00e3o na pasta Projetos/I-VM/src/vm/ e est\u00e3o organizados por ordem de dificuldade: 1a-Add 1b-Add 1c-Dic 2a-Calculadora 2b-Calculadora 2c-Calculadora 2d-Calculadora Para testar, basta editar o arquivo tests/config.txt com os m\u00f3dulos que deseja executar e ent\u00e3o executar o script: testeVM.py localizado na pasta do projeto. Exemplos \u00b6 Existem diversos exemplos de programas escritos em linguagem VM, eles est\u00e3o na pasta src/vmExamples/","title":"I - VM"},{"location":"I-VM-Projeto/#i-vm","text":"Nesse projeto iremos criar programas em VM para o nosso Z01.1, essa entrega \u00e9 individual e n\u00e3o vale nota, mas ser\u00e1 cobrado em prova e servir\u00e1 para voc\u00eas entenderem o pr\u00f3ximo projeto: F-VMTranslator .","title":"I - VM"},{"location":"I-VM-Projeto/#instrucoes","text":"As instru\u00e7\u00f5es t\u00e9cnicas referente ao projeto est\u00e3o no laborat\u00f3rio I-VM-Lab-1 .","title":"Instru\u00e7\u00f5es"},{"location":"I-VM-Projeto/#modulos-a-serem-implementados","text":"Os m\u00f3dulos est\u00e3o na pasta Projetos/I-VM/src/vm/ e est\u00e3o organizados por ordem de dificuldade: 1a-Add 1b-Add 1c-Dic 2a-Calculadora 2b-Calculadora 2c-Calculadora 2d-Calculadora Para testar, basta editar o arquivo tests/config.txt com os m\u00f3dulos que deseja executar e ent\u00e3o executar o script: testeVM.py localizado na pasta do projeto.","title":"M\u00f3dulos a serem implementados"},{"location":"I-VM-Projeto/#exemplos","text":"Existem diversos exemplos de programas escritos em linguagem VM, eles est\u00e3o na pasta src/vmExamples/","title":"Exemplos"},{"location":"J-VMtranslator-Lab-1/","text":"Vm Translator \u00b6 O VMTranslator \u00e9 um programa escrito em Java que faz a tradu\u00e7\u00e3o de c\u00f3digos escrito na linguagem VM definida no curso e traduz para linguagem Assembly do computador Z01. Testando \u00b6 Para testar, basta executar os dois comandos: $. /genJar.py $ ./testeVMtraslator.py O teste executa: genJAR.py | | V VMTranslator Assembler Z01-Simulator ------------------ arquivo.vm -------------> .nasm -----------> .hack > ------------> - Verifica sa\u00edda - ------------------ ^ | |- Desenvolvido no projeto J Traduzir o arquivo .vm -> .nasm Para isso foi criado alguns programas ( I-VM/src/vmExamples/ ) em VM muito espec\u00edficos que testam somente um comando, ou uma parte da tradu\u00e7\u00e3o do VMTranslator . Por exemplo o teste SimpleAdd possui somente a seguinte linha : add Esse teste foi criado para testar o Code.writeArithmetic no caso de um comando add . Para isso, antes da execu\u00e7\u00e3o desse c\u00f3digo, o simulador faz a inicializa\u00e7\u00e3o da RAM, simulando valores na pilha e j\u00e1 configurando o SP para uma situa\u00e7\u00e3o real. A mem\u00f3ria antes da execu\u00e7\u00e3o da instru\u00e7\u00e3o add \u00e9 a seguinte: 0 : 0000000100000010; 256 : 0000000000000010; 257 : 0000000000000100; 258 : 0000000000000000; Note I-VM/tests/tst/SimpleAdd/SimpleAdd0_in.mif Espera-se o resultado final ap\u00f3s a execu\u00e7\u00e3o do comando add : 0 : 0000000100000001 256 : 0000000000000110 teste: \u00b6 A seguir uma lista de como cada parte do VMTranslator \u00e9 testado: code.writePushPop \u00b6 pop SimplePopTemp : pop temp ... SimplePopLocal : pop local ... SimplePopThat : pop that ... SimplePopThis : pop this ... push SimplePushConst : push constant .... SimplePushTemp : push tempo .... SimplePushLocal : push local .... SimplePushArg : push argument ... SimplePushThis : push this ... SimplePushThat : push that ... code.writeArithmetic \u00b6 SimpleAdd : add SimpleNeg : neg SimpleSub : sub SimpleEq : eq SimpleGt : gt SimpleLt : lt SimpleAnd : and SimpleOr : or Implementando \u00b6 Vamos agora fazer a implementa\u00e7\u00e3o do comando push constant 3 no VMtranslator. Crie o projeto no IntelliJ da mesma maneira que do projeto H-Assembler o arquivo maven est\u00e1 na pasta J-VMTranslator/VMtranslator Nesse projeto voc\u00eas ter\u00e3o que mexer apenas no code.java , os demais m\u00f3dulos j\u00e1 est\u00e3o prontos (similar ao projeto do Assembler, temos nesse o parser , VMTranslator , ...). Editando o code.java \u00b6 No code.java encontre a implementa\u00e7\u00e3o do m\u00e9todo push , linha 119 public void writePushPop ( Parser . CommandType command , String segment , Integer index ) { ... ... ... else if ( command == Parser . CommandType . C_PUSH ) { commands . add ( String . format ( \"; %d - PUSH %s %d\" , lineCode ++ , segment , index )); if ( segment . equals ( \"constant\" )) { } Essa m\u00e9todo \u00e9 chamado sempre que um comando push/pop for ser interpretado, exemplo: push constant 3 command: C_PUSH segment: constant Index: 3 Precisamos agora traduzir a execu\u00e7\u00e3o desse comando em vm para nasm , seguindos os passos a seguir: Carregar o valor da constante em um registrador dispon\u00edvel Busca no StackPointer(SP) o endere\u00e7o da posi\u00e7\u00e3o vazia da stack Move o valor do Index (no caso 3) para essa posi\u00e7\u00e3o vazia Incrementa SP em um Exemplo de implementa\u00e7\u00e3o do segundo, deve se adicionar as instru\u00e7\u00f5es na lista de comandos commands . add ( \"leaw $SP,%A\" ); commands . add ( \"movw (%A),%A\" ); Para testar o projeto VMtranslator, n\u00e3o h\u00e1 testes unit\u00e1rios dispon\u00edveis, no entanto, podemos j\u00e1 realizar o teste de integra\u00e7\u00e3o direto (simula\u00e7\u00e3o), usando o testeVMtranslator.py . No caso do push constant , temos o teste SimplePushConst, bastando apenas habilitar este teste na config ( tests/config.txt ). Se observar o arquivo, ir\u00e1 perceber que existem diversos outros testes b\u00e1sicos, como SimplePushLocal , SimplePopLocal e outros ( lista ) que podem ser habilitados conforme forem implementado estes recursos no seu VMtranslator.","title":"Vm Translator"},{"location":"J-VMtranslator-Lab-1/#vm-translator","text":"O VMTranslator \u00e9 um programa escrito em Java que faz a tradu\u00e7\u00e3o de c\u00f3digos escrito na linguagem VM definida no curso e traduz para linguagem Assembly do computador Z01.","title":"Vm Translator"},{"location":"J-VMtranslator-Lab-1/#testando","text":"Para testar, basta executar os dois comandos: $. /genJar.py $ ./testeVMtraslator.py O teste executa: genJAR.py | | V VMTranslator Assembler Z01-Simulator ------------------ arquivo.vm -------------> .nasm -----------> .hack > ------------> - Verifica sa\u00edda - ------------------ ^ | |- Desenvolvido no projeto J Traduzir o arquivo .vm -> .nasm Para isso foi criado alguns programas ( I-VM/src/vmExamples/ ) em VM muito espec\u00edficos que testam somente um comando, ou uma parte da tradu\u00e7\u00e3o do VMTranslator . Por exemplo o teste SimpleAdd possui somente a seguinte linha : add Esse teste foi criado para testar o Code.writeArithmetic no caso de um comando add . Para isso, antes da execu\u00e7\u00e3o desse c\u00f3digo, o simulador faz a inicializa\u00e7\u00e3o da RAM, simulando valores na pilha e j\u00e1 configurando o SP para uma situa\u00e7\u00e3o real. A mem\u00f3ria antes da execu\u00e7\u00e3o da instru\u00e7\u00e3o add \u00e9 a seguinte: 0 : 0000000100000010; 256 : 0000000000000010; 257 : 0000000000000100; 258 : 0000000000000000; Note I-VM/tests/tst/SimpleAdd/SimpleAdd0_in.mif Espera-se o resultado final ap\u00f3s a execu\u00e7\u00e3o do comando add : 0 : 0000000100000001 256 : 0000000000000110","title":"Testando"},{"location":"J-VMtranslator-Lab-1/#teste","text":"A seguir uma lista de como cada parte do VMTranslator \u00e9 testado:","title":"teste:"},{"location":"J-VMtranslator-Lab-1/#codewritepushpop","text":"pop SimplePopTemp : pop temp ... SimplePopLocal : pop local ... SimplePopThat : pop that ... SimplePopThis : pop this ... push SimplePushConst : push constant .... SimplePushTemp : push tempo .... SimplePushLocal : push local .... SimplePushArg : push argument ... SimplePushThis : push this ... SimplePushThat : push that ...","title":"code.writePushPop"},{"location":"J-VMtranslator-Lab-1/#codewritearithmetic","text":"SimpleAdd : add SimpleNeg : neg SimpleSub : sub SimpleEq : eq SimpleGt : gt SimpleLt : lt SimpleAnd : and SimpleOr : or","title":"code.writeArithmetic"},{"location":"J-VMtranslator-Lab-1/#implementando","text":"Vamos agora fazer a implementa\u00e7\u00e3o do comando push constant 3 no VMtranslator. Crie o projeto no IntelliJ da mesma maneira que do projeto H-Assembler o arquivo maven est\u00e1 na pasta J-VMTranslator/VMtranslator Nesse projeto voc\u00eas ter\u00e3o que mexer apenas no code.java , os demais m\u00f3dulos j\u00e1 est\u00e3o prontos (similar ao projeto do Assembler, temos nesse o parser , VMTranslator , ...).","title":"Implementando"},{"location":"J-VMtranslator-Lab-1/#editando-o-codejava","text":"No code.java encontre a implementa\u00e7\u00e3o do m\u00e9todo push , linha 119 public void writePushPop ( Parser . CommandType command , String segment , Integer index ) { ... ... ... else if ( command == Parser . CommandType . C_PUSH ) { commands . add ( String . format ( \"; %d - PUSH %s %d\" , lineCode ++ , segment , index )); if ( segment . equals ( \"constant\" )) { } Essa m\u00e9todo \u00e9 chamado sempre que um comando push/pop for ser interpretado, exemplo: push constant 3 command: C_PUSH segment: constant Index: 3 Precisamos agora traduzir a execu\u00e7\u00e3o desse comando em vm para nasm , seguindos os passos a seguir: Carregar o valor da constante em um registrador dispon\u00edvel Busca no StackPointer(SP) o endere\u00e7o da posi\u00e7\u00e3o vazia da stack Move o valor do Index (no caso 3) para essa posi\u00e7\u00e3o vazia Incrementa SP em um Exemplo de implementa\u00e7\u00e3o do segundo, deve se adicionar as instru\u00e7\u00f5es na lista de comandos commands . add ( \"leaw $SP,%A\" ); commands . add ( \"movw (%A),%A\" ); Para testar o projeto VMtranslator, n\u00e3o h\u00e1 testes unit\u00e1rios dispon\u00edveis, no entanto, podemos j\u00e1 realizar o teste de integra\u00e7\u00e3o direto (simula\u00e7\u00e3o), usando o testeVMtranslator.py . No caso do push constant , temos o teste SimplePushConst, bastando apenas habilitar este teste na config ( tests/config.txt ). Se observar o arquivo, ir\u00e1 perceber que existem diversos outros testes b\u00e1sicos, como SimplePushLocal , SimplePopLocal e outros ( lista ) que podem ser habilitados conforme forem implementado estes recursos no seu VMtranslator.","title":"Editando o code.java"},{"location":"J-VMtranslator-Projeto/","text":"Nesse projeto iremos criar o programa VM translator que \u00e9 respons\u00e1vel por traduzir os c\u00f3digos escrito em linguagem VM de pilha para a linguagem assembly. Instru\u00e7\u00f5es \u00b6 As instru\u00e7\u00f5es t\u00e9cnicas referente ao projeto est\u00e3o no lab 17, parte 1 e parte 2 M\u00f3dulos a serem implementados \u00b6 Apenas o Code.java . O projeto no total possui 5 m\u00f3dulos, sendo que o m\u00f3dulo VMTranslator.java , VMtranslate.java , Parser.java e Error.java j\u00e1 est\u00e3o foram entregues implementados. Os m\u00f3dulos est\u00e3o listados de maneira Top - Down VMTranslator Arquivo : VMTranslator.java Descri\u00e7\u00e3o : Main do projeto. Recebe como par\u00e2metro o nome do arquivo .vm (ou diret\u00f3rio) e o nome do arquivo bin\u00e1rio assembly ( .nasm ) a ser escrito, passa essas informa\u00e7\u00f5es para a classe VMtranslate. Depend\u00eancias : VMtranslate.java VMtranslate Arquivo : VMtranslate.java Descri\u00e7\u00e3o : Classe respons\u00e1vel por criar o c\u00f3digo assembly, ela que efetivamente faz a varredura do arquivo .vm de entrada e escreve o arquivo .nasm de sa\u00edda, gerando a tradu\u00e7\u00e3o vm -> nasm. Depend\u00eancias : Code.java , Parser.java Code Arquivo : Code.java Descri\u00e7\u00e3o : Traduz comandos da linguagem vm para os comandos em nasm que a executam. Depend\u00eancias : None Parser Arquivo : Parser.java Descri\u00e7\u00e3o : Encapsula o c\u00f3digo de leitura. Carrega as instru\u00e7\u00f5es na linguagem vm, analisa, e oferece acesso as partes da instru\u00e7\u00e3o (campos e s\u00edmbolos). Al\u00e9m disso, remove todos os espa\u00e7os em branco e coment\u00e1rios. Depend\u00eancias : none Sugest\u00e3o de implementa\u00e7\u00e3o (partes) \u00b6 Sugerimos que o VMTranslator seja implementado em duas partes, a primeira implementa somente o Parser.java e opera\u00e7\u00f5es aritm\u00e9ticas e push/pop . A segunda parte faz a implementa\u00e7\u00e3o de fun\u00e7\u00f5es, goto e chamada de fun\u00e7\u00f5es. Parte 1 - Conceito C \u00b6 Code.writeArithmetic() Code.writePushPop() Parte 2 - Conceito B \u00b6 Code.writeGoto() Code.writeIf() Parte 3 - Conceito A Code.writeCall() Code.writeReturn() Code.writeFunction() Rubricas para avalia\u00e7\u00e3o de projetos \u00b6 Cada integrante do grupo ir\u00e1 receber duas notas: uma referente ao desenvolvimento total do projeto (Projeto) e outra referente a sua participa\u00e7\u00e3o individual no grupo (que depende do seu papel). Projeto \u00b6 Conceito I - Menos da metade dos m\u00f3dulos funcionando D - writeArithmetic OU writePushPop C - writeArithmetic E writePushPop B - writeLabel, writeGoto, writeIf A - writeCall, writeReturn, writeFunction Para testar \u00b6 A seguir os testes que devem passar para cada nota : C \u00b6 SimpleAdd SimpleNeg SimpleSub SimpleEq SimpleGt SimpleLt SimpleAnd SimpleOr SimplePushConst SimplePushTemp SimplePushLocal SimplePushArg SimplePushThis SimplePushThat SimplePopTemp SimplePopLocal SimplePopThat SimplePopThis SimplePushAdd SimplePopPointer StackTest (opcional) B \u00b6 BasicLoop A \u00b6 SimpleFunction StaticsTest Mult 1a-Add 1b-Add 2a-Calculadora 2b-Calculadora 2c-Calculadora 2d-Calculadora SimpleGoto SimpleIfGoto","title":"J VMtranslator Projeto"},{"location":"J-VMtranslator-Projeto/#instrucoes","text":"As instru\u00e7\u00f5es t\u00e9cnicas referente ao projeto est\u00e3o no lab 17, parte 1 e parte 2","title":"Instru\u00e7\u00f5es"},{"location":"J-VMtranslator-Projeto/#modulos-a-serem-implementados","text":"Apenas o Code.java . O projeto no total possui 5 m\u00f3dulos, sendo que o m\u00f3dulo VMTranslator.java , VMtranslate.java , Parser.java e Error.java j\u00e1 est\u00e3o foram entregues implementados. Os m\u00f3dulos est\u00e3o listados de maneira Top - Down VMTranslator Arquivo : VMTranslator.java Descri\u00e7\u00e3o : Main do projeto. Recebe como par\u00e2metro o nome do arquivo .vm (ou diret\u00f3rio) e o nome do arquivo bin\u00e1rio assembly ( .nasm ) a ser escrito, passa essas informa\u00e7\u00f5es para a classe VMtranslate. Depend\u00eancias : VMtranslate.java VMtranslate Arquivo : VMtranslate.java Descri\u00e7\u00e3o : Classe respons\u00e1vel por criar o c\u00f3digo assembly, ela que efetivamente faz a varredura do arquivo .vm de entrada e escreve o arquivo .nasm de sa\u00edda, gerando a tradu\u00e7\u00e3o vm -> nasm. Depend\u00eancias : Code.java , Parser.java Code Arquivo : Code.java Descri\u00e7\u00e3o : Traduz comandos da linguagem vm para os comandos em nasm que a executam. Depend\u00eancias : None Parser Arquivo : Parser.java Descri\u00e7\u00e3o : Encapsula o c\u00f3digo de leitura. Carrega as instru\u00e7\u00f5es na linguagem vm, analisa, e oferece acesso as partes da instru\u00e7\u00e3o (campos e s\u00edmbolos). Al\u00e9m disso, remove todos os espa\u00e7os em branco e coment\u00e1rios. Depend\u00eancias : none","title":"M\u00f3dulos a serem implementados"},{"location":"J-VMtranslator-Projeto/#sugestao-de-implementacao-partes","text":"Sugerimos que o VMTranslator seja implementado em duas partes, a primeira implementa somente o Parser.java e opera\u00e7\u00f5es aritm\u00e9ticas e push/pop . A segunda parte faz a implementa\u00e7\u00e3o de fun\u00e7\u00f5es, goto e chamada de fun\u00e7\u00f5es.","title":"Sugest\u00e3o de implementa\u00e7\u00e3o (partes)"},{"location":"J-VMtranslator-Projeto/#parte-1-conceito-c","text":"Code.writeArithmetic() Code.writePushPop()","title":"Parte 1 - Conceito C"},{"location":"J-VMtranslator-Projeto/#parte-2-conceito-b","text":"Code.writeGoto() Code.writeIf() Parte 3 - Conceito A Code.writeCall() Code.writeReturn() Code.writeFunction()","title":"Parte 2 - Conceito B"},{"location":"J-VMtranslator-Projeto/#rubricas-para-avaliacao-de-projetos","text":"Cada integrante do grupo ir\u00e1 receber duas notas: uma referente ao desenvolvimento total do projeto (Projeto) e outra referente a sua participa\u00e7\u00e3o individual no grupo (que depende do seu papel).","title":"Rubricas para avalia\u00e7\u00e3o de projetos"},{"location":"J-VMtranslator-Projeto/#projeto","text":"Conceito I - Menos da metade dos m\u00f3dulos funcionando D - writeArithmetic OU writePushPop C - writeArithmetic E writePushPop B - writeLabel, writeGoto, writeIf A - writeCall, writeReturn, writeFunction","title":"Projeto"},{"location":"J-VMtranslator-Projeto/#para-testar","text":"A seguir os testes que devem passar para cada nota :","title":"Para testar"},{"location":"J-VMtranslator-Projeto/#c","text":"SimpleAdd SimpleNeg SimpleSub SimpleEq SimpleGt SimpleLt SimpleAnd SimpleOr SimplePushConst SimplePushTemp SimplePushLocal SimplePushArg SimplePushThis SimplePushThat SimplePopTemp SimplePopLocal SimplePopThat SimplePopThis SimplePushAdd SimplePopPointer StackTest (opcional)","title":"C"},{"location":"J-VMtranslator-Projeto/#b","text":"BasicLoop","title":"B"},{"location":"J-VMtranslator-Projeto/#a","text":"SimpleFunction StaticsTest Mult 1a-Add 1b-Add 2a-Calculadora 2b-Calculadora 2c-Calculadora 2d-Calculadora SimpleGoto SimpleIfGoto","title":"A"},{"location":"J-VMtranslator-memoria/","text":"Fun\u00e7\u00e3o \u00b6 Os ponteiros LCL e ARG s\u00e3o utilizados somente na execu\u00e7\u00e3o de uma fun\u00e7\u00e3o. O ARG indica em qual endere\u00e7o da stack os par\u00e2metros que ser\u00e3o passados para a fun\u00e7\u00e3o est\u00e3o salvos e o LCL \u00e9 usado para apontar para o endere\u00e7o na pilha utilizado para armazenar vari\u00e1veis locais da fun\u00e7\u00e3o. O fluxo de chamada de fun\u00e7\u00e3o, de forma simplificada \u00e9: Coloca na pilha os argumentos que ser passado para a fun\u00e7\u00e3o a quantidade varia conforme a demanda da fun\u00e7\u00e3o primeiro argumento colocado na stack \u00e9 o de index 0 Chama a fun\u00e7\u00e3o ( call ) Aloca na pilha os endere\u00e7os de mem\u00f3ria para armazenar as vari\u00e1veis locais Atualiza os ponteiros: SP, LCL, ARG, THIS e THAT O fluxo de chamada de fun\u00e7\u00e3o (call) \u00e9 um pouco complexo, pois demanda que salvemos algumas informa\u00e7\u00f5es da pilha antes de executarmos a fun\u00e7\u00e3o (precisamos conseguir ap\u00f3s a execu\u00e7\u00e3o da fun\u00e7\u00e3o retornar para um estado similar antes da execu\u00e7\u00e3o). Para isso \u00e9 salvo na pilha, NA ORDEM A SEGUIR: Endere\u00e7o de retorno LCL (antes da chamada de fun\u00e7\u00e3o) ARG (antes da chamada de fun\u00e7\u00e3o) This (antes da chamada de fun\u00e7\u00e3o) That (antes da chamada de fun\u00e7\u00e3o) LCL - Local \u00b6 Local indica o endere\u00e7o na pilha na qual foi alocado para as vari\u00e1veis locais de uma fun\u00e7\u00e3o, a quantidade de endere\u00e7os alocados varia conforme a declara\u00e7\u00e3o da fun\u00e7\u00e3o, que pode possuir zero ou mais vari\u00e1veis tempor\u00e1rias. Peguemos como exemplo uma fun\u00e7\u00e3o em java : void example(int a, int b){ int aux0; int aux1; aux0 = a; aux1 = b; } Note que essa fun\u00e7\u00e3o possui duas vari\u00e1veis locais: aux0 e aux1 , que s\u00e3o vis\u00edveis somente dentro do escopo da fun\u00e7\u00e3o, essas vari\u00e1veis s\u00e3o alocadas quando a fun\u00e7\u00e3o \u00e9 chamada e desalocada quando a fun\u00e7\u00e3o retorna. Essas vari\u00e1veis ( aux0 , aux1 ) servem como vari\u00e1veis locais da fun\u00e7\u00e3o, e s\u00e3o salvas na stack, como a ilustra\u00e7\u00e3o a seguir : O exemplo em java anterior seria traduzido para a linguagem VM (de forma imediata) na seguinte maneira: function example 2 push argument 0 // coloca na pilha o valor a pop local 0 // aux0 = a push argument 1 // coloca na pilha o valor b pop local 1 // aux1 = b Note que o que define local 0 e local 1 \u00e9 a ordem na qual as vari\u00e1veis foram declaradas, como a vari\u00e1vel aux0 foi declarada primeiro, ela \u00e9 alocada no local 0 . O LCL aponta apenas para o endere\u00e7o do primeiro local , os demais s\u00e3o inferidos da seguinte maneira: push local n endere\u00e7o local n = LCL + n ARG - Argumento \u00b6 O ponteiro ARG indica a onde na pilha est\u00e3o salvos os argumentos que a fun\u00e7\u00e3o pode acessar, e segue a mesma l\u00f3gica do LCL, onde o ARG aponta para o primeiro argumento e o endere\u00e7o dos demais s\u00e3o inferidos com base no endere\u00e7o do primeiro. Os ARG s\u00e3o salvos na pr\u00f3pria pilha, antes da chamada da fun\u00e7\u00e3o: pilha comando VM endere\u00e7os -------------------------------------------- 12 | call mult 2 | 12 <- ARG 13 | | 13 SP -> | |----\\ | | |----/ | Exemplo Stack chamada de fun\u00e7\u00e3o \u00b6 258 : SP 265 : SP 257 : SP 333 : LCL 263 : LCL 333 : LCL 444 : ARG call mult 2 256 : ARG return 444 : ARG 555 : THIS |----\\ 555 : THIS |----\\ 555 : THIS 666 : THAT |----/ 666 : THAT |----/ 666 : THAT ~~~~~~~~~~~~ ~~~~~~~~~~~ ~~~~~~~~~~~~ 8 : 256 8 : 256 <- LCL 32 : 256 4 : 257 4 : 257 4 : 257 <- SP 0 : 258 <- SP 256 : 258 : RETURN 0 : 258 333 : 259 : LCL 444 : 260 : ARG 555 : 261 : THIS 666 : 262 : THAT 0 : 263 <- LCL 0 : 264 0 : 265 <- SP Static variables \u00b6 \u00c9 a regi\u00e3o da mem\u00f3ria utilizada para armazenar vari\u00e1veis compartilhadas entre o mesmo arquivo .vm, conforme figura a seguir : A static n\u00e3o \u00e9 vis\u00edvel entre diferentes arquivos .vm, deixando as vari\u00e1veis limitadas a um escopo. O static ser\u00e1 utilizado para armazenar as vari\u00e1veis est\u00e1ticas de uma determinada classe. Exemplo de acesso ao static : O exemplo a seguir demonstra duas classes (class1.vm e class2.vm) sendo utilizadas com os seus respectivos stacks. Nesse exemplo, a fun\u00e7\u00e3o main inicializa o static da classe 1 em : static[0] = 6, static[1] = 8 e o static ca classe 2 em : static[0] = 23, static[0] = 15. Isso ser\u00e1 bastante utilizado para fazer a implementa\u00e7\u00e3o da estrutura a seguir : public class class1 { static int valor0 ; // alocado no static 0 static int valor1 ; // alocado no static 1 public void set ( int var1 , va2 ){ valor0 = var1 ; valor1 = var2 ; } public void get ( void ){ return ( valor0 - valor1 ); } As vari\u00e1veis est\u00e1ticas s\u00e3o compartilhadas entre os objetos inicializados a partir da mesma classe, alocando assim apenas um slot de mem\u00f3ria para todos os objetos criados a partir dessa classe ^1. ^1: https://beginnersbook.com/2013/05/static-variable/ HEAP \u00b6 O HEAP \u00e9 a regi\u00e3o de mem\u00f3ria a ser utilizada para armazenamento objetos e vetores, um objeto ser\u00e1 constru\u00eddo a partir de uma classe e compartilhar\u00e1 as mesma vari\u00e1veis est\u00e1ticas mas n\u00e3o as mesmas vari\u00e1veis locais ao objeto. Vamos tomar como ponto de partida o exemplo a seguir que inicializa dois objetos (terra e lua) do tipo corpoCeleste : void main (){ corpoCeleste terra = new corpoCeletes (); terra . setMassa ( 1200 ); corpoCeleste lua = new corpoCeleste (); lua . setMassa ( 32 ); lua . pi = 314 ; } public class corpoCeleste (){ static int pi ; int raio ; int gravidade ; int massa ; void getMassa (){ return ( this . massa ); } void setMassa ( int m ){ this . massa = m ; } } Esse exemplo aloca no Heap tr\u00eas endere\u00e7os em locais diferentes para cada objeto criado do tipo corpoCeleste, por\u00e9m a vari\u00e1vel pi , que \u00e9 est\u00e1tica \u00e9 comum a todos os objetos criados a partir da mesma classe. A figura a seguir ilustra como essas vari\u00e1veis seriam alocadas em mem\u00f3ria. This \u00b6 This \u00e9 o ponteiro que refer\u00eancia o pr\u00f3prio objeto: objeto na qual o m\u00e9todo ou construtor est\u00e1 sendo chamado. No caso da chamada do m\u00e9todo getMassa() da classe corpoCeleste, o ponteiro This ser\u00e1 ajustado para apontar para o objeto na qual o m\u00e9todo foi chamado. O fluxo da m\u00e1quina virtual ser\u00e1 o seguinte : Ajusta o this para apontar para o in\u00edcio do HEAP pertencente ao objeto chama a fun\u00e7\u00e3o getMassa do arquivo corpoCeleste.vm That \u00b6 O ponteiro That \u00e9 utilizado para referenciar outro objeto, utilizado no exemplo a seguir : M\u00e9todo objetoCeleste : void compareMassa ( corpoCeleste outro ){ if ( this . massa == outro . massa ){ return ( True ); } else { return ( False ); } } C\u00f3digo principal : void main (){ ... rtn = terra . compareMassa ( lua ); } Nesse exemplo, inclu\u00edmos um novo m\u00e9todo (compareMass) na classe corpoCeleste, esse novo m\u00e9todo compara a massa de um outro objeto com a do pr\u00f3prio objeto, retornando verdadeiro ou falso dependendo do resultado. Como esse c\u00f3digo seria traduzido para VM ? O objeto em quest\u00e3o ser\u00e1 acessado utilizando o ponteiro this e o objeto a ser comparado ser\u00e1 acessado via o that . O compilador da linguagem de alto n\u00edvel para VM ser\u00e1 respons\u00e1vel por alocar os objetos nos endere\u00e7os certos. function main 0 ... push constant 2048 // endere\u00e7o objeto terra push constant 2051 // endere\u00e7o objeto lua call cortpoCeleste.compare mass 2 function corpoCeleste.compareMass 0 push argument 0 pop pointer 0 // atualiza endere\u00e7o this push argument 1 pop pointer 1 // atualiza endere\u00e7o that push this 2 // this 0 = gravidade; this 1 = raio; this 2 = massa push that 2 // that 0 = gravidade; this 1 = raio; this 2 = massa eq return Note que quando o m\u00e9todo for chamado (no caso da vm o m\u00e9todo ser\u00e1 traduzido para uma fun\u00e7\u00e3o), os ponteiros this e that devem ser passados via a chama da fun\u00e7\u00e3o, e no come\u00e7o da fun\u00e7\u00e3o atualizado os endere\u00e7os RAM[3] - This e RAM[4] - That.","title":"J VMtranslator memoria"},{"location":"J-VMtranslator-memoria/#funcao","text":"Os ponteiros LCL e ARG s\u00e3o utilizados somente na execu\u00e7\u00e3o de uma fun\u00e7\u00e3o. O ARG indica em qual endere\u00e7o da stack os par\u00e2metros que ser\u00e3o passados para a fun\u00e7\u00e3o est\u00e3o salvos e o LCL \u00e9 usado para apontar para o endere\u00e7o na pilha utilizado para armazenar vari\u00e1veis locais da fun\u00e7\u00e3o. O fluxo de chamada de fun\u00e7\u00e3o, de forma simplificada \u00e9: Coloca na pilha os argumentos que ser passado para a fun\u00e7\u00e3o a quantidade varia conforme a demanda da fun\u00e7\u00e3o primeiro argumento colocado na stack \u00e9 o de index 0 Chama a fun\u00e7\u00e3o ( call ) Aloca na pilha os endere\u00e7os de mem\u00f3ria para armazenar as vari\u00e1veis locais Atualiza os ponteiros: SP, LCL, ARG, THIS e THAT O fluxo de chamada de fun\u00e7\u00e3o (call) \u00e9 um pouco complexo, pois demanda que salvemos algumas informa\u00e7\u00f5es da pilha antes de executarmos a fun\u00e7\u00e3o (precisamos conseguir ap\u00f3s a execu\u00e7\u00e3o da fun\u00e7\u00e3o retornar para um estado similar antes da execu\u00e7\u00e3o). Para isso \u00e9 salvo na pilha, NA ORDEM A SEGUIR: Endere\u00e7o de retorno LCL (antes da chamada de fun\u00e7\u00e3o) ARG (antes da chamada de fun\u00e7\u00e3o) This (antes da chamada de fun\u00e7\u00e3o) That (antes da chamada de fun\u00e7\u00e3o)","title":"Fun\u00e7\u00e3o"},{"location":"J-VMtranslator-memoria/#lcl-local","text":"Local indica o endere\u00e7o na pilha na qual foi alocado para as vari\u00e1veis locais de uma fun\u00e7\u00e3o, a quantidade de endere\u00e7os alocados varia conforme a declara\u00e7\u00e3o da fun\u00e7\u00e3o, que pode possuir zero ou mais vari\u00e1veis tempor\u00e1rias. Peguemos como exemplo uma fun\u00e7\u00e3o em java : void example(int a, int b){ int aux0; int aux1; aux0 = a; aux1 = b; } Note que essa fun\u00e7\u00e3o possui duas vari\u00e1veis locais: aux0 e aux1 , que s\u00e3o vis\u00edveis somente dentro do escopo da fun\u00e7\u00e3o, essas vari\u00e1veis s\u00e3o alocadas quando a fun\u00e7\u00e3o \u00e9 chamada e desalocada quando a fun\u00e7\u00e3o retorna. Essas vari\u00e1veis ( aux0 , aux1 ) servem como vari\u00e1veis locais da fun\u00e7\u00e3o, e s\u00e3o salvas na stack, como a ilustra\u00e7\u00e3o a seguir : O exemplo em java anterior seria traduzido para a linguagem VM (de forma imediata) na seguinte maneira: function example 2 push argument 0 // coloca na pilha o valor a pop local 0 // aux0 = a push argument 1 // coloca na pilha o valor b pop local 1 // aux1 = b Note que o que define local 0 e local 1 \u00e9 a ordem na qual as vari\u00e1veis foram declaradas, como a vari\u00e1vel aux0 foi declarada primeiro, ela \u00e9 alocada no local 0 . O LCL aponta apenas para o endere\u00e7o do primeiro local , os demais s\u00e3o inferidos da seguinte maneira: push local n endere\u00e7o local n = LCL + n","title":"LCL - Local"},{"location":"J-VMtranslator-memoria/#arg-argumento","text":"O ponteiro ARG indica a onde na pilha est\u00e3o salvos os argumentos que a fun\u00e7\u00e3o pode acessar, e segue a mesma l\u00f3gica do LCL, onde o ARG aponta para o primeiro argumento e o endere\u00e7o dos demais s\u00e3o inferidos com base no endere\u00e7o do primeiro. Os ARG s\u00e3o salvos na pr\u00f3pria pilha, antes da chamada da fun\u00e7\u00e3o: pilha comando VM endere\u00e7os -------------------------------------------- 12 | call mult 2 | 12 <- ARG 13 | | 13 SP -> | |----\\ | | |----/ |","title":"ARG - Argumento"},{"location":"J-VMtranslator-memoria/#exemplo-stack-chamada-de-funcao","text":"258 : SP 265 : SP 257 : SP 333 : LCL 263 : LCL 333 : LCL 444 : ARG call mult 2 256 : ARG return 444 : ARG 555 : THIS |----\\ 555 : THIS |----\\ 555 : THIS 666 : THAT |----/ 666 : THAT |----/ 666 : THAT ~~~~~~~~~~~~ ~~~~~~~~~~~ ~~~~~~~~~~~~ 8 : 256 8 : 256 <- LCL 32 : 256 4 : 257 4 : 257 4 : 257 <- SP 0 : 258 <- SP 256 : 258 : RETURN 0 : 258 333 : 259 : LCL 444 : 260 : ARG 555 : 261 : THIS 666 : 262 : THAT 0 : 263 <- LCL 0 : 264 0 : 265 <- SP","title":"Exemplo Stack chamada de fun\u00e7\u00e3o"},{"location":"J-VMtranslator-memoria/#static-variables","text":"\u00c9 a regi\u00e3o da mem\u00f3ria utilizada para armazenar vari\u00e1veis compartilhadas entre o mesmo arquivo .vm, conforme figura a seguir : A static n\u00e3o \u00e9 vis\u00edvel entre diferentes arquivos .vm, deixando as vari\u00e1veis limitadas a um escopo. O static ser\u00e1 utilizado para armazenar as vari\u00e1veis est\u00e1ticas de uma determinada classe. Exemplo de acesso ao static : O exemplo a seguir demonstra duas classes (class1.vm e class2.vm) sendo utilizadas com os seus respectivos stacks. Nesse exemplo, a fun\u00e7\u00e3o main inicializa o static da classe 1 em : static[0] = 6, static[1] = 8 e o static ca classe 2 em : static[0] = 23, static[0] = 15. Isso ser\u00e1 bastante utilizado para fazer a implementa\u00e7\u00e3o da estrutura a seguir : public class class1 { static int valor0 ; // alocado no static 0 static int valor1 ; // alocado no static 1 public void set ( int var1 , va2 ){ valor0 = var1 ; valor1 = var2 ; } public void get ( void ){ return ( valor0 - valor1 ); } As vari\u00e1veis est\u00e1ticas s\u00e3o compartilhadas entre os objetos inicializados a partir da mesma classe, alocando assim apenas um slot de mem\u00f3ria para todos os objetos criados a partir dessa classe ^1. ^1: https://beginnersbook.com/2013/05/static-variable/","title":"Static variables"},{"location":"J-VMtranslator-memoria/#heap","text":"O HEAP \u00e9 a regi\u00e3o de mem\u00f3ria a ser utilizada para armazenamento objetos e vetores, um objeto ser\u00e1 constru\u00eddo a partir de uma classe e compartilhar\u00e1 as mesma vari\u00e1veis est\u00e1ticas mas n\u00e3o as mesmas vari\u00e1veis locais ao objeto. Vamos tomar como ponto de partida o exemplo a seguir que inicializa dois objetos (terra e lua) do tipo corpoCeleste : void main (){ corpoCeleste terra = new corpoCeletes (); terra . setMassa ( 1200 ); corpoCeleste lua = new corpoCeleste (); lua . setMassa ( 32 ); lua . pi = 314 ; } public class corpoCeleste (){ static int pi ; int raio ; int gravidade ; int massa ; void getMassa (){ return ( this . massa ); } void setMassa ( int m ){ this . massa = m ; } } Esse exemplo aloca no Heap tr\u00eas endere\u00e7os em locais diferentes para cada objeto criado do tipo corpoCeleste, por\u00e9m a vari\u00e1vel pi , que \u00e9 est\u00e1tica \u00e9 comum a todos os objetos criados a partir da mesma classe. A figura a seguir ilustra como essas vari\u00e1veis seriam alocadas em mem\u00f3ria.","title":"HEAP"},{"location":"J-VMtranslator-memoria/#this","text":"This \u00e9 o ponteiro que refer\u00eancia o pr\u00f3prio objeto: objeto na qual o m\u00e9todo ou construtor est\u00e1 sendo chamado. No caso da chamada do m\u00e9todo getMassa() da classe corpoCeleste, o ponteiro This ser\u00e1 ajustado para apontar para o objeto na qual o m\u00e9todo foi chamado. O fluxo da m\u00e1quina virtual ser\u00e1 o seguinte : Ajusta o this para apontar para o in\u00edcio do HEAP pertencente ao objeto chama a fun\u00e7\u00e3o getMassa do arquivo corpoCeleste.vm","title":"This"},{"location":"J-VMtranslator-memoria/#that","text":"O ponteiro That \u00e9 utilizado para referenciar outro objeto, utilizado no exemplo a seguir : M\u00e9todo objetoCeleste : void compareMassa ( corpoCeleste outro ){ if ( this . massa == outro . massa ){ return ( True ); } else { return ( False ); } } C\u00f3digo principal : void main (){ ... rtn = terra . compareMassa ( lua ); } Nesse exemplo, inclu\u00edmos um novo m\u00e9todo (compareMass) na classe corpoCeleste, esse novo m\u00e9todo compara a massa de um outro objeto com a do pr\u00f3prio objeto, retornando verdadeiro ou falso dependendo do resultado. Como esse c\u00f3digo seria traduzido para VM ? O objeto em quest\u00e3o ser\u00e1 acessado utilizando o ponteiro this e o objeto a ser comparado ser\u00e1 acessado via o that . O compilador da linguagem de alto n\u00edvel para VM ser\u00e1 respons\u00e1vel por alocar os objetos nos endere\u00e7os certos. function main 0 ... push constant 2048 // endere\u00e7o objeto terra push constant 2051 // endere\u00e7o objeto lua call cortpoCeleste.compare mass 2 function corpoCeleste.compareMass 0 push argument 0 pop pointer 0 // atualiza endere\u00e7o this push argument 1 pop pointer 1 // atualiza endere\u00e7o that push this 2 // this 0 = gravidade; this 1 = raio; this 2 = massa push that 2 // that 0 = gravidade; this 1 = raio; this 2 = massa eq return Note que quando o m\u00e9todo for chamado (no caso da vm o m\u00e9todo ser\u00e1 traduzido para uma fun\u00e7\u00e3o), os ponteiros this e that devem ser passados via a chama da fun\u00e7\u00e3o, e no come\u00e7o da fun\u00e7\u00e3o atualizado os endere\u00e7os RAM[3] - This e RAM[4] - That.","title":"That"},{"location":"LogiComb-Lab-1/","text":"Lab 4: FPGA - VHDL \u00b6 Linux Usar o Linux fornecido! Trabalhando em grupo Realizar o resto o lab em dupla Esse laborat\u00f3rio \u00e9 introdut\u00f3rio para o desenvolvimento do projeto ( B-L\u00f3gica-Combinacional ), onde iremos criar os bloquinhos de hardware que ser\u00e3o os tijolos de nosso computador. Primeiro precisamos praticar um pouco de VHDL e entender a ferramenta de compila\u00e7\u00e3o e programa\u00e7\u00e3o (Quartus). Ap\u00f3s essa etapa, iremos come\u00e7ar o desenvolvimento do projeto, programando os m\u00f3dulos que vir\u00e3o a ser utilizados no computador Z01 (Lab-5). Antes de come\u00e7ar \u00b6 Toda vez que um novo projeto come\u00e7ar ser\u00e1 necess\u00e1rio realizar algumas configura\u00e7\u00f5es no reposit\u00f3rio do grupo, voc\u00eas devem seguir para o documento: Util/Come\u00e7ando novo Projeto e depois voltar para esse lab. Warning N\u00e3o seguir sem realizar a etapa anterior. Entendendo a estrutura de pastas dos projetos \u00b6 A pasta do projeto B ( LogicaCombinacional ) no reposit\u00f3rio Z01 possui a seguinte estrutura (assim como todos os demais projetos): /B-LogicaCombinacional testeLogicaCombinacional.py /Quartus /src /rtl *.vhd /tests config.txt /tst *.vhd Quartus : Projeto Quartus que faz uso dos arquivos VHDL localizados em src/rtl/*.vhd Serve para programar a FPGA *.py : Scripts em python automatiza a execu\u00e7\u00e3o dos testes src/rtl/*.vhd : Arquivos VHDL que ser\u00e3o implementado pelo grupo tests/tst/*.vhd : Arquivos VHDL que realizam teste l\u00f3gico nos arquivos do rtl tests/config.txt : Configura\u00e7\u00e3o dos testes Abrindo o Quartus \u00b6 Linux Se n\u00e3o encontrar o software abra o terminal e escreva quartus enter . Abra o software do Quartus e clique em File Open Project escolha o projeto localizado na pasta B-LogicaCombinacional/Quartus . O arquivo que o Quartus ir\u00e1 reconhecer \u00e9 o: DE0_CV_Default.qpf como no gif a seguir: Abra o arquivo TopLevel.vhd como demonstrado no gif anterior, este arquivo \u00e9 o que chamamos de top level (pode-se fazer uma analogia com o main de um c\u00f3digo), ele ser\u00e1 o primeiro a ser executado na compila\u00e7\u00e3o e utilizar\u00e1 os demais m\u00f3dulos do sistema. Compilando o c\u00f3digo \u00b6 Note O c\u00f3digo original dispon\u00edvel n\u00e3o realiza nenhuma l\u00f3gica. Note que sua arquitetura est\u00e1 vazia! Para compilarmos esse c\u00f3digo VHDL basta irmos em: Processing Start Compilation . A ferramenta ir\u00e1 \"realizar\" o c\u00f3digo, ou seja, interpretar e torna-lo um hardware. RTL View \u00b6 Podemos gerar a vis\u00e3o RTL do c\u00f3digo em vhdl, esse diagrama \u00e9 a interpreta\u00e7\u00e3o do c\u00f3digo em VHDL pelo compilador e como ele seria supostamente implementando em hardware. Para isso: Tools Netlist Viewers RTL viewer Ele ir\u00e1 gerar o diagrama a seguir: Onde podemos analisar que n\u00e3o existe nenhuma l\u00f3gica que relaciona entrada com sa\u00edda. RTL O RTL aqui tem outro significado de quando foi utilizado com transistores, aqui \u00e9 Register-transfer level e nos transistores \u00e9 Resistor\u2013transistor logic . Tip Iremos utilizar bastante o RTL. Modificando o projeto \u00b6 Vamos modificar o arquivo toplevel.vhd do projeto adicionando que o bit 0 do vetor LEDR seja igual ao bit 0 da chave SW, o vhdl deve ficar como a seguir: --------------- -- implementacao --------------- begin LEDR ( 0 ) <= SW ( 0 ); end rtl ; Tarefa Edite o toplevel Compile Gere o RTL Viewer novamente O resultado deve ser o seguinte: Onde o valor do LEDR0 ser\u00e1 o pr\u00f3prio valor de entrada chave SW0 . Programando a FPGA \u00b6 Conectar via USB (n\u00e3o precisa da fonte) Deve ligar, caso contr\u00e1rio apertar o bot\u00e3o vermelho Verificar se a chave SW10 est\u00e1 em 'run' Para programar na FPGA conecte-a ao seu computador via cabo USB e v\u00e1 em: Tools Programmer . Ele deve abrir uma nova interface: Testando Brinque com a chave SW0 e note que o LED ir\u00e1 acender conforme a chave \u00e9 colocada na posi\u00e7\u00e3o on. Exerc\u00edcios \u00b6 Para cada desafio proposto a seguir, verifique se o RTL corresponde a l\u00f3gica que deseja implementar. Ap\u00f3s a verifica\u00e7\u00e3o teste na programe e teste na FPGA: Compile Verifique o RTL Programe a FPGA Tarefa Fa\u00e7a a sa\u00edda LEDR(0) ser o inverso da entrada SW(0) Tarefa Fa\u00e7a a sa\u00edda LEDR(0) ser a entrada SW(0) ou SW(1) Tarefa Fa\u00e7a a sa\u00edda LEDR(0) ser a entrada SW(0) ou SW(1) e o LEDR(1) ser a chave SW(1) Note que na nossa FPGA possu\u00edmos seis displays de sete segmentos . Para termos acesso a esses displays, basta modificar a entidade do projeto para: entity TopLevel is port ( SW : in std_logic_vector ( 9 downto 0 ); HEX0 : out std_logic_vector ( 6 downto 0 ); -- 7seg0 LEDR : out std_logic_vector ( 9 downto 0 ) ); end entity ; Agora com um display de 7segementos mapeado como sa\u00edda ( out ) na nossa entity podemos acionar cada led do display como descrito no manual da placa (isso s\u00f3 \u00e9 poss\u00edvel pois o projeto j\u00e1 foi configurado corretamente antes pelo seu professor): Tip Para acender um segmento \u00e9 necess\u00e1rio colocar 0 e para apagar 1 . Tarefa Modifique a entity para possuir a nova sa\u00edda Fa\u00e7a aparecer o n\u00famero 5 no HEX0 . Adicionando um novo componente ao projeto \u00b6 O desenvolvimento de projetos de hardware assim como os de softwares devem ser feitos de forma modular, onde especifica-se e implementa-se pequenos m\u00f3dulos (entidades) que s\u00e3o combinadas em sistemas cada vez mais complexos at\u00e9 chegar ao TopLevel . Para usarmos um novo componente no projeto \u00e9 necess\u00e1rio: Adicionar o arquivo ao projeto Usar na arquitetura bin\u00e1rio para BCD \u00b6 Vamos inserir no toplevel um componente que faz a convers\u00e3o de n\u00fameros bin\u00e1rios para BCD , esse componente j\u00e1 est\u00e1 implementando e se encontra na pasta B-LogicaCombinacional/src/rtl/ junto com outros m\u00f3dulos: And16.vhd Mux8Way.vhd binarioToBcd.vhd ... Nor8Way.vhd TopLevel.vhd O m\u00f3dulo binarioToBcd.vhd possui a seguinte entidade (entradas e sa\u00eddas): entity binary_bcd is port ( clk , reset : in std_logic ; binary_in : in std_logic_vector ( N - 1 downto 0 ); bcd0 , bcd1 , bcd2 , bcd3 , bcd4 : out std_logic_vector ( 3 downto 0 ) ); end binary_bcd ; Esse m\u00f3dulo que possui como interfaces principais: um vetor de entrada binary_in e cinco sa\u00eddas ( bcd0 .. bcd5 ) e implementa um conversor de bin\u00e1rio para BCD. clock e rst Note que esse componente possui outras duas entradas: clk e reset , isso \u00e9 necess\u00e1rio pois ele \u00e9 um componente sequencial (ainda n\u00e3o vimos isso). Inserindo binarioToBcd no projeto \u00b6 Para inserirmos o componente no projeto devemos: no quartus Project Add/Remove files in Project . Uma nova janela deve aparecer, nela clicar em File name ... e procurar pelo arquivo binarioToBcd.vhd que est\u00e1 na pasta src/rtl um n\u00edvel a cima. Ao final, clicar em apply . Usando no toplevel \u00b6 Podemos inserir o conversor binarioToBcd no toplevel da seguinte maneira: begin u1 : work . binarioToBcd port map ( clk => CLOCK_50 , reset => '0' , binary_in => SW , bcd0 => LEDR ( 3 downto 0 ), bcd1 => LEDR ( 7 downto 4 ), bcd2 => open , bcd3 => open , bcd4 => open ); end rtl ; Essa linha de c\u00f3digo pode ser lida como: Cria um componente chamada de u1 , esse componente \u00e9 uma implementa\u00e7\u00e3o do binarioToBcd , nesse componente mapeasse a entrada clk para o pino CLOCK_50 , a entrada reset para 0 e a entrada binary_in para as chaves da FPGA. Os d\u00edgitos 0 e 1 s\u00e3o exibidos nos LEDs e os demais deixamos desconectados. Compilando o projeto podemos analisar o RTL gerado: Testando \u00b6 Tarefa Compile Gere o RTL e an\u00e1lise Programe a FPGA e teste Voc\u00ea deve mudar as chaves SW e observar se os LEDs (3..0) e (7..4) est\u00e3o acendendo corretamente. dica: coloque a palavra 13 em bin\u00e1rio, voc\u00ea deve obter: LED(3..0) = \"0011\" e os LED(7..4) = \"0001\". Desafios extras \u00b6 Realize os seguintes desafios junto com o seu grupo, siga os passos anteriores para conseguir rodar na FPGA. Tarefa Fa\u00e7a TODOs os LEDs acenderem quando a seguinte combina\u00e7\u00e3o de entrada for: SW9 SW0 1 0 0 1 1 0 1 0 1 0 Tarefa Fa\u00e7a um c\u00f3digo VHDL para implementar o circuito a seguir: Sendo: X: chave 0 (SW(0)) y: chave 1 (SW(1)) z: chave 2 (SW(2))","title":"Lab 4: FPGA - VHDL"},{"location":"LogiComb-Lab-1/#lab-4-fpga-vhdl","text":"Linux Usar o Linux fornecido! Trabalhando em grupo Realizar o resto o lab em dupla Esse laborat\u00f3rio \u00e9 introdut\u00f3rio para o desenvolvimento do projeto ( B-L\u00f3gica-Combinacional ), onde iremos criar os bloquinhos de hardware que ser\u00e3o os tijolos de nosso computador. Primeiro precisamos praticar um pouco de VHDL e entender a ferramenta de compila\u00e7\u00e3o e programa\u00e7\u00e3o (Quartus). Ap\u00f3s essa etapa, iremos come\u00e7ar o desenvolvimento do projeto, programando os m\u00f3dulos que vir\u00e3o a ser utilizados no computador Z01 (Lab-5).","title":"Lab 4: FPGA - VHDL"},{"location":"LogiComb-Lab-1/#antes-de-comecar","text":"Toda vez que um novo projeto come\u00e7ar ser\u00e1 necess\u00e1rio realizar algumas configura\u00e7\u00f5es no reposit\u00f3rio do grupo, voc\u00eas devem seguir para o documento: Util/Come\u00e7ando novo Projeto e depois voltar para esse lab. Warning N\u00e3o seguir sem realizar a etapa anterior.","title":"Antes de come\u00e7ar"},{"location":"LogiComb-Lab-1/#entendendo-a-estrutura-de-pastas-dos-projetos","text":"A pasta do projeto B ( LogicaCombinacional ) no reposit\u00f3rio Z01 possui a seguinte estrutura (assim como todos os demais projetos): /B-LogicaCombinacional testeLogicaCombinacional.py /Quartus /src /rtl *.vhd /tests config.txt /tst *.vhd Quartus : Projeto Quartus que faz uso dos arquivos VHDL localizados em src/rtl/*.vhd Serve para programar a FPGA *.py : Scripts em python automatiza a execu\u00e7\u00e3o dos testes src/rtl/*.vhd : Arquivos VHDL que ser\u00e3o implementado pelo grupo tests/tst/*.vhd : Arquivos VHDL que realizam teste l\u00f3gico nos arquivos do rtl tests/config.txt : Configura\u00e7\u00e3o dos testes","title":"Entendendo a estrutura de pastas dos projetos"},{"location":"LogiComb-Lab-1/#abrindo-o-quartus","text":"Linux Se n\u00e3o encontrar o software abra o terminal e escreva quartus enter . Abra o software do Quartus e clique em File Open Project escolha o projeto localizado na pasta B-LogicaCombinacional/Quartus . O arquivo que o Quartus ir\u00e1 reconhecer \u00e9 o: DE0_CV_Default.qpf como no gif a seguir: Abra o arquivo TopLevel.vhd como demonstrado no gif anterior, este arquivo \u00e9 o que chamamos de top level (pode-se fazer uma analogia com o main de um c\u00f3digo), ele ser\u00e1 o primeiro a ser executado na compila\u00e7\u00e3o e utilizar\u00e1 os demais m\u00f3dulos do sistema.","title":"Abrindo o Quartus"},{"location":"LogiComb-Lab-1/#compilando-o-codigo","text":"Note O c\u00f3digo original dispon\u00edvel n\u00e3o realiza nenhuma l\u00f3gica. Note que sua arquitetura est\u00e1 vazia! Para compilarmos esse c\u00f3digo VHDL basta irmos em: Processing Start Compilation . A ferramenta ir\u00e1 \"realizar\" o c\u00f3digo, ou seja, interpretar e torna-lo um hardware.","title":"Compilando o c\u00f3digo"},{"location":"LogiComb-Lab-1/#rtl-view","text":"Podemos gerar a vis\u00e3o RTL do c\u00f3digo em vhdl, esse diagrama \u00e9 a interpreta\u00e7\u00e3o do c\u00f3digo em VHDL pelo compilador e como ele seria supostamente implementando em hardware. Para isso: Tools Netlist Viewers RTL viewer Ele ir\u00e1 gerar o diagrama a seguir: Onde podemos analisar que n\u00e3o existe nenhuma l\u00f3gica que relaciona entrada com sa\u00edda. RTL O RTL aqui tem outro significado de quando foi utilizado com transistores, aqui \u00e9 Register-transfer level e nos transistores \u00e9 Resistor\u2013transistor logic . Tip Iremos utilizar bastante o RTL.","title":"RTL View"},{"location":"LogiComb-Lab-1/#modificando-o-projeto","text":"Vamos modificar o arquivo toplevel.vhd do projeto adicionando que o bit 0 do vetor LEDR seja igual ao bit 0 da chave SW, o vhdl deve ficar como a seguir: --------------- -- implementacao --------------- begin LEDR ( 0 ) <= SW ( 0 ); end rtl ; Tarefa Edite o toplevel Compile Gere o RTL Viewer novamente O resultado deve ser o seguinte: Onde o valor do LEDR0 ser\u00e1 o pr\u00f3prio valor de entrada chave SW0 .","title":"Modificando o projeto"},{"location":"LogiComb-Lab-1/#programando-a-fpga","text":"Conectar via USB (n\u00e3o precisa da fonte) Deve ligar, caso contr\u00e1rio apertar o bot\u00e3o vermelho Verificar se a chave SW10 est\u00e1 em 'run' Para programar na FPGA conecte-a ao seu computador via cabo USB e v\u00e1 em: Tools Programmer . Ele deve abrir uma nova interface: Testando Brinque com a chave SW0 e note que o LED ir\u00e1 acender conforme a chave \u00e9 colocada na posi\u00e7\u00e3o on.","title":"Programando a FPGA"},{"location":"LogiComb-Lab-1/#exercicios","text":"Para cada desafio proposto a seguir, verifique se o RTL corresponde a l\u00f3gica que deseja implementar. Ap\u00f3s a verifica\u00e7\u00e3o teste na programe e teste na FPGA: Compile Verifique o RTL Programe a FPGA Tarefa Fa\u00e7a a sa\u00edda LEDR(0) ser o inverso da entrada SW(0) Tarefa Fa\u00e7a a sa\u00edda LEDR(0) ser a entrada SW(0) ou SW(1) Tarefa Fa\u00e7a a sa\u00edda LEDR(0) ser a entrada SW(0) ou SW(1) e o LEDR(1) ser a chave SW(1) Note que na nossa FPGA possu\u00edmos seis displays de sete segmentos . Para termos acesso a esses displays, basta modificar a entidade do projeto para: entity TopLevel is port ( SW : in std_logic_vector ( 9 downto 0 ); HEX0 : out std_logic_vector ( 6 downto 0 ); -- 7seg0 LEDR : out std_logic_vector ( 9 downto 0 ) ); end entity ; Agora com um display de 7segementos mapeado como sa\u00edda ( out ) na nossa entity podemos acionar cada led do display como descrito no manual da placa (isso s\u00f3 \u00e9 poss\u00edvel pois o projeto j\u00e1 foi configurado corretamente antes pelo seu professor): Tip Para acender um segmento \u00e9 necess\u00e1rio colocar 0 e para apagar 1 . Tarefa Modifique a entity para possuir a nova sa\u00edda Fa\u00e7a aparecer o n\u00famero 5 no HEX0 .","title":"Exerc\u00edcios"},{"location":"LogiComb-Lab-1/#adicionando-um-novo-componente-ao-projeto","text":"O desenvolvimento de projetos de hardware assim como os de softwares devem ser feitos de forma modular, onde especifica-se e implementa-se pequenos m\u00f3dulos (entidades) que s\u00e3o combinadas em sistemas cada vez mais complexos at\u00e9 chegar ao TopLevel . Para usarmos um novo componente no projeto \u00e9 necess\u00e1rio: Adicionar o arquivo ao projeto Usar na arquitetura","title":"Adicionando um novo componente ao projeto"},{"location":"LogiComb-Lab-1/#binario-para-bcd","text":"Vamos inserir no toplevel um componente que faz a convers\u00e3o de n\u00fameros bin\u00e1rios para BCD , esse componente j\u00e1 est\u00e1 implementando e se encontra na pasta B-LogicaCombinacional/src/rtl/ junto com outros m\u00f3dulos: And16.vhd Mux8Way.vhd binarioToBcd.vhd ... Nor8Way.vhd TopLevel.vhd O m\u00f3dulo binarioToBcd.vhd possui a seguinte entidade (entradas e sa\u00eddas): entity binary_bcd is port ( clk , reset : in std_logic ; binary_in : in std_logic_vector ( N - 1 downto 0 ); bcd0 , bcd1 , bcd2 , bcd3 , bcd4 : out std_logic_vector ( 3 downto 0 ) ); end binary_bcd ; Esse m\u00f3dulo que possui como interfaces principais: um vetor de entrada binary_in e cinco sa\u00eddas ( bcd0 .. bcd5 ) e implementa um conversor de bin\u00e1rio para BCD. clock e rst Note que esse componente possui outras duas entradas: clk e reset , isso \u00e9 necess\u00e1rio pois ele \u00e9 um componente sequencial (ainda n\u00e3o vimos isso).","title":"bin\u00e1rio para BCD"},{"location":"LogiComb-Lab-1/#inserindo-binariotobcd-no-projeto","text":"Para inserirmos o componente no projeto devemos: no quartus Project Add/Remove files in Project . Uma nova janela deve aparecer, nela clicar em File name ... e procurar pelo arquivo binarioToBcd.vhd que est\u00e1 na pasta src/rtl um n\u00edvel a cima. Ao final, clicar em apply .","title":"Inserindo binarioToBcd no projeto"},{"location":"LogiComb-Lab-1/#usando-no-toplevel","text":"Podemos inserir o conversor binarioToBcd no toplevel da seguinte maneira: begin u1 : work . binarioToBcd port map ( clk => CLOCK_50 , reset => '0' , binary_in => SW , bcd0 => LEDR ( 3 downto 0 ), bcd1 => LEDR ( 7 downto 4 ), bcd2 => open , bcd3 => open , bcd4 => open ); end rtl ; Essa linha de c\u00f3digo pode ser lida como: Cria um componente chamada de u1 , esse componente \u00e9 uma implementa\u00e7\u00e3o do binarioToBcd , nesse componente mapeasse a entrada clk para o pino CLOCK_50 , a entrada reset para 0 e a entrada binary_in para as chaves da FPGA. Os d\u00edgitos 0 e 1 s\u00e3o exibidos nos LEDs e os demais deixamos desconectados. Compilando o projeto podemos analisar o RTL gerado:","title":"Usando no toplevel"},{"location":"LogiComb-Lab-1/#testando","text":"Tarefa Compile Gere o RTL e an\u00e1lise Programe a FPGA e teste Voc\u00ea deve mudar as chaves SW e observar se os LEDs (3..0) e (7..4) est\u00e3o acendendo corretamente. dica: coloque a palavra 13 em bin\u00e1rio, voc\u00ea deve obter: LED(3..0) = \"0011\" e os LED(7..4) = \"0001\".","title":"Testando"},{"location":"LogiComb-Lab-1/#desafios-extras","text":"Realize os seguintes desafios junto com o seu grupo, siga os passos anteriores para conseguir rodar na FPGA. Tarefa Fa\u00e7a TODOs os LEDs acenderem quando a seguinte combina\u00e7\u00e3o de entrada for: SW9 SW0 1 0 0 1 1 0 1 0 1 0 Tarefa Fa\u00e7a um c\u00f3digo VHDL para implementar o circuito a seguir: Sendo: X: chave 0 (SW(0)) y: chave 1 (SW(1)) z: chave 2 (SW(2))","title":"Desafios extras"},{"location":"LogiComb-Lab-2/","text":"Lab 5: L\u00f3gica Combinacional \u00b6 Individual Esse laborat\u00f3rio \u00e9 para ser realizado individualmente. Esse laborat\u00f3rio introduz o modelo de desenvolvimento baseado em testes que ser\u00e1 utilizado em todos os projetos. Iremos trabalhar implementando o m\u00f3dulo or16 que \u00e9 uma parte do projeto B. Para isso devemos editar o arquivo de configura\u00e7\u00e3o /Z01.1/Projetos/C-LogicaCombinacional/tests/config.txt descomentando o m\u00f3dulo Or16.vhd : ###################################### # Rafael.Corsi @ Insper.edu.br # # Elementos de Sistemas # # # # Arquivos de teste do projeto C # # - Para incluir o teste basta # # descomentar a linha # # # ###################################### nand.vhd Or16.vhd #Nor8Way.vhd #And16.vhd #Not16.vhd #Or8Way.vhd #DMux2Way.vhd #DMux4Way.vhd #DMux8Way.vhd #Mux2Way.vhd #Mux4Way.vhd #Mux16.vhd #Mux4Way16.vhd #Mux8Way.vhd #Mux8Way16.vhd Note Vamos ter dois m\u00f3dulos no teste: nand.vhd e o Or16.vhd Abra o terminal na pasta B-Logica-Combinacional/ e execute o script python testeLogicaCombinacional.py : $ ./testeLogicaCombinacional.py O mesmo ir\u00e1 executar a compila\u00e7\u00e3o dos arquivos src/rtl/*.vhd e realizar testes unit\u00e1rios em cada um desses m\u00f3dulos, como os m\u00f3dulos n\u00e3o est\u00e3o implementados e como estamos for\u00e7ando o teste do or16 devemos ter um erro nesse m\u00f3dulo. Esse erro acontece pois o m\u00f3dulo n\u00e3o possui nenhuma implementa\u00e7\u00e3o: Or16.vhd : library IEEE ; use IEEE.STD_LOGIC_1164. ALL ; entity Or16 is port ( a : in STD_LOGIC_VECTOR ( 15 downto 0 ); b : in STD_LOGIC_VECTOR ( 15 downto 0 ); q : out STD_LOGIC_VECTOR ( 15 downto 0 )); end entity ; architecture arch of Or16 is begin end architecture ; Vamos agora editar esse arquivo para realizar sua implementa\u00e7\u00e3o. Esse m\u00f3dulo deve realizar uma OR entre as entras a e b e colocar o resultado na sa\u00edda q , para isso insira a seguinte linha no arquivo q <= a or b ; Essa modifica\u00e7\u00e3o deve ser salva em novo branch or16 . Dentro do terminal (na pasta do projeto C): $ git checkout -B or16 Teste novamente ( ./testeLogicaCombinacional.py ), agora deve passar: Realizando o commit: $ git commit -am \"funcionando e testado\" Warning S\u00f3 um integrante do grupo deve realizar o pull! Pois todos fizeram a mesma coisa. Agora vamos enviar para o servidor (reposit\u00f3rio git remoto) o novo branch or16 : $ git push origin or16 Com o branch enviado ao github voc\u00ea deve gerar um pull-request para o mediador verificar e aprovar ou n\u00e3o a sua implementa\u00e7\u00e3o. Pr\u00f3ximos passos \u00b6 Agora \u00e9 come\u00e7ar a trabalhar nos demais m\u00f3dulos, leia a descri\u00e7\u00e3o do Projeto B na p\u00e1gina. Scrum Master Voc\u00ea \u00e9 scrum? Ent\u00e3o tem v\u00e1rias tarefas pela frente! Acesse a p\u00e1gina Util -> Vixi! Sou Scrum Master e siga os passos l\u00e1!","title":"Lab 5: L\u00f3gica Combinacional"},{"location":"LogiComb-Lab-2/#lab-5-logica-combinacional","text":"Individual Esse laborat\u00f3rio \u00e9 para ser realizado individualmente. Esse laborat\u00f3rio introduz o modelo de desenvolvimento baseado em testes que ser\u00e1 utilizado em todos os projetos. Iremos trabalhar implementando o m\u00f3dulo or16 que \u00e9 uma parte do projeto B. Para isso devemos editar o arquivo de configura\u00e7\u00e3o /Z01.1/Projetos/C-LogicaCombinacional/tests/config.txt descomentando o m\u00f3dulo Or16.vhd : ###################################### # Rafael.Corsi @ Insper.edu.br # # Elementos de Sistemas # # # # Arquivos de teste do projeto C # # - Para incluir o teste basta # # descomentar a linha # # # ###################################### nand.vhd Or16.vhd #Nor8Way.vhd #And16.vhd #Not16.vhd #Or8Way.vhd #DMux2Way.vhd #DMux4Way.vhd #DMux8Way.vhd #Mux2Way.vhd #Mux4Way.vhd #Mux16.vhd #Mux4Way16.vhd #Mux8Way.vhd #Mux8Way16.vhd Note Vamos ter dois m\u00f3dulos no teste: nand.vhd e o Or16.vhd Abra o terminal na pasta B-Logica-Combinacional/ e execute o script python testeLogicaCombinacional.py : $ ./testeLogicaCombinacional.py O mesmo ir\u00e1 executar a compila\u00e7\u00e3o dos arquivos src/rtl/*.vhd e realizar testes unit\u00e1rios em cada um desses m\u00f3dulos, como os m\u00f3dulos n\u00e3o est\u00e3o implementados e como estamos for\u00e7ando o teste do or16 devemos ter um erro nesse m\u00f3dulo. Esse erro acontece pois o m\u00f3dulo n\u00e3o possui nenhuma implementa\u00e7\u00e3o: Or16.vhd : library IEEE ; use IEEE.STD_LOGIC_1164. ALL ; entity Or16 is port ( a : in STD_LOGIC_VECTOR ( 15 downto 0 ); b : in STD_LOGIC_VECTOR ( 15 downto 0 ); q : out STD_LOGIC_VECTOR ( 15 downto 0 )); end entity ; architecture arch of Or16 is begin end architecture ; Vamos agora editar esse arquivo para realizar sua implementa\u00e7\u00e3o. Esse m\u00f3dulo deve realizar uma OR entre as entras a e b e colocar o resultado na sa\u00edda q , para isso insira a seguinte linha no arquivo q <= a or b ; Essa modifica\u00e7\u00e3o deve ser salva em novo branch or16 . Dentro do terminal (na pasta do projeto C): $ git checkout -B or16 Teste novamente ( ./testeLogicaCombinacional.py ), agora deve passar: Realizando o commit: $ git commit -am \"funcionando e testado\" Warning S\u00f3 um integrante do grupo deve realizar o pull! Pois todos fizeram a mesma coisa. Agora vamos enviar para o servidor (reposit\u00f3rio git remoto) o novo branch or16 : $ git push origin or16 Com o branch enviado ao github voc\u00ea deve gerar um pull-request para o mediador verificar e aprovar ou n\u00e3o a sua implementa\u00e7\u00e3o.","title":"Lab 5: L\u00f3gica Combinacional"},{"location":"LogiComb-Lab-2/#proximos-passos","text":"Agora \u00e9 come\u00e7ar a trabalhar nos demais m\u00f3dulos, leia a descri\u00e7\u00e3o do Projeto B na p\u00e1gina. Scrum Master Voc\u00ea \u00e9 scrum? Ent\u00e3o tem v\u00e1rias tarefas pela frente! Acesse a p\u00e1gina Util -> Vixi! Sou Scrum Master e siga os passos l\u00e1!","title":"Pr\u00f3ximos passos"},{"location":"LogiComb-Projeto/","text":"B - L\u00f3gica Combinacional \u00b6 Scrum Master Voc\u00ea \u00e9 Scrum Master e n\u00e3o sabe por onde come\u00e7ar? De uma olhada nessas dicas: Vixi! Sou Scrum Master Esse projeto tem como objetivo trabalhar com portas l\u00f3gicas e sistemas digitais combinacionais (sem um clock) em FPGA e VHDL. Os elementos l\u00f3gicos desenvolvidos nessa etapa ser\u00e3o utilizados como elementos b\u00e1sicos para a constru\u00e7\u00e3o do computador. Instru\u00e7\u00f5es \u00b6 O desenvolvimento ser\u00e1 na linguagem VHDL, o grupo deve se organizar para implementar todos os elementos propostos. O facilitador escolhido ser\u00e1 respons\u00e1vel pela completude e consist\u00eancia do branch master do grupo. Integrantes \u00b6 Tarefas devem ser criadas no Issues e atribu\u00eddas aos demais colegas. As tarefas devem ser resolvidas individualmente! Utilize a ajuda de seus colegas, mas resolva o que foi atribu\u00eddo a voc\u00eas, essa \u00e9 sua tarefa/ responsabilidade! Warning Este projeto \u00e9 para ser realizado por todos os integrantes do grupo em seus pr\u00f3prios computadores, quem n\u00e3o participar, n\u00e3o implementar os m\u00f3dulos que foram atribu\u00eddos, ou n\u00e3o realizar pull-request n\u00e3o ganhar\u00e1 nota de participa\u00e7\u00e3o individual. Controle de Tarefas e Reposit\u00f3rio \u00b6 Nas discuss\u00f5es com os outros colegas o scrum master deve definir os m\u00f3dulos que cada um do grupo ir\u00e1 desenvolver. Crie uma rotina para commits e pull-request. Sempre teste os m\u00f3dulos e verifique se est\u00e1 fazendo o esperado. Facilitador (Scrum Master) \u00b6 Fazer a atualiza\u00e7\u00e3o do fork com o upstream Organizar o github + issues + project Gerenciar o grupo (atribuir tarefas) Gerenciar os pull-requests Criar relat\u00f3rio da performance de cada um do grupo Entregar/Apresentar o projeto no final Desenvolvedores \u00b6 Realizar as tarefas atribuidas pelo scrum-master Ajudar na entrega final Testar os c\u00f3digos Realizar os pull-requests Arquivos \u00b6 A pasta cont\u00e9m dois diret\u00f3rios distintos : src/ e Quartus/ . O diret\u00f3rio src cont\u00e9m os arquivos fontes que dever\u00e3o ser editados para implementar o projeto. O diret\u00f3rio quartus/ cont\u00e9m o projeto que possibilitar\u00e1 compilar os m\u00f3dulos e testar em hardware. Entendendo o projeto \u00b6 A pasta do projeto C no reposit\u00f3rio Z01.1 possui a seguinte estrutura : /B-LogicaCombinacional testeLogicaCombinacional.py /Quartus /src /rtl *.vhd /tests /tst *.vhd Quartus : Projeto Quartus que faz uso dos arquivos VHDL localizados em src/rtl/*.vhd testeLogicaCombinacional.py : Script em python que possibilita a execu\u00e7\u00e3o dos testes src/rtl/*.vhd : Arquivos VHDL que ser\u00e3o implementado pelo grupo tests/tst/*.vhd : Arquivos VHDL que realizam teste l\u00f3gico nos arquivos do rtl Executando o script de teste \u00b6 Abra o terminal na pasta B-LogicaCombinacional e execute o script python localizado nessa pasta: $ ./testeLogicaCombinacional.py Note No exemplo de teste verificamos que aimplementa\u00e7\u00e3o da nand est\u00e1 errada. Entrega \u00b6 A entrega deve ser feita no ramo master do git. Implementar todos os m\u00f3dulos listados Todos os m\u00f3dulos devem passar nos testes Travis deve estar configurado e funcionando Implementar acionamento do diplay de 7 segmentos e demonstrar na FPGA Note Esses arquivos est\u00e3o localizados em B-LogicaCombinacional/src/rtl/ Tip Utilize o VScode para editar os arquivos vhdl e valide a implementa\u00e7\u00e3o executando o script de testes. Deve-se implementar os seguintes circuitos combinacionais: AND 16 bits Arquivo : And16.vhd Descri\u00e7\u00e3o : And bit a bit entre duas palavras de 16 bits. OR de 16 bits Arquivo : Or16.vhd Descri\u00e7\u00e3o : OR bit a bit entre duas palavras de 16 bits. NOT de 16 bits Arquivo : Not16.vhd Descri\u00e7\u00e3o : NOT bit a bit entre duas palavras de 16 bits. NOR 8 Way Arquivo : Nor8Way.vhd Descri\u00e7\u00e3o : NOR entre 8 bits, resulta em uma \u00fanica sa\u00edda OR 8 Way Arquivo : Or8Way.vhd Descri\u00e7\u00e3o : OR entre 8 bits, resulta em uma \u00fanica sa\u00edda Demultiplexiador de 2 sa\u00eddas Arquivo : DMux2Way.vhd Descri\u00e7\u00e3o : Demultiplexa uma entrada bin\u00e1ria em duas sa\u00eddas. Demultiplexiador de 4 sa\u00eddas Arquivo : DMux4Way.vhd Descri\u00e7\u00e3o : Demultiplexa uma entrada bin\u00e1ria em quatro sa\u00eddas. Demultiplexiador de 8 sa\u00eddas Arquivo : DMux8Way.vhd Descri\u00e7\u00e3o : Demultiplexa uma entrada bin\u00e1ria em oito sa\u00eddas. Multiplexador de duas entradas de 16 bits Arquivo : Mux16.vhd Descri\u00e7\u00e3o : Multiplexa duas entradas de 16 bits para uma de 16 bits. Multiplexador 2 entradas de um bit cada Arquivo : Mux2Way.vhd Descri\u00e7\u00e3o : Multiplexa 2 entradas bin\u00e1rias em uma sa\u00edda bin\u00e1ria Multiplexador 4 entradas de um bit cada Arquivo : Mux4Way.vhd Descri\u00e7\u00e3o : Multiplexa 4 entradas bin\u00e1rias em uma sa\u00edda bin\u00e1ria Multiplexador 8 entradas de um bit cada Arquivo : Mux8Way.vhd Descri\u00e7\u00e3o : Multiplexa 8 entradas bin\u00e1rias em uma sa\u00edda bin\u00e1ria Multiplexador 4 entradas de 16 bits cada Arquivo : Mux4Way16.vhd Descri\u00e7\u00e3o : Multiplexa 4 entradas de 16 bits cada em uma sa\u00edda de 16 bits. Multiplexador 8 entradas de 16 bits cada Arquivo : Mux8Way16.vhd Circuito l\u00f3gico Arquivo : circuito.vhd Descri\u00e7\u00e3o : Primeira quest\u00e3o da lista de exerc\u00edcios \u00c1lgebra Booleana 2 Detector de moedas Arquivo : detectorDeMoedas.vhd Descri\u00e7\u00e3o : Quest\u00e3o do detector de moedas da lista de exerc\u00edcios \u00c1lgebra Booleana 2 Impressora Arquivo : impressora.vhd Descri\u00e7\u00e3o : Quest\u00e3o da impressora da lista de exerc\u00edcios \u00c1lgebra Booleana 2 Display de 7s Arquivo : `sevenSeg.vhd' Descri\u00e7\u00e3o : Quest\u00e3o do display de sete segmentos da lista de exerc\u00edcios \u00c1lgebra Booleana 2 Display 7s Esse item \u00e9 uma continua\u00e7\u00e3o do que foi realizado no Lab4 , onde voc\u00eas tiveram que exibir um valor constante no display de 7s. Para cada segmento do display, voc\u00eas devem encontrar uma equa\u00e7\u00e3o booleana que o represente, e ent\u00e3o implementar em VHDL e testar na FPGA. V\u00eddeo O grupo deve apresentar um v\u00eddeo da FPGA mostrando nos display de 7 segmentos o seguinte: (C) O valor em hexadecimal da palavra bin\u00e1ria formada pelas chaves SW(3 .. 0) (C) O valor em hexadecimal da palavra bin\u00e1ria formada pelas chaves SW(9 .. 0) (B) O valor em decimal da palavra bin\u00e1ria formada pelas chaves SW(9 .. 0) Rubricas para avalia\u00e7\u00e3o do projeto \u00b6 Cada integrante do grupo ir\u00e1 receber duas notas: Uma referente ao desenvolvimento total do projeto (Projeto) e outra referente a sua participa\u00e7\u00e3o individual no grupo. Grupo \u00b6 Para atingir os objetivos A e B, deve-se antes atingir o C. Conceito Descritivo A Exibe tr\u00eas d\u00edgitos em Decimal na FPGA B Exibe tr\u00eas d\u00edgitos em Hexadecimal na FPGA (exibir at\u00e9 o valor 0x3FF = 2^10 - 1) C Ter criado o project no github O travis configurado e funcionando Todos os m\u00f3dulos implementados e funcionado Implementando um \u00fanico display de 7s (conta at\u00e9 16 em hexadecimal) D At\u00e9 dois M\u00f3dulos com falha/ n\u00e3o apresentou o v\u00eddeo da FPGA I Mais de tr\u00eas m\u00f3dulos com falha Individual \u00b6 As rubricas a serem seguidas ser\u00e3o comuns a todos os projeto e est\u00e1 descrito no link: Rubricas Scrum e Desenvolvedor","title":"B - L\u00f3gica Combinacional"},{"location":"LogiComb-Projeto/#b-logica-combinacional","text":"Scrum Master Voc\u00ea \u00e9 Scrum Master e n\u00e3o sabe por onde come\u00e7ar? De uma olhada nessas dicas: Vixi! Sou Scrum Master Esse projeto tem como objetivo trabalhar com portas l\u00f3gicas e sistemas digitais combinacionais (sem um clock) em FPGA e VHDL. Os elementos l\u00f3gicos desenvolvidos nessa etapa ser\u00e3o utilizados como elementos b\u00e1sicos para a constru\u00e7\u00e3o do computador.","title":"B - L\u00f3gica Combinacional"},{"location":"LogiComb-Projeto/#instrucoes","text":"O desenvolvimento ser\u00e1 na linguagem VHDL, o grupo deve se organizar para implementar todos os elementos propostos. O facilitador escolhido ser\u00e1 respons\u00e1vel pela completude e consist\u00eancia do branch master do grupo.","title":"Instru\u00e7\u00f5es"},{"location":"LogiComb-Projeto/#integrantes","text":"Tarefas devem ser criadas no Issues e atribu\u00eddas aos demais colegas. As tarefas devem ser resolvidas individualmente! Utilize a ajuda de seus colegas, mas resolva o que foi atribu\u00eddo a voc\u00eas, essa \u00e9 sua tarefa/ responsabilidade! Warning Este projeto \u00e9 para ser realizado por todos os integrantes do grupo em seus pr\u00f3prios computadores, quem n\u00e3o participar, n\u00e3o implementar os m\u00f3dulos que foram atribu\u00eddos, ou n\u00e3o realizar pull-request n\u00e3o ganhar\u00e1 nota de participa\u00e7\u00e3o individual.","title":"Integrantes"},{"location":"LogiComb-Projeto/#controle-de-tarefas-e-repositorio","text":"Nas discuss\u00f5es com os outros colegas o scrum master deve definir os m\u00f3dulos que cada um do grupo ir\u00e1 desenvolver. Crie uma rotina para commits e pull-request. Sempre teste os m\u00f3dulos e verifique se est\u00e1 fazendo o esperado.","title":"Controle de Tarefas e Reposit\u00f3rio"},{"location":"LogiComb-Projeto/#facilitador-scrum-master","text":"Fazer a atualiza\u00e7\u00e3o do fork com o upstream Organizar o github + issues + project Gerenciar o grupo (atribuir tarefas) Gerenciar os pull-requests Criar relat\u00f3rio da performance de cada um do grupo Entregar/Apresentar o projeto no final","title":"Facilitador (Scrum Master)"},{"location":"LogiComb-Projeto/#desenvolvedores","text":"Realizar as tarefas atribuidas pelo scrum-master Ajudar na entrega final Testar os c\u00f3digos Realizar os pull-requests","title":"Desenvolvedores"},{"location":"LogiComb-Projeto/#arquivos","text":"A pasta cont\u00e9m dois diret\u00f3rios distintos : src/ e Quartus/ . O diret\u00f3rio src cont\u00e9m os arquivos fontes que dever\u00e3o ser editados para implementar o projeto. O diret\u00f3rio quartus/ cont\u00e9m o projeto que possibilitar\u00e1 compilar os m\u00f3dulos e testar em hardware.","title":"Arquivos"},{"location":"LogiComb-Projeto/#entendendo-o-projeto","text":"A pasta do projeto C no reposit\u00f3rio Z01.1 possui a seguinte estrutura : /B-LogicaCombinacional testeLogicaCombinacional.py /Quartus /src /rtl *.vhd /tests /tst *.vhd Quartus : Projeto Quartus que faz uso dos arquivos VHDL localizados em src/rtl/*.vhd testeLogicaCombinacional.py : Script em python que possibilita a execu\u00e7\u00e3o dos testes src/rtl/*.vhd : Arquivos VHDL que ser\u00e3o implementado pelo grupo tests/tst/*.vhd : Arquivos VHDL que realizam teste l\u00f3gico nos arquivos do rtl","title":"Entendendo o projeto"},{"location":"LogiComb-Projeto/#executando-o-script-de-teste","text":"Abra o terminal na pasta B-LogicaCombinacional e execute o script python localizado nessa pasta: $ ./testeLogicaCombinacional.py Note No exemplo de teste verificamos que aimplementa\u00e7\u00e3o da nand est\u00e1 errada.","title":"Executando o script de teste"},{"location":"LogiComb-Projeto/#entrega","text":"A entrega deve ser feita no ramo master do git. Implementar todos os m\u00f3dulos listados Todos os m\u00f3dulos devem passar nos testes Travis deve estar configurado e funcionando Implementar acionamento do diplay de 7 segmentos e demonstrar na FPGA Note Esses arquivos est\u00e3o localizados em B-LogicaCombinacional/src/rtl/ Tip Utilize o VScode para editar os arquivos vhdl e valide a implementa\u00e7\u00e3o executando o script de testes. Deve-se implementar os seguintes circuitos combinacionais: AND 16 bits Arquivo : And16.vhd Descri\u00e7\u00e3o : And bit a bit entre duas palavras de 16 bits. OR de 16 bits Arquivo : Or16.vhd Descri\u00e7\u00e3o : OR bit a bit entre duas palavras de 16 bits. NOT de 16 bits Arquivo : Not16.vhd Descri\u00e7\u00e3o : NOT bit a bit entre duas palavras de 16 bits. NOR 8 Way Arquivo : Nor8Way.vhd Descri\u00e7\u00e3o : NOR entre 8 bits, resulta em uma \u00fanica sa\u00edda OR 8 Way Arquivo : Or8Way.vhd Descri\u00e7\u00e3o : OR entre 8 bits, resulta em uma \u00fanica sa\u00edda Demultiplexiador de 2 sa\u00eddas Arquivo : DMux2Way.vhd Descri\u00e7\u00e3o : Demultiplexa uma entrada bin\u00e1ria em duas sa\u00eddas. Demultiplexiador de 4 sa\u00eddas Arquivo : DMux4Way.vhd Descri\u00e7\u00e3o : Demultiplexa uma entrada bin\u00e1ria em quatro sa\u00eddas. Demultiplexiador de 8 sa\u00eddas Arquivo : DMux8Way.vhd Descri\u00e7\u00e3o : Demultiplexa uma entrada bin\u00e1ria em oito sa\u00eddas. Multiplexador de duas entradas de 16 bits Arquivo : Mux16.vhd Descri\u00e7\u00e3o : Multiplexa duas entradas de 16 bits para uma de 16 bits. Multiplexador 2 entradas de um bit cada Arquivo : Mux2Way.vhd Descri\u00e7\u00e3o : Multiplexa 2 entradas bin\u00e1rias em uma sa\u00edda bin\u00e1ria Multiplexador 4 entradas de um bit cada Arquivo : Mux4Way.vhd Descri\u00e7\u00e3o : Multiplexa 4 entradas bin\u00e1rias em uma sa\u00edda bin\u00e1ria Multiplexador 8 entradas de um bit cada Arquivo : Mux8Way.vhd Descri\u00e7\u00e3o : Multiplexa 8 entradas bin\u00e1rias em uma sa\u00edda bin\u00e1ria Multiplexador 4 entradas de 16 bits cada Arquivo : Mux4Way16.vhd Descri\u00e7\u00e3o : Multiplexa 4 entradas de 16 bits cada em uma sa\u00edda de 16 bits. Multiplexador 8 entradas de 16 bits cada Arquivo : Mux8Way16.vhd Circuito l\u00f3gico Arquivo : circuito.vhd Descri\u00e7\u00e3o : Primeira quest\u00e3o da lista de exerc\u00edcios \u00c1lgebra Booleana 2 Detector de moedas Arquivo : detectorDeMoedas.vhd Descri\u00e7\u00e3o : Quest\u00e3o do detector de moedas da lista de exerc\u00edcios \u00c1lgebra Booleana 2 Impressora Arquivo : impressora.vhd Descri\u00e7\u00e3o : Quest\u00e3o da impressora da lista de exerc\u00edcios \u00c1lgebra Booleana 2 Display de 7s Arquivo : `sevenSeg.vhd' Descri\u00e7\u00e3o : Quest\u00e3o do display de sete segmentos da lista de exerc\u00edcios \u00c1lgebra Booleana 2 Display 7s Esse item \u00e9 uma continua\u00e7\u00e3o do que foi realizado no Lab4 , onde voc\u00eas tiveram que exibir um valor constante no display de 7s. Para cada segmento do display, voc\u00eas devem encontrar uma equa\u00e7\u00e3o booleana que o represente, e ent\u00e3o implementar em VHDL e testar na FPGA. V\u00eddeo O grupo deve apresentar um v\u00eddeo da FPGA mostrando nos display de 7 segmentos o seguinte: (C) O valor em hexadecimal da palavra bin\u00e1ria formada pelas chaves SW(3 .. 0) (C) O valor em hexadecimal da palavra bin\u00e1ria formada pelas chaves SW(9 .. 0) (B) O valor em decimal da palavra bin\u00e1ria formada pelas chaves SW(9 .. 0)","title":"Entrega"},{"location":"LogiComb-Projeto/#rubricas-para-avaliacao-do-projeto","text":"Cada integrante do grupo ir\u00e1 receber duas notas: Uma referente ao desenvolvimento total do projeto (Projeto) e outra referente a sua participa\u00e7\u00e3o individual no grupo.","title":"Rubricas para avalia\u00e7\u00e3o do projeto"},{"location":"LogiComb-Projeto/#grupo","text":"Para atingir os objetivos A e B, deve-se antes atingir o C. Conceito Descritivo A Exibe tr\u00eas d\u00edgitos em Decimal na FPGA B Exibe tr\u00eas d\u00edgitos em Hexadecimal na FPGA (exibir at\u00e9 o valor 0x3FF = 2^10 - 1) C Ter criado o project no github O travis configurado e funcionando Todos os m\u00f3dulos implementados e funcionado Implementando um \u00fanico display de 7s (conta at\u00e9 16 em hexadecimal) D At\u00e9 dois M\u00f3dulos com falha/ n\u00e3o apresentou o v\u00eddeo da FPGA I Mais de tr\u00eas m\u00f3dulos com falha","title":"Grupo"},{"location":"LogiComb-Projeto/#individual","text":"As rubricas a serem seguidas ser\u00e3o comuns a todos os projeto e est\u00e1 descrito no link: Rubricas Scrum e Desenvolvedor","title":"Individual"},{"location":"Sobre-Criterios-de-Avaliacao/","text":"Descri\u00e7\u00e3o \u00b6 Ao longo do semestre ser\u00e3o utilizados os seguintes crit\u00e9rios de avalia\u00e7\u00e3o: Provas \u00b6 Ao longo do semestre o aluno deve acumular 60 pontos de Software e 60 pontos de Hardware esses pontos estar\u00e3o distribu\u00eddos nas quatro provas (P1,P2,P3,P4) que ser\u00e3o aplicadas ao longo do semestre. Projetos / APS \u00b6 O projeto \u00e9 composto por duas notas: Grupo e Individual sendo que cada uma segue uma rubrica diferente e avalia objetivo diferentes do curso. Crit\u00e9rios \u00b6 Os alunos devem: Ter acumulado 60 pontos de HW nas provas Ter acumulado 60 pontos de SW nas provas Ter no m\u00ednimo conceito C no quesito Grupo em todos os Projetos. Ter ate duas notas inferiores a C na avalia\u00e7\u00e3o individual do projeto ( Individual ). Uma vez que os crit\u00e9rios foram atingidos: Projeto \u00b6 A nota de projeto \u00e9 constitu\u00edda por todas as notas de APS de projetos sendo o conceito final definido por: A: 9 das APS de projetos com nota A e as demais com nota superior a C e nenhuma contribui\u00e7\u00e3o individual negativa nos projetos. B: 8 das APS de projetos com nota igual ou superior a B e as demais com nota igual ou superior a C e apenas uma contribui\u00e7\u00e3o negativa nos projetos. C: 12 das APS de projetos com nota igual ou superior a C e at\u00e9 duas contribui\u00e7\u00f5es negativas. D: At\u00e9 uma nota abaixo de C nas APS de projetos ou mais de duas contribui\u00e7\u00f5es negativas. I: At\u00e9 quatro notas abaixo de C nas APS de projetos ou mais que seis contribui\u00e7\u00f5es negativas. Nota final \u00b6 A nota final ser\u00e1 composta pela nota de Projeto e a nota da Prova: Nota Final = mean([HW, SW, Projeto])","title":"Crit\u00e9rios de Avalia\u00e7\u00e3o"},{"location":"Sobre-Criterios-de-Avaliacao/#descricao","text":"Ao longo do semestre ser\u00e3o utilizados os seguintes crit\u00e9rios de avalia\u00e7\u00e3o:","title":"Descri\u00e7\u00e3o"},{"location":"Sobre-Criterios-de-Avaliacao/#provas","text":"Ao longo do semestre o aluno deve acumular 60 pontos de Software e 60 pontos de Hardware esses pontos estar\u00e3o distribu\u00eddos nas quatro provas (P1,P2,P3,P4) que ser\u00e3o aplicadas ao longo do semestre.","title":"Provas"},{"location":"Sobre-Criterios-de-Avaliacao/#projetos-aps","text":"O projeto \u00e9 composto por duas notas: Grupo e Individual sendo que cada uma segue uma rubrica diferente e avalia objetivo diferentes do curso.","title":"Projetos / APS"},{"location":"Sobre-Criterios-de-Avaliacao/#criterios","text":"Os alunos devem: Ter acumulado 60 pontos de HW nas provas Ter acumulado 60 pontos de SW nas provas Ter no m\u00ednimo conceito C no quesito Grupo em todos os Projetos. Ter ate duas notas inferiores a C na avalia\u00e7\u00e3o individual do projeto ( Individual ). Uma vez que os crit\u00e9rios foram atingidos:","title":"Crit\u00e9rios"},{"location":"Sobre-Criterios-de-Avaliacao/#projeto","text":"A nota de projeto \u00e9 constitu\u00edda por todas as notas de APS de projetos sendo o conceito final definido por: A: 9 das APS de projetos com nota A e as demais com nota superior a C e nenhuma contribui\u00e7\u00e3o individual negativa nos projetos. B: 8 das APS de projetos com nota igual ou superior a B e as demais com nota igual ou superior a C e apenas uma contribui\u00e7\u00e3o negativa nos projetos. C: 12 das APS de projetos com nota igual ou superior a C e at\u00e9 duas contribui\u00e7\u00f5es negativas. D: At\u00e9 uma nota abaixo de C nas APS de projetos ou mais de duas contribui\u00e7\u00f5es negativas. I: At\u00e9 quatro notas abaixo de C nas APS de projetos ou mais que seis contribui\u00e7\u00f5es negativas.","title":"Projeto"},{"location":"Sobre-Criterios-de-Avaliacao/#nota-final","text":"A nota final ser\u00e1 composta pela nota de Projeto e a nota da Prova: Nota Final = mean([HW, SW, Projeto])","title":"Nota final"},{"location":"Sobre-Objetivos-de-Aprendizagem/","text":"Ao final da disciplina o estudante ser\u00e1 capaz de: Implementar um computador digital simples a partir de componentes eletr\u00f4nicos. Integrar as camadas de programa\u00e7\u00e3o e execu\u00e7\u00e3o de um computador simples. Trabalhar de forma colaborativa no desenvolvimento de um sistema computacional. Compreender a evolu\u00e7\u00e3o da inform\u00e1tica. Descrever como dados e instru\u00e7\u00f5es s\u00e3o armazenados e tratados em computadores. Conte\u00fado Program\u00e1tico: L\u00f3gica Combinacional Unidade L\u00f3gica Aritm\u00e9tica L\u00f3gica Sequencial L\u00f3gica de Controle Linguagem de M\u00e1quinas Assembly Assembler M\u00e1quina Virtual Controle de programa Linguagem Orientada a Objetos An\u00e1lise L\u00e9xica e Sint\u00e1tica Linguagens","title":"Sobre Objetivos de Aprendizagem"},{"location":"Sobre-Rubricas/","text":"Rubricas individuais - Corona \u00b6 Tip Atualizado devido ao corona. Tip S\u00f3 come\u00e7a a valer a partir do pr\u00f3ximo projeto (D-L\u00f3gica-Sequencial). Facilitador \u00b6 O facilitador ser\u00e1 avaliado pelos 'Desenvolvedores' com base em seus objetivos: Fez a manuten\u00e7\u00e3o do Kanban board (GitHub project). Ex: cria cards, atribui tarefas, da feedback de inssues. Gerenciou os pull-requests. Acompanhou o desenvolvimento do grupo, dando o suporte sempre que necess\u00e1rio Ajudou outros colegas com o objetivo da entrega final e n\u00e3o somente das suas tarefas A nota final ser\u00e1 a m\u00e9dia das notas de cada 'Desenvolvedor' vezes Fator de participa\u00e7\u00e3o em aula (1, 0.5, 0). Fator de Participa\u00e7\u00e3o em aula: 1: Esteve presente e participou nas aulas referentes aos projetos 0.6: Faltou e/ou n\u00e3o participou de alguma aula referente ao projeto 0: Faltou e/ou n\u00e3o participou da maioria das aulas do projeto Warning Se algum facilitador n\u00e3o preencher o formul\u00e1rio no prazo estipulado sua nota ser\u00e1 D/I Desenvolvedor \u00b6 Se o facilitador tiver m\u00e9dia maior que C , a nota dos desenvolvedores ser\u00e1 dada pelo facilitador com base em seus objetivos: Participou das aulas referentes ao projetos (handouts, labs) Desenvolveu as rotinas atribu\u00eddas pelo Facilitador para passarem nos testes! Submeteu altera\u00e7\u00f5es por pull requests. Acompanhou o desenvolvimento do grupo, dando o suporte sempre que necess\u00e1rio Entregas orientadas para o objetivo do projeto A nota final ser\u00e1 a nota do 'Facilitador' vezes Fator de participa\u00e7\u00e3o em aula (1, 0.75, 0.5). Fator de Participa\u00e7\u00e3o em aula: 1: Esteve presente e participou nas aulas referentes aos projetos 0.75: Faltou e/ou n\u00e3o participou de alguma aula referente ao projeto 0.5: Faltou e/ou n\u00e3o participou da maioria das aulas do projeto Caso a nota do Facilitador seja inferior a C, a nota dos desenvolvedores se dar\u00e1 pela m\u00e9dia da avalia\u00e7\u00e3o dos seus colegas. Warning Se algum desenvolvedor n\u00e3o preencher o formul\u00e1rio no prazo estipulado sua nota ser\u00e1 D/I","title":"Rubricas Projetos"},{"location":"Sobre-Rubricas/#rubricas-individuais-corona","text":"Tip Atualizado devido ao corona. Tip S\u00f3 come\u00e7a a valer a partir do pr\u00f3ximo projeto (D-L\u00f3gica-Sequencial).","title":"Rubricas individuais - Corona"},{"location":"Sobre-Rubricas/#facilitador","text":"O facilitador ser\u00e1 avaliado pelos 'Desenvolvedores' com base em seus objetivos: Fez a manuten\u00e7\u00e3o do Kanban board (GitHub project). Ex: cria cards, atribui tarefas, da feedback de inssues. Gerenciou os pull-requests. Acompanhou o desenvolvimento do grupo, dando o suporte sempre que necess\u00e1rio Ajudou outros colegas com o objetivo da entrega final e n\u00e3o somente das suas tarefas A nota final ser\u00e1 a m\u00e9dia das notas de cada 'Desenvolvedor' vezes Fator de participa\u00e7\u00e3o em aula (1, 0.5, 0). Fator de Participa\u00e7\u00e3o em aula: 1: Esteve presente e participou nas aulas referentes aos projetos 0.6: Faltou e/ou n\u00e3o participou de alguma aula referente ao projeto 0: Faltou e/ou n\u00e3o participou da maioria das aulas do projeto Warning Se algum facilitador n\u00e3o preencher o formul\u00e1rio no prazo estipulado sua nota ser\u00e1 D/I","title":"Facilitador"},{"location":"Sobre-Rubricas/#desenvolvedor","text":"Se o facilitador tiver m\u00e9dia maior que C , a nota dos desenvolvedores ser\u00e1 dada pelo facilitador com base em seus objetivos: Participou das aulas referentes ao projetos (handouts, labs) Desenvolveu as rotinas atribu\u00eddas pelo Facilitador para passarem nos testes! Submeteu altera\u00e7\u00f5es por pull requests. Acompanhou o desenvolvimento do grupo, dando o suporte sempre que necess\u00e1rio Entregas orientadas para o objetivo do projeto A nota final ser\u00e1 a nota do 'Facilitador' vezes Fator de participa\u00e7\u00e3o em aula (1, 0.75, 0.5). Fator de Participa\u00e7\u00e3o em aula: 1: Esteve presente e participou nas aulas referentes aos projetos 0.75: Faltou e/ou n\u00e3o participou de alguma aula referente ao projeto 0.5: Faltou e/ou n\u00e3o participou da maioria das aulas do projeto Caso a nota do Facilitador seja inferior a C, a nota dos desenvolvedores se dar\u00e1 pela m\u00e9dia da avalia\u00e7\u00e3o dos seus colegas. Warning Se algum desenvolvedor n\u00e3o preencher o formul\u00e1rio no prazo estipulado sua nota ser\u00e1 D/I","title":"Desenvolvedor"},{"location":"Teoria-Algebra-Booleana/","text":"\u00c1lgebra Booleana \u00b6 Estudando Bibliografia [Cap1. Cap2. NISAN, 2005] [Cap6. TOCCI, 2011] [Cap1. FLOYD, 2007] [LAING, 2004] V\u00eddeos (extra) Logic 101 (#11): Truth Tables Logic 101 (#12): Truth Table Practice Computer Science: Karnaugh Maps \u2013 Introduction Computer Science: Karnaugh Maps - 4 vars A \u00e1lgebra booleana foi desenvolvida por George Boole , um matem\u00e1tico brit\u00e2nico que desenvolveu os conceitos em 1847, base da computa\u00e7\u00e3o moderna. Muito tempo depois, nos anos 30, Claude Shannon, um importante engenheiro na hist\u00f3ria da computa\u00e7\u00e3o moderna, aplicou as ideias de Boole em circuitos el\u00e9tricos. Ele trabalhava no Analisador Diferencial de Vannevar Bush, e logo percebeu a rela\u00e7\u00e3o dos rel\u00e9s com \u00e1lgebra booleana. Ele fazia um rel\u00e9 acionar o outro usando usando uma l\u00f3gica bin\u00e1ria do rel\u00e9 fechado ou aberto. Sua disserta\u00e7\u00e3o e artigos, levaram outras pessoas a perceber os benef\u00edcios da \u00e1lgebra booleana em eletr\u00f4nica e consequentemente computa\u00e7\u00e3o. Em \u00c1lgebra Booleana as vari\u00e1veis s\u00f3 podem assumir dois valores. Desligado e ligado, ou falso e verdadeiro, 0 volt e 5 volts, branco e preto. Por\u00e9m normalmente na computa\u00e7\u00e3o usamos 0 e 1 pela conveni\u00eancia. Todos os computadores tem como sua menor unidade de dado, esse elemento. Em computa\u00e7\u00e3o chamamos isso de bit. que vem de d\u00edgito bin\u00e1rio (ou do ingl\u00eas binary digit). Note Bit \u00e9 a unidade mais simples de representa\u00e7\u00e3o de dados digitais, um bit \u00e9 uma unidade que pode assumir apenas dois valores: 0 ou 1 . Com um bit podemos representar o estado de uma luz na sala de aula, se uma cadeira est\u00e1 vazio ou n\u00e3o, .... n\u00e3o conseguimos representar com apenas um bit uma informa\u00e7\u00e3o que n\u00e3o seja bin\u00e1ria. Mas se combinarmos mais de um bit, criando um vetor de bits, somos capazes de representar quantos estados desejarmos. Equa\u00e7\u00f5es \u00b6 Uma equa\u00e7\u00e3o de l\u00f3gica booleana pode possuir uma ou mais 'entradas' e apenas uma sa\u00edda, na equa\u00e7\u00e3o exemplo a seguir, X \u00e9 uma sa\u00edda (e pode assumir apenas valor 1 ou 0 ) e A e B s\u00e3o entradas tamb\u00e9m do tipo bin\u00e1ria. X(A,B) = A ^ B Note A opera\u00e7\u00e3o ^ \u00e9 chamada de E ( and ) que tamb\u00e9m pode ser representada pelo simbolo de multiplica\u00e7\u00e3o escalar . X = A and B X = A . B A opera\u00e7\u00e3o de and pode ser entendida como uma multiplica\u00e7\u00e3o: A sa\u00edda ( X ) s\u00f3 \u00e9 verdadeira se as entradas A e B forem verdadeiras: 1 . 1 = 1 . Como A e B s\u00e3o n\u00fameros bin\u00e1rios, \u00e9 poss\u00edvel encontrar uma tabela que relaciona o valor da sa\u00edda X com as poss\u00edveis entradas de A e B Entrada A Entrada B Sa\u00edda X 0 0 0 0 1 0 1 0 0 1 1 1 Tabela Verdade Essa tabela que acabamos de construir chama tabela verdade, e ser\u00e1 muito utilizada ao longo do curso. Podemos representar essa equa\u00e7\u00e3o X = A ^ B como sendo um circuito digital, como ilustrado a seguir: Note Resolver fun\u00e7\u00f5es booleanas \u00e9 entender quando a sa\u00edda ser\u00e1 Verdadeira ou Falsa dado a combina\u00e7\u00e3o poss\u00edvel de entradas. Opera\u00e7\u00f5es \u00b6 O and utilizado no exemplo anterior \u00e9 um operador da l\u00f3gica booleana, operadores possuem uma ou mais entradas e geram uma sa\u00edda. Os operadores mais comuns s\u00e3o: not , and , or , nand , nor , xor . not, and, or, nor \u00b6 not O operador not atua sobre uma vari\u00e1vel, tornando a sa\u00edda o inverso da entrada, ou seja, se a entrada do operador for 1 sua sa\u00edda ser\u00e1 0 e vice versa. Uso: a luz interna do carro ser\u00e1 acesa ('1') quando a porta estiver fechada ('0'). Nota\u00e7\u00e3o: not , - , ~ , \u00ac _ X = not A / X = A / X = \u00c3 / X = \u00ac A Tabela Verdade Entrada A X = not A 0 1 1 0 Simbologia and O operador and atua sobre duas vari\u00e1vel, tornando a sa\u00edda verdadeira somente se as duas entradas forem verdadeiras , se uma das entradas forem falsa a sa\u00edda ser\u00e1 falsa . Uso: o cofre ser\u00e1 aberto somente quando as duas chaves de seguran\u00e7as forem inseridas. Nota\u00e7\u00e3o: and , . , ^ X = A and B / X = A . B / X = A ^ B Tabela Verdade A B X = A and B 0 0 0 0 1 0 1 0 0 1 1 1 Simbologia or O operador or atua sobre duas vari\u00e1vel, tornando a sa\u00edda verdadeira sempre que uma das entradas forem verdadeira . Uso: O alarme de inc\u00eandio ser\u00e1 acionado caso alguns dois dois bot\u00f5es sejam pressionados. Nota\u00e7\u00e3o: or , + , v X = A or B / X = A + B / X = A v B Tabela Verdade A B X = A or B 0 0 0 0 1 1 1 0 1 1 1 1 Simbologia nand Podemos come\u00e7ar a 'unir' operadores para formar novos comportamentos, o nand \u00e9 a invers\u00e3o ( not ) da porta l\u00f3gica and . Na porta nand a sa\u00edda s\u00f3 \u00e9 verdadeira quando as entradas s\u00e3o falsas . Uso: Soar o alarme se os sensores de batimento card\u00edaco e o de press\u00e3o falharem. Nota\u00e7\u00e3o: nand , \u00ac( \u2227 ) _____ X = A nand B / X = A . B / X = \u00ac(A \u2227 B) Tabela Verdade A B X = A nand B 0 0 1 0 1 1 1 0 1 1 1 0 Simbologia nor / xor / xnor Para as demais portas l\u00f3gicas, consulte a refer\u00eancia: https://en.wikipedia.org/wiki/Logic_gate#Symbols Check-Point \ufeffL\u00f3gica booleana 1 Quest\u00f5es b\u00e1sicas O que \u00e9 correto afirmar sobre bits? 1 AND 0 Se aplicarmos as entradas 1 e 0 a porta, a sa\u00edda ser\u00e1: 1 OR 0 Se aplicarmos as entradas 1 e 0 a porta, a sa\u00edda ser\u00e1: Tabela Verdade \u00b6 Nessa tabela criamos colunas para cada vari\u00e1vel de entrada e de sa\u00edda e colocamos as situa\u00e7\u00f5es poss\u00edveis (resultado). Para construirmos uma tabela verdade basta seguir as regras a seguir (na sequ\u00eancia): Criar uma coluna para cada entrada do sistema (n) Criar uma coluna para cada sa\u00edda do sistema A tabela verdade vai ter 2^n n\u00fameros de linhas (onde n \u00e9 a quantidade de entradas) um sistema com 2 entradas possui 2\u00b2 = 4 linhas um sistema com 3 entradas possui 2\u00b3 = 8 linhas ... Preencher as entradas (com '1's e '0's ) de forma a cobrir todas as possibilidades. Para cada linha, analisar se a combina\u00e7\u00e3o de '1's e '0' torna a sa\u00edda '1' e '0' Check-Point L\u00f3gica booleana - Tabela Verdade Responda sobre tabela verdade \u00c9 correto afirmar sobre a tabela verdade: (pode existir mais de um item correto) Considerando um circuito de 4 entradas (A,B, C, D) quantas s\u00e3o as linhas da tabela verdade? \ufeffQual tabela verdade a seguir foi montada correta? Considerando a equa\u00e7\u00e3o: X = not(B) + A , e a tabela verdade da imagem, qual resposta est\u00e1 correta (na sequ\u00eancia da tabela)? Resposta na sequ\u00eancia: X0; X1; X2; X3 Fun\u00e7\u00f5es geradas a partir de Tabelas Verdade \u00b6 \u00c9 poss\u00edvel a partir de uma tabela verdade obter uma equa\u00e7\u00e3o l\u00f3gica que a represente (caminho inverso), podemos fazer isso por duas t\u00e9cnicas diferentes (chamadas de forma can\u00f4nicas): Soma dos Produtos (SoP) Produto das Somas (PoS) Soma Dos Produtos \u00b6 Na soma dos produtos iremos encontrar uma equa\u00e7\u00e3o booleana que possui a seguinte forma: X = ( . . . ) + ( . . . ) + ... + ( . . . ) ----- | | = '1' Nesse m\u00e9todo, precisamos encontrar as linhas da tabela verdade que resultam em uma sa\u00edda '1' (Verdadeira) e invertendo (ou n\u00e3o) as entras fazendo com que o termo ( . . . .) resulte em '1' para a linha em quest\u00e3o. Produto das somas \u00b6 X = ( + + + ) . ( + + + ) . ... . ( + + + ) ----- | | = '0' Nesse m\u00e9todo, precisamos encontrar as linhas da tabela verdade que resultam em uma sa\u00edda '0' e invertendo (ou n\u00e3o) as entras gazer com que o termo ( . . . .) resulte em '0' para a linha em quest\u00e3o. Example Check-Point \ufeffL\u00f3gica Booleana - Equa\u00e7\u00f5es Can\u00f4nicas Encontre a equa\u00e7\u00e3o correta dada a tabela verdade ou vice versa \ufeffQual forma \u00e9 a mais adequada? \ufeffQual forma \u00e9 a mais adequada? Qual equa\u00e7\u00e3o representa a tabela verdade? Qual equa\u00e7\u00e3o representa a tabela verdade? Quiz Maker - powered by Riddle Simplifica\u00e7\u00e3o \u00b6 Existem duas formas bastante populares de simplificar uma equa\u00e7\u00e3o booleana: alg\u00e9brica ou via mapa de Karnaugh. Veremos as duas com mais detalhes. Simplifica\u00e7\u00e3o alg\u00e9brica \u00b6 Na simplifica\u00e7\u00e3o alg\u00e9brica iremos utilizar as seguintes propriedades de l\u00f3gica booleana para nos ajudar a simplificar uma equa\u00e7\u00e3o: Propriedade Opera\u00e7\u00e3o Lei da Identidade A = A \\bar{A} = \\bar{A} \\bar{A} = \\bar{A} Lei da Comutatividade A . B = B . A A + B = B + A Lei da Associatividade A . (B . C) = A B C A + (B + C) = A + B + C Lei da Idempot\u00eancia A . A = A A + A = A Lei do Complemento Duplo \\overline{\\overline{A}} = A \\overline{\\overline{A}} = A Lei da Complementariedade A \\, \\overline{A} = 0 A \\, \\overline{A} = 0 A + \\overline{A} = 1 A + \\overline{A} = 1 Lei da Intersec\u00e7\u00e3o A . 1 = A A . 0 = 0 Lei da Uni\u00e3o A + 1 = 1 A + 0 = A Lei da Distributividade A . (B + C) = (A . B) + (A . C) A + (B . C) = (A + B) (A + C) Teorema de DeMorgan \\overline{A \\, B} = \\bar{A} + \\bar{B} \\overline{A \\, B} = \\bar{A} + \\bar{B} \\overline{A + B} = \\bar{A} \\, \\bar{B} \\overline{A + B} = \\bar{A} \\, \\bar{B} Explica\u00e7\u00e3o da tabela Para essas simplifica\u00e7\u00f5es n\u00f3s usaremos as propriedades das opera\u00e7\u00f5es b\u00e1sicas de \u00e1lgebra booleana, representada na tabela anterior. As leis da identidade, comutatividade, associatividade e distributividade s\u00e3o bem similares ao que j\u00e1 fazemos normalmente em express\u00f5es matem\u00e1ticas. A idempot\u00eancia mostra que um AND ou OR com duas vari\u00e1veis \u00e9 exatamente a mesma vari\u00e1vel. A lei do complemento duplo mostra que se negarmos duas vezes uma vari\u00e1vel, teremos a mesma vari\u00e1vel. A lei da complementariedade j\u00e1 mostra que fazermos um AND com a nega\u00e7\u00e3o da mesma vari\u00e1vel acabaremos com zero, ou seja, 0 vezes 1 ou 1 vezes 0 sempre dar\u00e1 zero. J\u00e1 com o OR \u00e9 o oposto e sempre teremos 1 como resposta. Na lei da interse\u00e7\u00e3o temos que uma vari\u00e1vel vezes 1 \u00e9 sempre ela mesma, e se for vezes 0, acabara zerando o resultado. J\u00e1 a lei da uni\u00e3o diz que uma vari\u00e1vel mais um \u00e9 sempre um, e uma vari\u00e1vel mais zero \u00e9 a pr\u00f3pria vari\u00e1vel. O teorema de DeMorgam \u00e9 bem interessante, pois mostra uma propriedade bem peculiar da \u00e1lgebra booleana, no caso o conjunto de A vezes B negado, \u00e9 o mesmo que A negado, mais B negado, e da mesma forma A negado mais B negado \u00e9 igual ao A vezes B, e esse resultado negado. Para simplificarmos uma equa\u00e7\u00e3o, aplicamos as propriedades da tabela anterior a fim de encontrarmos uma equa\u00e7\u00e3o que: Tenha uma forma mais explicita de sua propriedade exe: A . B + A . C A . B + A . C -> A (B + C) A (B + C) Minimize o uso de 'portas l\u00f3gicas' exe: (A . B) . C + A . B . D (A . B) . C + A . B . D -> (A . B)(C + D) (A . B)(C + D) Elimine minimize as entradas necess\u00e1rias exe: (A \\overline{A}.B) (A \\overline{A}.B) -> B B Exemplos \u00b6 Exemplo 1 Exemplo 2 Exemplo 3 Tip O v\u00eddeo a seguir possui as resolu\u00e7\u00f5es de forma detalhada: Mapa de Karnaugh (MK) \u00b6 A simplifica\u00e7\u00e3o por mapa de Karnaugh \u00e9 uma t\u00e9cnica visual de encontrarmos uma equa\u00e7\u00e3o reduzida, por\u00e9m para isso precisamos primeiro: Gerar a tabela verdade Gerar o mapa de Karnaugh Criar os grupos Gerar as equa\u00e7\u00f5es 2. Criando o Mapa \u00b6 O mapa pode ser criado para N entradas, mas s\u00f3 iremos tratar nesse curso sistemas de 2 , 3 ou 4 vari\u00e1veis (entradas). A seguir exemplos do mapa para 2, 3 e 4 entradas: Para criar o mapa basta seguir a receitinha anterior, note que a sequ\u00eancia das entras: AB e CD \u00e9 da forma: __ _ _ AB AB AB AB ----------- AB \\ 00 01 11 10 e n\u00e3o: AB \\ 00 01 10 11 Como seria mais l\u00f3gico (j\u00e1 que em bin\u00e1rio: 00 = 0; 01 = 1; 10 = 2; 11 = 3 ). Por\u00e9m o mapa de Karnaugh assume que as vari\u00e1veis est\u00e3o ordenadas na forma de c\u00f3digo gray , onde um bit \u00e9 alterado por vez! Warning Colocar qualquer sequ\u00eancia na cria\u00e7\u00e3o do mapa \u00e9 um dos erros mais comuns dos anos anteriores! Tip Podemos come\u00e7ar a sequ\u00eancia com qualquer combina\u00e7\u00e3o, se seguirmos a ordem de s\u00f3 mudar um bit por vez, exemplo: AB \\ 11 10 00 01 AB \\ 01 11 10 00 Check-Point L\u00f3gica Booleana - Karnaugh 1 Encontre a montagem do mapa de Karnaugh correta. Qual mapa de K. foi montado certo? Qual mapa de K. foi montado certo? Quiz Maker - powered by Riddle 3. Grupos \u00b6 No MK podemos agrupar '1's na quantidade de: 2^n 2^n , onde n=0,1,2,3, ou seja, grupos de: 1, 2, 4, 8, ... , o agrupamento s\u00f3 pode ser feito na vertical ou horizontal, nunca na diagonal. Tip Os grupos podem se sobrepor! Agrupar sempre na maior quantidade poss\u00edvel (2, 4, 8, ...) Devemos agrupar sempre na maior quantidade poss\u00edvel! A seguir exemplos do que n\u00e3o deve ser feito! Note N\u00e3o agrupar na maior quantidade de uns poss\u00edvel impacta em n\u00e3o obter a equa\u00e7\u00e3o reduzida. Podemos pensar no MK n\u00e3o como sendo uma tabela plana , mas sim uma superf\u00edcie mapeada em uma esfera, logo as pontas est\u00e3o conectadas. Com isso podemos criar grupos nas situa\u00e7\u00f5es a seguir: Tip O agrupamento no mapa de Karnaugh s\u00f3 pode ser realizado quando juntamos uns que est\u00e3o a um bit de dist\u00e2ncia. Essa \u00e9 a raz\u00e3o de n\u00e3o podermos juntar na diagonal. AB 00 01 11 10 CD \\--------------------- 00 | 0000 0100 1100 1000 10 | 0010 0110 1110 1010 11 | 0011 0111 1111 1011 10 | 0010 0110 1110 1010 Note que no exemplo anterior se juntarmos duas possibilidades na horizontal (as duas primeira): --------- [0000 0100] --------- Apenas o bit referente a entrada B muda. Mas se considerarmos a diagonal: ---- [0000 0110] ---- Temos duas mudan\u00e7as de bit, a da entrada B e a da entrada C , isso n\u00e3o pode! O ultimo caso s\u00e3o os cantos, por exemplo: ---- ---- 0000] [1000 ---- ---- Nesse caso apenas o bit A muda, logo podemos juntar! Um caso que n\u00e3o pode juntar s\u00e3o as extremidades: ---- 0000] ---- ---- [1010 ---- Nesse caso A e C mudam! Check-Point [COPY] L\u00f3gica Booleana - Karnaugh 1 Encontre a montagem do mapa de Karnaugh correta. Qual mapa de K. foi montado certo? Qual mapa de K. foi montado certo? 4. Gerando as equa\u00e7\u00f5es \u00b6 Gera-se uma equa\u00e7\u00e3o por agrupamento, cada grupo ir\u00e1 fornecer um componente na forma da equa\u00e7\u00e3o da Soma Dos Produtos: (. . . ) + (. . . ). O truque \u00e9 identificar no grupo quais s\u00e3o as vari\u00e1veis que assumem todas as possibilidades. Exemplo 1 Nesse caso, a vari\u00e1vel B pode assumir tanto 0 quanto 1 para A fixo em 0 , para o grupo em quest\u00e3o as entradas A e B s\u00e3o: AB: 00 AB: 01 A equa\u00e7\u00e3o feita via a tabela verdade seria: \\bar{A}.B + \\bar{A} . \\bar{B} \\bar{A}.B + \\bar{A} . \\bar{B} que pode ser reduzida para \\bar{A} (\\bar{B}. B) \\bar{A} (\\bar{B}. B) e ent\u00e3o para: \\bar{A} \\bar{A} O mapa de Karnaugh j\u00e1 nos fornece o resultado de forma direta! Exemplo 2 Nesse caso, a vari\u00e1vel A pode assumir tanto 0 quanto 1 para B fixo em 0 , ou seja, A n\u00e3o impacta nesse grupo. Exemplo 3 Aqui temos um caso particular, para todas as combina\u00e7\u00f5es de entrada A e B a sa\u00edda \u00e9 sempre 1 , logo essa equa\u00e7\u00e3o \u00e9 sempre verdadeira: F = 1 F = 1 . Exemplo 4 Nesse exemplo n\u00e3o foi poss\u00edvel agrupar uns em maior quantidade, logo, n\u00e3o iremos conseguir obter um resultado melhor que a tabela verdade. Nenhuma vari\u00e1vel \u00e9 descart\u00e1vel. Exemplo 5 Nesse caso criamos dois grupos um na horizontal outro na vertical. Cada grupo ir\u00e1 gerar um termo da equa\u00e7\u00e3o na forma da SoP. Casos extras","title":"\u00c1lgebra Booleana"},{"location":"Teoria-Algebra-Booleana/#algebra-booleana","text":"Estudando Bibliografia [Cap1. Cap2. NISAN, 2005] [Cap6. TOCCI, 2011] [Cap1. FLOYD, 2007] [LAING, 2004] V\u00eddeos (extra) Logic 101 (#11): Truth Tables Logic 101 (#12): Truth Table Practice Computer Science: Karnaugh Maps \u2013 Introduction Computer Science: Karnaugh Maps - 4 vars A \u00e1lgebra booleana foi desenvolvida por George Boole , um matem\u00e1tico brit\u00e2nico que desenvolveu os conceitos em 1847, base da computa\u00e7\u00e3o moderna. Muito tempo depois, nos anos 30, Claude Shannon, um importante engenheiro na hist\u00f3ria da computa\u00e7\u00e3o moderna, aplicou as ideias de Boole em circuitos el\u00e9tricos. Ele trabalhava no Analisador Diferencial de Vannevar Bush, e logo percebeu a rela\u00e7\u00e3o dos rel\u00e9s com \u00e1lgebra booleana. Ele fazia um rel\u00e9 acionar o outro usando usando uma l\u00f3gica bin\u00e1ria do rel\u00e9 fechado ou aberto. Sua disserta\u00e7\u00e3o e artigos, levaram outras pessoas a perceber os benef\u00edcios da \u00e1lgebra booleana em eletr\u00f4nica e consequentemente computa\u00e7\u00e3o. Em \u00c1lgebra Booleana as vari\u00e1veis s\u00f3 podem assumir dois valores. Desligado e ligado, ou falso e verdadeiro, 0 volt e 5 volts, branco e preto. Por\u00e9m normalmente na computa\u00e7\u00e3o usamos 0 e 1 pela conveni\u00eancia. Todos os computadores tem como sua menor unidade de dado, esse elemento. Em computa\u00e7\u00e3o chamamos isso de bit. que vem de d\u00edgito bin\u00e1rio (ou do ingl\u00eas binary digit). Note Bit \u00e9 a unidade mais simples de representa\u00e7\u00e3o de dados digitais, um bit \u00e9 uma unidade que pode assumir apenas dois valores: 0 ou 1 . Com um bit podemos representar o estado de uma luz na sala de aula, se uma cadeira est\u00e1 vazio ou n\u00e3o, .... n\u00e3o conseguimos representar com apenas um bit uma informa\u00e7\u00e3o que n\u00e3o seja bin\u00e1ria. Mas se combinarmos mais de um bit, criando um vetor de bits, somos capazes de representar quantos estados desejarmos.","title":"\u00c1lgebra Booleana"},{"location":"Teoria-Algebra-Booleana/#equacoes","text":"Uma equa\u00e7\u00e3o de l\u00f3gica booleana pode possuir uma ou mais 'entradas' e apenas uma sa\u00edda, na equa\u00e7\u00e3o exemplo a seguir, X \u00e9 uma sa\u00edda (e pode assumir apenas valor 1 ou 0 ) e A e B s\u00e3o entradas tamb\u00e9m do tipo bin\u00e1ria. X(A,B) = A ^ B Note A opera\u00e7\u00e3o ^ \u00e9 chamada de E ( and ) que tamb\u00e9m pode ser representada pelo simbolo de multiplica\u00e7\u00e3o escalar . X = A and B X = A . B A opera\u00e7\u00e3o de and pode ser entendida como uma multiplica\u00e7\u00e3o: A sa\u00edda ( X ) s\u00f3 \u00e9 verdadeira se as entradas A e B forem verdadeiras: 1 . 1 = 1 . Como A e B s\u00e3o n\u00fameros bin\u00e1rios, \u00e9 poss\u00edvel encontrar uma tabela que relaciona o valor da sa\u00edda X com as poss\u00edveis entradas de A e B Entrada A Entrada B Sa\u00edda X 0 0 0 0 1 0 1 0 0 1 1 1 Tabela Verdade Essa tabela que acabamos de construir chama tabela verdade, e ser\u00e1 muito utilizada ao longo do curso. Podemos representar essa equa\u00e7\u00e3o X = A ^ B como sendo um circuito digital, como ilustrado a seguir: Note Resolver fun\u00e7\u00f5es booleanas \u00e9 entender quando a sa\u00edda ser\u00e1 Verdadeira ou Falsa dado a combina\u00e7\u00e3o poss\u00edvel de entradas.","title":"Equa\u00e7\u00f5es"},{"location":"Teoria-Algebra-Booleana/#operacoes","text":"O and utilizado no exemplo anterior \u00e9 um operador da l\u00f3gica booleana, operadores possuem uma ou mais entradas e geram uma sa\u00edda. Os operadores mais comuns s\u00e3o: not , and , or , nand , nor , xor .","title":"Opera\u00e7\u00f5es"},{"location":"Teoria-Algebra-Booleana/#not-and-or-nor","text":"not O operador not atua sobre uma vari\u00e1vel, tornando a sa\u00edda o inverso da entrada, ou seja, se a entrada do operador for 1 sua sa\u00edda ser\u00e1 0 e vice versa. Uso: a luz interna do carro ser\u00e1 acesa ('1') quando a porta estiver fechada ('0'). Nota\u00e7\u00e3o: not , - , ~ , \u00ac _ X = not A / X = A / X = \u00c3 / X = \u00ac A Tabela Verdade Entrada A X = not A 0 1 1 0 Simbologia and O operador and atua sobre duas vari\u00e1vel, tornando a sa\u00edda verdadeira somente se as duas entradas forem verdadeiras , se uma das entradas forem falsa a sa\u00edda ser\u00e1 falsa . Uso: o cofre ser\u00e1 aberto somente quando as duas chaves de seguran\u00e7as forem inseridas. Nota\u00e7\u00e3o: and , . , ^ X = A and B / X = A . B / X = A ^ B Tabela Verdade A B X = A and B 0 0 0 0 1 0 1 0 0 1 1 1 Simbologia or O operador or atua sobre duas vari\u00e1vel, tornando a sa\u00edda verdadeira sempre que uma das entradas forem verdadeira . Uso: O alarme de inc\u00eandio ser\u00e1 acionado caso alguns dois dois bot\u00f5es sejam pressionados. Nota\u00e7\u00e3o: or , + , v X = A or B / X = A + B / X = A v B Tabela Verdade A B X = A or B 0 0 0 0 1 1 1 0 1 1 1 1 Simbologia nand Podemos come\u00e7ar a 'unir' operadores para formar novos comportamentos, o nand \u00e9 a invers\u00e3o ( not ) da porta l\u00f3gica and . Na porta nand a sa\u00edda s\u00f3 \u00e9 verdadeira quando as entradas s\u00e3o falsas . Uso: Soar o alarme se os sensores de batimento card\u00edaco e o de press\u00e3o falharem. Nota\u00e7\u00e3o: nand , \u00ac( \u2227 ) _____ X = A nand B / X = A . B / X = \u00ac(A \u2227 B) Tabela Verdade A B X = A nand B 0 0 1 0 1 1 1 0 1 1 1 0 Simbologia nor / xor / xnor Para as demais portas l\u00f3gicas, consulte a refer\u00eancia: https://en.wikipedia.org/wiki/Logic_gate#Symbols Check-Point","title":"not, and, or, nor"},{"location":"Teoria-Algebra-Booleana/#tabela-verdade","text":"Nessa tabela criamos colunas para cada vari\u00e1vel de entrada e de sa\u00edda e colocamos as situa\u00e7\u00f5es poss\u00edveis (resultado). Para construirmos uma tabela verdade basta seguir as regras a seguir (na sequ\u00eancia): Criar uma coluna para cada entrada do sistema (n) Criar uma coluna para cada sa\u00edda do sistema A tabela verdade vai ter 2^n n\u00fameros de linhas (onde n \u00e9 a quantidade de entradas) um sistema com 2 entradas possui 2\u00b2 = 4 linhas um sistema com 3 entradas possui 2\u00b3 = 8 linhas ... Preencher as entradas (com '1's e '0's ) de forma a cobrir todas as possibilidades. Para cada linha, analisar se a combina\u00e7\u00e3o de '1's e '0' torna a sa\u00edda '1' e '0' Check-Point","title":"Tabela Verdade"},{"location":"Teoria-Algebra-Booleana/#funcoes-geradas-a-partir-de-tabelas-verdade","text":"\u00c9 poss\u00edvel a partir de uma tabela verdade obter uma equa\u00e7\u00e3o l\u00f3gica que a represente (caminho inverso), podemos fazer isso por duas t\u00e9cnicas diferentes (chamadas de forma can\u00f4nicas): Soma dos Produtos (SoP) Produto das Somas (PoS)","title":"Fun\u00e7\u00f5es geradas a partir de Tabelas Verdade"},{"location":"Teoria-Algebra-Booleana/#soma-dos-produtos","text":"Na soma dos produtos iremos encontrar uma equa\u00e7\u00e3o booleana que possui a seguinte forma: X = ( . . . ) + ( . . . ) + ... + ( . . . ) ----- | | = '1' Nesse m\u00e9todo, precisamos encontrar as linhas da tabela verdade que resultam em uma sa\u00edda '1' (Verdadeira) e invertendo (ou n\u00e3o) as entras fazendo com que o termo ( . . . .) resulte em '1' para a linha em quest\u00e3o.","title":"Soma Dos Produtos"},{"location":"Teoria-Algebra-Booleana/#produto-das-somas","text":"X = ( + + + ) . ( + + + ) . ... . ( + + + ) ----- | | = '0' Nesse m\u00e9todo, precisamos encontrar as linhas da tabela verdade que resultam em uma sa\u00edda '0' e invertendo (ou n\u00e3o) as entras gazer com que o termo ( . . . .) resulte em '0' para a linha em quest\u00e3o. Example Check-Point","title":"Produto das somas"},{"location":"Teoria-Algebra-Booleana/#simplificacao","text":"Existem duas formas bastante populares de simplificar uma equa\u00e7\u00e3o booleana: alg\u00e9brica ou via mapa de Karnaugh. Veremos as duas com mais detalhes.","title":"Simplifica\u00e7\u00e3o"},{"location":"Teoria-Algebra-Booleana/#simplificacao-algebrica","text":"Na simplifica\u00e7\u00e3o alg\u00e9brica iremos utilizar as seguintes propriedades de l\u00f3gica booleana para nos ajudar a simplificar uma equa\u00e7\u00e3o: Propriedade Opera\u00e7\u00e3o Lei da Identidade A = A \\bar{A} = \\bar{A} \\bar{A} = \\bar{A} Lei da Comutatividade A . B = B . A A + B = B + A Lei da Associatividade A . (B . C) = A B C A + (B + C) = A + B + C Lei da Idempot\u00eancia A . A = A A + A = A Lei do Complemento Duplo \\overline{\\overline{A}} = A \\overline{\\overline{A}} = A Lei da Complementariedade A \\, \\overline{A} = 0 A \\, \\overline{A} = 0 A + \\overline{A} = 1 A + \\overline{A} = 1 Lei da Intersec\u00e7\u00e3o A . 1 = A A . 0 = 0 Lei da Uni\u00e3o A + 1 = 1 A + 0 = A Lei da Distributividade A . (B + C) = (A . B) + (A . C) A + (B . C) = (A + B) (A + C) Teorema de DeMorgan \\overline{A \\, B} = \\bar{A} + \\bar{B} \\overline{A \\, B} = \\bar{A} + \\bar{B} \\overline{A + B} = \\bar{A} \\, \\bar{B} \\overline{A + B} = \\bar{A} \\, \\bar{B} Explica\u00e7\u00e3o da tabela Para essas simplifica\u00e7\u00f5es n\u00f3s usaremos as propriedades das opera\u00e7\u00f5es b\u00e1sicas de \u00e1lgebra booleana, representada na tabela anterior. As leis da identidade, comutatividade, associatividade e distributividade s\u00e3o bem similares ao que j\u00e1 fazemos normalmente em express\u00f5es matem\u00e1ticas. A idempot\u00eancia mostra que um AND ou OR com duas vari\u00e1veis \u00e9 exatamente a mesma vari\u00e1vel. A lei do complemento duplo mostra que se negarmos duas vezes uma vari\u00e1vel, teremos a mesma vari\u00e1vel. A lei da complementariedade j\u00e1 mostra que fazermos um AND com a nega\u00e7\u00e3o da mesma vari\u00e1vel acabaremos com zero, ou seja, 0 vezes 1 ou 1 vezes 0 sempre dar\u00e1 zero. J\u00e1 com o OR \u00e9 o oposto e sempre teremos 1 como resposta. Na lei da interse\u00e7\u00e3o temos que uma vari\u00e1vel vezes 1 \u00e9 sempre ela mesma, e se for vezes 0, acabara zerando o resultado. J\u00e1 a lei da uni\u00e3o diz que uma vari\u00e1vel mais um \u00e9 sempre um, e uma vari\u00e1vel mais zero \u00e9 a pr\u00f3pria vari\u00e1vel. O teorema de DeMorgam \u00e9 bem interessante, pois mostra uma propriedade bem peculiar da \u00e1lgebra booleana, no caso o conjunto de A vezes B negado, \u00e9 o mesmo que A negado, mais B negado, e da mesma forma A negado mais B negado \u00e9 igual ao A vezes B, e esse resultado negado. Para simplificarmos uma equa\u00e7\u00e3o, aplicamos as propriedades da tabela anterior a fim de encontrarmos uma equa\u00e7\u00e3o que: Tenha uma forma mais explicita de sua propriedade exe: A . B + A . C A . B + A . C -> A (B + C) A (B + C) Minimize o uso de 'portas l\u00f3gicas' exe: (A . B) . C + A . B . D (A . B) . C + A . B . D -> (A . B)(C + D) (A . B)(C + D) Elimine minimize as entradas necess\u00e1rias exe: (A \\overline{A}.B) (A \\overline{A}.B) -> B B","title":"Simplifica\u00e7\u00e3o alg\u00e9brica"},{"location":"Teoria-Algebra-Booleana/#exemplos","text":"Exemplo 1 Exemplo 2 Exemplo 3 Tip O v\u00eddeo a seguir possui as resolu\u00e7\u00f5es de forma detalhada:","title":"Exemplos"},{"location":"Teoria-Algebra-Booleana/#mapa-de-karnaugh-mk","text":"A simplifica\u00e7\u00e3o por mapa de Karnaugh \u00e9 uma t\u00e9cnica visual de encontrarmos uma equa\u00e7\u00e3o reduzida, por\u00e9m para isso precisamos primeiro: Gerar a tabela verdade Gerar o mapa de Karnaugh Criar os grupos Gerar as equa\u00e7\u00f5es","title":"Mapa de Karnaugh (MK)"},{"location":"Teoria-Algebra-Booleana/#2-criando-o-mapa","text":"O mapa pode ser criado para N entradas, mas s\u00f3 iremos tratar nesse curso sistemas de 2 , 3 ou 4 vari\u00e1veis (entradas). A seguir exemplos do mapa para 2, 3 e 4 entradas: Para criar o mapa basta seguir a receitinha anterior, note que a sequ\u00eancia das entras: AB e CD \u00e9 da forma: __ _ _ AB AB AB AB ----------- AB \\ 00 01 11 10 e n\u00e3o: AB \\ 00 01 10 11 Como seria mais l\u00f3gico (j\u00e1 que em bin\u00e1rio: 00 = 0; 01 = 1; 10 = 2; 11 = 3 ). Por\u00e9m o mapa de Karnaugh assume que as vari\u00e1veis est\u00e3o ordenadas na forma de c\u00f3digo gray , onde um bit \u00e9 alterado por vez! Warning Colocar qualquer sequ\u00eancia na cria\u00e7\u00e3o do mapa \u00e9 um dos erros mais comuns dos anos anteriores! Tip Podemos come\u00e7ar a sequ\u00eancia com qualquer combina\u00e7\u00e3o, se seguirmos a ordem de s\u00f3 mudar um bit por vez, exemplo: AB \\ 11 10 00 01 AB \\ 01 11 10 00 Check-Point","title":"2. Criando o Mapa"},{"location":"Teoria-Algebra-Booleana/#3-grupos","text":"No MK podemos agrupar '1's na quantidade de: 2^n 2^n , onde n=0,1,2,3, ou seja, grupos de: 1, 2, 4, 8, ... , o agrupamento s\u00f3 pode ser feito na vertical ou horizontal, nunca na diagonal. Tip Os grupos podem se sobrepor! Agrupar sempre na maior quantidade poss\u00edvel (2, 4, 8, ...) Devemos agrupar sempre na maior quantidade poss\u00edvel! A seguir exemplos do que n\u00e3o deve ser feito! Note N\u00e3o agrupar na maior quantidade de uns poss\u00edvel impacta em n\u00e3o obter a equa\u00e7\u00e3o reduzida. Podemos pensar no MK n\u00e3o como sendo uma tabela plana , mas sim uma superf\u00edcie mapeada em uma esfera, logo as pontas est\u00e3o conectadas. Com isso podemos criar grupos nas situa\u00e7\u00f5es a seguir: Tip O agrupamento no mapa de Karnaugh s\u00f3 pode ser realizado quando juntamos uns que est\u00e3o a um bit de dist\u00e2ncia. Essa \u00e9 a raz\u00e3o de n\u00e3o podermos juntar na diagonal. AB 00 01 11 10 CD \\--------------------- 00 | 0000 0100 1100 1000 10 | 0010 0110 1110 1010 11 | 0011 0111 1111 1011 10 | 0010 0110 1110 1010 Note que no exemplo anterior se juntarmos duas possibilidades na horizontal (as duas primeira): --------- [0000 0100] --------- Apenas o bit referente a entrada B muda. Mas se considerarmos a diagonal: ---- [0000 0110] ---- Temos duas mudan\u00e7as de bit, a da entrada B e a da entrada C , isso n\u00e3o pode! O ultimo caso s\u00e3o os cantos, por exemplo: ---- ---- 0000] [1000 ---- ---- Nesse caso apenas o bit A muda, logo podemos juntar! Um caso que n\u00e3o pode juntar s\u00e3o as extremidades: ---- 0000] ---- ---- [1010 ---- Nesse caso A e C mudam! Check-Point","title":"3. Grupos"},{"location":"Teoria-Algebra-Booleana/#4-gerando-as-equacoes","text":"Gera-se uma equa\u00e7\u00e3o por agrupamento, cada grupo ir\u00e1 fornecer um componente na forma da equa\u00e7\u00e3o da Soma Dos Produtos: (. . . ) + (. . . ). O truque \u00e9 identificar no grupo quais s\u00e3o as vari\u00e1veis que assumem todas as possibilidades. Exemplo 1 Nesse caso, a vari\u00e1vel B pode assumir tanto 0 quanto 1 para A fixo em 0 , para o grupo em quest\u00e3o as entradas A e B s\u00e3o: AB: 00 AB: 01 A equa\u00e7\u00e3o feita via a tabela verdade seria: \\bar{A}.B + \\bar{A} . \\bar{B} \\bar{A}.B + \\bar{A} . \\bar{B} que pode ser reduzida para \\bar{A} (\\bar{B}. B) \\bar{A} (\\bar{B}. B) e ent\u00e3o para: \\bar{A} \\bar{A} O mapa de Karnaugh j\u00e1 nos fornece o resultado de forma direta! Exemplo 2 Nesse caso, a vari\u00e1vel A pode assumir tanto 0 quanto 1 para B fixo em 0 , ou seja, A n\u00e3o impacta nesse grupo. Exemplo 3 Aqui temos um caso particular, para todas as combina\u00e7\u00f5es de entrada A e B a sa\u00edda \u00e9 sempre 1 , logo essa equa\u00e7\u00e3o \u00e9 sempre verdadeira: F = 1 F = 1 . Exemplo 4 Nesse exemplo n\u00e3o foi poss\u00edvel agrupar uns em maior quantidade, logo, n\u00e3o iremos conseguir obter um resultado melhor que a tabela verdade. Nenhuma vari\u00e1vel \u00e9 descart\u00e1vel. Exemplo 5 Nesse caso criamos dois grupos um na horizontal outro na vertical. Cada grupo ir\u00e1 gerar um termo da equa\u00e7\u00e3o na forma da SoP. Casos extras","title":"4. Gerando as equa\u00e7\u00f5es"},{"location":"Teoria-Aritmetica-Binaria-HW/","text":"Aritm\u00e9tica Bin\u00e1ria - HW \u00b6 Conte\u00fado: hald-adder/ full-adder/ somador Tip Esse conte\u00fado est\u00e1 no cap. 2 do livro texto da disciplina The Elements of Computing Systems . Precisamos lembrar que nosso objetivo \u00e9 a cria\u00e7\u00e3o de um hardware capaz de operar em n\u00fameros bin\u00e1rios. Nessa teoria iremos analisar algumas t\u00e9cnicas de realizar o hardware necess\u00e1rio para realizar opera\u00e7\u00e3o de soma bin\u00e1ria entre dois vetores. Para isso iremos definir dois componentes: Half-Adder e o Full-Adder. half-adder (HAD) \u00b6 Half-Adder (HAD) \u00e9 um circuito digital capaz de somar dois bits ( a e b ), tem como resultado o valor da soma e do carry , como ilustrado a seguir: ------ a -->| |--> Soma | HA | b -->| |--> Carry ------ O HA possui a seguinte tabela verdade: a b Carry (out) Soma (out) 0 0 0 0 0 1 0 1 1 0 0 1 1 1 1 0 E \u00e9 implementado da seguinte forma em hardware: Fonte: https://en.wikipedia.org/wiki/Adder_(electronics ) full-adder (FAD) \u00b6 Full-adder \u00e9 um componente digital capaz de somar tr\u00eas vits ( a , b e c ) e possui como sa\u00edda o valor da soma e do carry resultante da opera\u00e7\u00e3o. A seguir um diagrama de blocos de um FAD : Fonte: https://en.wikipedia.org/wiki/Adder_(electronics ) O FAD possui a seguinte tabela verdade: a b c Carry (out) Soma (out) 0 0 0 0 0 0 0 1 0 1 0 1 0 0 1 0 1 1 1 0 1 0 0 0 1 1 0 1 1 0 1 1 0 1 0 1 1 1 1 1 E \u00e9 implementado da seguinte maneira em portas l\u00f3gicas: Fonte: https://en.wikipedia.org/wiki/Adder_(electronics ) Tip Voc\u00ea deve ser capaz de encontrar esses circuitos analisando a tabela verdade e simplificando via Mapa de K. Note que existem duas abordagens para representar o Carry_out: A.B+A.C+B.C e A.B+C(A xor B) Fonte: (2011) Fundamentals of Digital and Computer Design with VHDL, pg 199. Somador \u00b6 Tip Utilizando o HAD e o FAD somos capazes de realizar um somador de dois vetores em bin\u00e1rios. Para isso, teremos que utilizar um full-adder para cada bit desse nosso vetor. Por exemplo: se formos criar um Somador capaz de somar dois vetores de 4bits , necessitamos utilizar 4 FAD para isso. A liga\u00e7\u00e3o dos full-adders \u00e9 descrita a baixo: Fonte: https://en.wikipedia.org/wiki/Adder_(electronics ) Note Nesse diagrama, estamos realizando a soma ente os vetores A(3 downto 0) e B(3 downto 0) que resulta em um outro vetor S(3 downto 0) e um carry C4 .","title":"Aritm\u00e9tica Bin\u00e1ria - HW"},{"location":"Teoria-Aritmetica-Binaria-HW/#aritmetica-binaria-hw","text":"Conte\u00fado: hald-adder/ full-adder/ somador Tip Esse conte\u00fado est\u00e1 no cap. 2 do livro texto da disciplina The Elements of Computing Systems . Precisamos lembrar que nosso objetivo \u00e9 a cria\u00e7\u00e3o de um hardware capaz de operar em n\u00fameros bin\u00e1rios. Nessa teoria iremos analisar algumas t\u00e9cnicas de realizar o hardware necess\u00e1rio para realizar opera\u00e7\u00e3o de soma bin\u00e1ria entre dois vetores. Para isso iremos definir dois componentes: Half-Adder e o Full-Adder.","title":"Aritm\u00e9tica Bin\u00e1ria - HW"},{"location":"Teoria-Aritmetica-Binaria-HW/#half-adder-had","text":"Half-Adder (HAD) \u00e9 um circuito digital capaz de somar dois bits ( a e b ), tem como resultado o valor da soma e do carry , como ilustrado a seguir: ------ a -->| |--> Soma | HA | b -->| |--> Carry ------ O HA possui a seguinte tabela verdade: a b Carry (out) Soma (out) 0 0 0 0 0 1 0 1 1 0 0 1 1 1 1 0 E \u00e9 implementado da seguinte forma em hardware: Fonte: https://en.wikipedia.org/wiki/Adder_(electronics )","title":"half-adder (HAD)"},{"location":"Teoria-Aritmetica-Binaria-HW/#full-adder-fad","text":"Full-adder \u00e9 um componente digital capaz de somar tr\u00eas vits ( a , b e c ) e possui como sa\u00edda o valor da soma e do carry resultante da opera\u00e7\u00e3o. A seguir um diagrama de blocos de um FAD : Fonte: https://en.wikipedia.org/wiki/Adder_(electronics ) O FAD possui a seguinte tabela verdade: a b c Carry (out) Soma (out) 0 0 0 0 0 0 0 1 0 1 0 1 0 0 1 0 1 1 1 0 1 0 0 0 1 1 0 1 1 0 1 1 0 1 0 1 1 1 1 1 E \u00e9 implementado da seguinte maneira em portas l\u00f3gicas: Fonte: https://en.wikipedia.org/wiki/Adder_(electronics ) Tip Voc\u00ea deve ser capaz de encontrar esses circuitos analisando a tabela verdade e simplificando via Mapa de K. Note que existem duas abordagens para representar o Carry_out: A.B+A.C+B.C e A.B+C(A xor B) Fonte: (2011) Fundamentals of Digital and Computer Design with VHDL, pg 199.","title":"full-adder (FAD)"},{"location":"Teoria-Aritmetica-Binaria-HW/#somador","text":"Tip Utilizando o HAD e o FAD somos capazes de realizar um somador de dois vetores em bin\u00e1rios. Para isso, teremos que utilizar um full-adder para cada bit desse nosso vetor. Por exemplo: se formos criar um Somador capaz de somar dois vetores de 4bits , necessitamos utilizar 4 FAD para isso. A liga\u00e7\u00e3o dos full-adders \u00e9 descrita a baixo: Fonte: https://en.wikipedia.org/wiki/Adder_(electronics ) Note Nesse diagrama, estamos realizando a soma ente os vetores A(3 downto 0) e B(3 downto 0) que resulta em um outro vetor S(3 downto 0) e um carry C4 .","title":"Somador"},{"location":"Teoria-Aritmetica-Binaria/","text":"Aritm\u00e9tica Bin\u00e1ria \u00b6 Conte\u00fado: Complemento de um/ Complemento de dois/ Ponto fixo/ Soma bin\u00e1ria/ Leitura necess\u00e1ria The Elements of Computing Systems (Livro texto do curso), cap 2. Podemos utilizar n\u00fameros bin\u00e1rios para codificar qualquer tipo de dado, como vimos na teoria de dados digitais. Mas ainda n\u00e3o sabemos como utilizar n\u00fameros bin\u00e1rios para representar: n\u00fameros inteiros que possam ser negativos e n\u00fameros reais (exe: 1,032 ). Essa teoria ir\u00e1 tratar desses temas e tamb\u00e9m da parte referente a opera\u00e7\u00f5es com n\u00fameros bin\u00e1rios (soma e subtra\u00e7\u00e3o). Soma bin\u00e1ria \u00b6 A soma bin\u00e1ria \u00e9 realizada de maneira similar a soma de decimais, s\u00f3 que precisamos notar que 1 + 1 em bin\u00e1rio ( esse + \u00e9 de soma n\u00e3o de OR ), resulta em 10 , o 1 do estouro e que passa para a pr\u00f3xima casa \u00e9 chamado de carry . Esse carry \u00e9 similar ao vai um em uma soma decimal, por exemplo: quando somamos em decimal 9 + 3 o resultado \u00e9 12 (10 + 2). Exemplos a seguir consideram Somador de 8 bits N\u00fameros inteiros positivos Tip 01 + 01 = 10 01 + 01 + 01 = 11 0xAA + 0x55 = 0xFF : Carry 1 0 1 0 1 0 1 0 : A 0 1 0 1 0 1 0 1 + : B --------------- 1 1 1 1 1 1 1 1 : Resultado (A+B) 0xAA + 0x55 = 0xFF : Carry 1 0 1 0 1 0 1 0 : A 0 1 0 1 0 1 0 1 + : B --------------- 1 1 1 1 1 1 1 1 : Resultado (A+B) 0x2B + 0x57 = 0xFF 1 1 1 1 1 1 1 : Carry 0 0 1 0 1 0 1 1 : A 0 1 0 1 0 1 1 1 + : B --------------- 1 0 0 0 0 0 1 0 : Resultado (A+B) Tip 01 + 01 = 10 01 + 01 + 01 = 11 Precisamos perceber que cada bit deve ser armazenado em hardware real! Um sistema com 8 bits n\u00e3o consegue armazenar 9 bits, e se houver um estouro no \u00faltimo bit essa informa\u00e7\u00e3o ser\u00e1 perdida. 0x80 + 0x80 = 0x100, mas resulta em 0x00 por conta do somador ser 8 bits: carry \u00e9 perdido 1 \\ 1 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 + --------------- 0 0 0 0 0 0 0 0 0x03 + 0x81 = 0x84 1 1 : carry (vai um) \\ 0 0 0 0 0 0 1 1 1 0 0 0 0 0 0 1 + --------------- 1 0 0 0 0 1 0 0 complemento de um \u00b6 Warning Forma 'errada/ n\u00e3o usual' de armazenar n\u00fameros sinalizados (+, -) Exemplos consideram Palavras bin\u00e1rias com 4 bits No complemento de um, utilizamos a casa mais significativa de um vetor de bits para representar se o n\u00famero \u00e9 positivo ( 0 ) ou negativo ( 1 ). Exemplo (utilizando 4 bits): Valor +1 em bin\u00e1rio, com complemento de 1 00000001 ^ | indica que o valor \u00e9 positivo Valor -1 em bin\u00e1rio, com complemento de 1 10000001 ^ | indica que o valor \u00e9 negativo O problema do complemento de 1 \u00e9 que: Possu\u00edmos duas representa\u00e7\u00f5es para o valor 0: 00000000 e 10000000 Opera\u00e7\u00f5es de soma n\u00e3o funcionam corretamente entre os dois n\u00fameros codificados em complemento de um. Exemplo: 1 - 1 = -2 e n\u00e3o 0 1 : carry (vai um) \\ 0 0 0 0 0 0 0 1 : +1 1 0 0 0 0 0 0 1 + : -1 --------------- 1 0 0 0 0 0 1 0 : -2 e n\u00e3o 0 (como deveria ser) Tabela com 3 bits Decimal Bin\u00e1rio em complemento de 1 3 011 2 010 1 001 0 000 / 100 -1 101 -2 110 -3 111 Complemento de 2 \u00b6 O complemento de dois \u00e9 uma outra maneira de representar n\u00fameros sinalizados com bits, essa t\u00e9cnica possui as vantagens de: Uma \u00fanica representa\u00e7\u00e3o para o valor 0: 0000 A opera\u00e7\u00e3o de soma/ subtra\u00e7\u00e3o funciona corretamente! O bit mais significativo indica se a palavra \u00e9 positiva ( 0 ) ou negativa ( 1 ). Para obter um n\u00famero positivo <-> negativo nessa nota\u00e7\u00e3o \u00e9 necess\u00e1rio seguir os seguintes passos: Escreva o valor em bin\u00e1rios (positivo) Inverter todos os bits (not bit a bit) da palavra original Somar o valor 1 a palavra invertida. Exemplos consideram Palavras bin\u00e1rias com 4 bits Exemplo: -3 = 1101 0 0 0 0 0 0 1 1 : 3 ----------------------- 1 1 1 1 1 1 0 0 : not bit a bit da palavra original 0 0 0 0 + 1 : Soma um a palavra invertida ----------------------- 1 1 1 1 1 1 0 1 <-- -3 em complemento de 2 Exemplo: -5 = 1011 0 0 0 0 0 1 0 1 : 5 ----------------------- 1 1 1 1 1 0 1 0 : not bit a bit da palavra original 0 0 0 0 0 0 0 1 + : Soma um a palavra invertida ----------------------- 1 1 1 1 1 0 1 1 <-- -5 em complemento de 2 Exemplo (com 4 bits para simplificar): -9 (n\u00e3o funciona!!) 1 0 0 1 : 9 0 1 1 0 : not bit a bit da palavra original + 1 : Soma um a palavra invertida 0 1 1 1 ^ | n\u00e3o funcionou =( O exemplo anterior n\u00e3o funciona pois faltam bits para representar o valor -9 , para isso seria necess\u00e1rio 5 bits e n\u00e3o 4 como no exemplo. Tabela com 3 bits Decimal Bin\u00e1rio em complemento de dois 3 011 2 010 1 001 0 000 -1 111 -2 110 -3 101 -4 100 Multiplica\u00e7\u00e3o/ Divis\u00e3o por m\u00faltiplo de 2 \u00b6 Assumindo Um n\u00famero positivo Em bin\u00e1rio, para multiplicar uma palavra (positiva) por 2 basta rotacionar todos os bits uma casa para esquerda. Para dividir por 2 basta rotacionar todos os bits uma vez para direita (sempre colocando 0 no bit que entra e desaparecendo com o bit que sai). Exemplos a seguir: 2 x 1 ( 00000001 ) = 2 00000010 <-- 1x 00000001 => 00000010 2 x 4 ( 00000100 ) = 8 00001000 <-- 1x 00000100 => 00001000 9 ( 00001001 ) / 2 = 4 00000100 1x --> 00001001 => 00000100 Note A divis\u00e3o de 9/2 retorna um n\u00famero inteiro. Isso se d\u00e1 devido a t\u00e9cnica s\u00f3 funcionar com n\u00fameros inteiros. Essa t\u00e9cnica de rotacionar vale para m\u00faltiplos de 2, se deseja multiplicar/dividir por M , onde M \u00e9 um m\u00faltiplo de 2 ( M=Nx2 ), \u00e9 necess\u00e1rio rotacionar o vetor de bits N vezes: exemplo: 4 x 1 ( 00000001 ) = 00000100 <-- 2x 00000001 => 00000100 Ponto fixo \u00b6 Ponto fixo \u00e9 uma das t\u00e9cnicas de representa\u00e7\u00e3o de n\u00fameros fracionados em bin\u00e1rio, nessa nota\u00e7\u00e3o fixasse quantos bits ser\u00e3o utilizados para a parte inteira e quantos ser\u00e3o utilizados para a fra\u00e7\u00e3o. \u00c9 aplicado o mesmo conceito dos n\u00fameros decimais, as casas a direita do ponto possuem peso na ordem 2^-n . Vamos pegar como exemplo o valor 26.5 , e assumindo que estamos trabalhando com uma palavra de 8 bits onde o ponto est\u00e1 localizado no bit 3 : XXXXX.YYY . Nesse caso, cada casa bin\u00e1ria possui o peso a seguir: 2^5 2^4 2^3 2^2 2^1 2^0 2^-1 2^-2 2^-3 32 16 8 4 2 1 0.5 0.25 0.125 Para construirmos o valor 26.5 basta selecionarmos os bits que somados d\u00e3o esse valor: 011010100 : 0*32 + 1*16 + 1*8 + 0*4 + 1*2 + 0*1 + 1*0.5 + 0*0.025 + 0*0.125 = 26.5 A quest\u00e3o dessa nota\u00e7\u00e3o \u00e9 que uma vez escolhido onde o ponto vai estar localizado (projeto de hardware) n\u00e3o da para mudar depois, se o n\u00famero a ser armazenado \u00e9 apenas fra\u00e7\u00e3o, perdemos muitos bits sem uso com a parte inteira, o que faz possuirmos menor resolu\u00e7\u00e3o. A solu\u00e7\u00e3o para isso \u00e9 a nota\u00e7\u00e3o de ponto flutuante - IEEE 754 voc\u00eas v\u00e3o ver isso na disciplina de Sistemas Hardware Software do 5s).","title":"Aritm\u00e9tica Bin\u00e1ria"},{"location":"Teoria-Aritmetica-Binaria/#aritmetica-binaria","text":"Conte\u00fado: Complemento de um/ Complemento de dois/ Ponto fixo/ Soma bin\u00e1ria/ Leitura necess\u00e1ria The Elements of Computing Systems (Livro texto do curso), cap 2. Podemos utilizar n\u00fameros bin\u00e1rios para codificar qualquer tipo de dado, como vimos na teoria de dados digitais. Mas ainda n\u00e3o sabemos como utilizar n\u00fameros bin\u00e1rios para representar: n\u00fameros inteiros que possam ser negativos e n\u00fameros reais (exe: 1,032 ). Essa teoria ir\u00e1 tratar desses temas e tamb\u00e9m da parte referente a opera\u00e7\u00f5es com n\u00fameros bin\u00e1rios (soma e subtra\u00e7\u00e3o).","title":"Aritm\u00e9tica Bin\u00e1ria"},{"location":"Teoria-Aritmetica-Binaria/#soma-binaria","text":"A soma bin\u00e1ria \u00e9 realizada de maneira similar a soma de decimais, s\u00f3 que precisamos notar que 1 + 1 em bin\u00e1rio ( esse + \u00e9 de soma n\u00e3o de OR ), resulta em 10 , o 1 do estouro e que passa para a pr\u00f3xima casa \u00e9 chamado de carry . Esse carry \u00e9 similar ao vai um em uma soma decimal, por exemplo: quando somamos em decimal 9 + 3 o resultado \u00e9 12 (10 + 2). Exemplos a seguir consideram Somador de 8 bits N\u00fameros inteiros positivos Tip 01 + 01 = 10 01 + 01 + 01 = 11 0xAA + 0x55 = 0xFF : Carry 1 0 1 0 1 0 1 0 : A 0 1 0 1 0 1 0 1 + : B --------------- 1 1 1 1 1 1 1 1 : Resultado (A+B) 0xAA + 0x55 = 0xFF : Carry 1 0 1 0 1 0 1 0 : A 0 1 0 1 0 1 0 1 + : B --------------- 1 1 1 1 1 1 1 1 : Resultado (A+B) 0x2B + 0x57 = 0xFF 1 1 1 1 1 1 1 : Carry 0 0 1 0 1 0 1 1 : A 0 1 0 1 0 1 1 1 + : B --------------- 1 0 0 0 0 0 1 0 : Resultado (A+B) Tip 01 + 01 = 10 01 + 01 + 01 = 11 Precisamos perceber que cada bit deve ser armazenado em hardware real! Um sistema com 8 bits n\u00e3o consegue armazenar 9 bits, e se houver um estouro no \u00faltimo bit essa informa\u00e7\u00e3o ser\u00e1 perdida. 0x80 + 0x80 = 0x100, mas resulta em 0x00 por conta do somador ser 8 bits: carry \u00e9 perdido 1 \\ 1 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 + --------------- 0 0 0 0 0 0 0 0 0x03 + 0x81 = 0x84 1 1 : carry (vai um) \\ 0 0 0 0 0 0 1 1 1 0 0 0 0 0 0 1 + --------------- 1 0 0 0 0 1 0 0","title":"Soma bin\u00e1ria"},{"location":"Teoria-Aritmetica-Binaria/#complemento-de-um","text":"Warning Forma 'errada/ n\u00e3o usual' de armazenar n\u00fameros sinalizados (+, -) Exemplos consideram Palavras bin\u00e1rias com 4 bits No complemento de um, utilizamos a casa mais significativa de um vetor de bits para representar se o n\u00famero \u00e9 positivo ( 0 ) ou negativo ( 1 ). Exemplo (utilizando 4 bits): Valor +1 em bin\u00e1rio, com complemento de 1 00000001 ^ | indica que o valor \u00e9 positivo Valor -1 em bin\u00e1rio, com complemento de 1 10000001 ^ | indica que o valor \u00e9 negativo O problema do complemento de 1 \u00e9 que: Possu\u00edmos duas representa\u00e7\u00f5es para o valor 0: 00000000 e 10000000 Opera\u00e7\u00f5es de soma n\u00e3o funcionam corretamente entre os dois n\u00fameros codificados em complemento de um. Exemplo: 1 - 1 = -2 e n\u00e3o 0 1 : carry (vai um) \\ 0 0 0 0 0 0 0 1 : +1 1 0 0 0 0 0 0 1 + : -1 --------------- 1 0 0 0 0 0 1 0 : -2 e n\u00e3o 0 (como deveria ser) Tabela com 3 bits Decimal Bin\u00e1rio em complemento de 1 3 011 2 010 1 001 0 000 / 100 -1 101 -2 110 -3 111","title":"complemento de um"},{"location":"Teoria-Aritmetica-Binaria/#complemento-de-2","text":"O complemento de dois \u00e9 uma outra maneira de representar n\u00fameros sinalizados com bits, essa t\u00e9cnica possui as vantagens de: Uma \u00fanica representa\u00e7\u00e3o para o valor 0: 0000 A opera\u00e7\u00e3o de soma/ subtra\u00e7\u00e3o funciona corretamente! O bit mais significativo indica se a palavra \u00e9 positiva ( 0 ) ou negativa ( 1 ). Para obter um n\u00famero positivo <-> negativo nessa nota\u00e7\u00e3o \u00e9 necess\u00e1rio seguir os seguintes passos: Escreva o valor em bin\u00e1rios (positivo) Inverter todos os bits (not bit a bit) da palavra original Somar o valor 1 a palavra invertida. Exemplos consideram Palavras bin\u00e1rias com 4 bits Exemplo: -3 = 1101 0 0 0 0 0 0 1 1 : 3 ----------------------- 1 1 1 1 1 1 0 0 : not bit a bit da palavra original 0 0 0 0 + 1 : Soma um a palavra invertida ----------------------- 1 1 1 1 1 1 0 1 <-- -3 em complemento de 2 Exemplo: -5 = 1011 0 0 0 0 0 1 0 1 : 5 ----------------------- 1 1 1 1 1 0 1 0 : not bit a bit da palavra original 0 0 0 0 0 0 0 1 + : Soma um a palavra invertida ----------------------- 1 1 1 1 1 0 1 1 <-- -5 em complemento de 2 Exemplo (com 4 bits para simplificar): -9 (n\u00e3o funciona!!) 1 0 0 1 : 9 0 1 1 0 : not bit a bit da palavra original + 1 : Soma um a palavra invertida 0 1 1 1 ^ | n\u00e3o funcionou =( O exemplo anterior n\u00e3o funciona pois faltam bits para representar o valor -9 , para isso seria necess\u00e1rio 5 bits e n\u00e3o 4 como no exemplo. Tabela com 3 bits Decimal Bin\u00e1rio em complemento de dois 3 011 2 010 1 001 0 000 -1 111 -2 110 -3 101 -4 100","title":"Complemento de 2"},{"location":"Teoria-Aritmetica-Binaria/#multiplicacao-divisao-por-multiplo-de-2","text":"Assumindo Um n\u00famero positivo Em bin\u00e1rio, para multiplicar uma palavra (positiva) por 2 basta rotacionar todos os bits uma casa para esquerda. Para dividir por 2 basta rotacionar todos os bits uma vez para direita (sempre colocando 0 no bit que entra e desaparecendo com o bit que sai). Exemplos a seguir: 2 x 1 ( 00000001 ) = 2 00000010 <-- 1x 00000001 => 00000010 2 x 4 ( 00000100 ) = 8 00001000 <-- 1x 00000100 => 00001000 9 ( 00001001 ) / 2 = 4 00000100 1x --> 00001001 => 00000100 Note A divis\u00e3o de 9/2 retorna um n\u00famero inteiro. Isso se d\u00e1 devido a t\u00e9cnica s\u00f3 funcionar com n\u00fameros inteiros. Essa t\u00e9cnica de rotacionar vale para m\u00faltiplos de 2, se deseja multiplicar/dividir por M , onde M \u00e9 um m\u00faltiplo de 2 ( M=Nx2 ), \u00e9 necess\u00e1rio rotacionar o vetor de bits N vezes: exemplo: 4 x 1 ( 00000001 ) = 00000100 <-- 2x 00000001 => 00000100","title":"Multiplica\u00e7\u00e3o/ Divis\u00e3o por m\u00faltiplo de 2"},{"location":"Teoria-Aritmetica-Binaria/#ponto-fixo","text":"Ponto fixo \u00e9 uma das t\u00e9cnicas de representa\u00e7\u00e3o de n\u00fameros fracionados em bin\u00e1rio, nessa nota\u00e7\u00e3o fixasse quantos bits ser\u00e3o utilizados para a parte inteira e quantos ser\u00e3o utilizados para a fra\u00e7\u00e3o. \u00c9 aplicado o mesmo conceito dos n\u00fameros decimais, as casas a direita do ponto possuem peso na ordem 2^-n . Vamos pegar como exemplo o valor 26.5 , e assumindo que estamos trabalhando com uma palavra de 8 bits onde o ponto est\u00e1 localizado no bit 3 : XXXXX.YYY . Nesse caso, cada casa bin\u00e1ria possui o peso a seguir: 2^5 2^4 2^3 2^2 2^1 2^0 2^-1 2^-2 2^-3 32 16 8 4 2 1 0.5 0.25 0.125 Para construirmos o valor 26.5 basta selecionarmos os bits que somados d\u00e3o esse valor: 011010100 : 0*32 + 1*16 + 1*8 + 0*4 + 1*2 + 0*1 + 1*0.5 + 0*0.025 + 0*0.125 = 26.5 A quest\u00e3o dessa nota\u00e7\u00e3o \u00e9 que uma vez escolhido onde o ponto vai estar localizado (projeto de hardware) n\u00e3o da para mudar depois, se o n\u00famero a ser armazenado \u00e9 apenas fra\u00e7\u00e3o, perdemos muitos bits sem uso com a parte inteira, o que faz possuirmos menor resolu\u00e7\u00e3o. A solu\u00e7\u00e3o para isso \u00e9 a nota\u00e7\u00e3o de ponto flutuante - IEEE 754 voc\u00eas v\u00e3o ver isso na disciplina de Sistemas Hardware Software do 5s).","title":"Ponto fixo"},{"location":"Teoria-Componentes/","text":"Componentes Digitais \u00b6 Essa lista descreve os principais componentes digitais utilizados em projetos diversos e no do nosso Z01! portas l\u00f3gicas \u00b6 buffer not and or nand nor xor Multiplexado (mux) \u00b6 fonte wikipedia : Schematic of a 2-to-1 Multiplexer. It can be equated to a controlled switch. entity mux is port ( in0 : in std_logic ; in1 : in std_logic ; sel : in std_logic ; o : out std_logic ); end entity ; O mux como \u00e9 chamado o Multiplexador \u00e9 um componente que possui n entradas e uma sa\u00edda q , um sinal chamado de seletor sel seleciona qual entrada ir\u00e1 ser copiada para a sa\u00edda. As entradas n e a sa\u00edda q podem ser bin\u00e1rias ou vetor de tamanho m . A seguir uma tabela verdade para um mux de 2 entradas: in 0 in 1 Sel out 1 X 0 1 X 0 1 0 0 X 0 0 X 1 1 1 Note A tabela verdade do mux de 2 entradas possuir 3^2 linhas (o seletor conta como entrada), logo deveria ter 8 linhas. Por\u00e9m para simplificar, utilizamos o X que significa tanto faz 0 ou 1 , logo cada linha que possui X seria expandida para duas linhas, totalizando 8. Tip O tamanho do seletor deve ser um numero inteiro: log2(size(n)) log2(size(n)) . Quantidade de entras Tamanho do seletor 2 1 3 2 4 2 5 3 8 3 Demutiplexador (demux) \u00b6 \u00c9 similar com o mux s\u00f3 que possui uma entrada in e n sa\u00eddas q , o demux conecta a entrada a alguma das sa\u00eddas, sendo controlado pelo seletor. fonte wikipedia : Schematic of a 1-to-2 Demultiplexer. Like a multiplexer, it can be equated to a controlled switch. entity demux is port ( in0 : in std_logic ; sel : in std_logic ; out0 : out std_logic ; out1 : out std_logic ); end entity ; A entrada in e a sa\u00edda q podem ser bin\u00e1rias ou de vetorer de tamanho m . A seguir uma tabela verdade para um demux de 2 sa\u00eddas: in Sel out 0 out 1 1 0 1 0 1 1 0 1 0 1 0 0 0 0 0 0 Enconders \u00b6 Enconders s\u00e3o componentes que codificam uma entrada em uma sa\u00edda de outro formato, algum exemplos s\u00e3o: BCD Gray code SevenSeg Priority Encoder BCD \u00b6 Binary-coded decimal (BCD) \u00e9 uma forma de codifica\u00e7\u00e3o de n\u00fameros inteiros em bin\u00e1rio na qual utiliza-se para cada d\u00edgito de um n\u00famero inteiro, 4 bits em bin\u00e1rio. Decimal Number BCD 8421 Code 0 0000 0000 01 0000 0001 02 0000 0010 03 0000 0011 04 0000 0100 05 0000 0101 06 0000 0110 07 0000 0111 08 0000 1000 09 0000 1001 10 (1+0) 0001 0000 11 (1+1) 0001 0001 12 (1+2) 0001 0010 continua em blocos de 4 |-----------| | | out1[3..0] x[n..0] | Binary |-----/--------> ----/------>| to | .... | BCD | outm[3..0] | |-----/--------> |-----------| entity binaryToBCD is port ( x : in std_logic ( 4 downto 0 ); out0 : out std_logic_vector ( 3 downto 0 ); -- Unidade out1 : out std_logic_vector ( 3 downto 0 ) -- Dezena ); end entity ; Tip O maior valor que um bloco de 4 bits do BCD assume \u00e9 o 1001 que \u00e9 referente ao n\u00famero inteiro 9. O BCD \u00e9 bastante utilizado para o controle de displays de 7 segmentos, como demonstrado na figura a seguir que usa o chip fonte electronics-tutorials C\u00f3digo Gray \u00b6 O c\u00f3digo gray \u00e9 uma forma de codificar n\u00fameros bin\u00e1rios, nessa codifica\u00e7\u00e3o apenas um bit muda por vez. C\u00f3digo decimal C\u00f3digo Bin\u00e1rio C\u00f3digo Gray 0 0000 0000 1 0001 0001 2 0010 0011 3 0011 0010 4 0100 0110 5 0101 0111 6 0110 0101 7 0111 0100 8 1000 1100 9 1001 1101 10 1010 1111 11 1011 1110 12 1100 1010 13 1101 1011 14 1110 1001 15 1111 1000 Note Esse sistema era muito utilizado antigamente quando rel\u00e9s eram utilizados no lugar de transistor, em um contador bin\u00e1rio comum ocorre de muitos bits mudarem de uma \u00fanica vez (0111 -> 1000) isso gerava um pico de corrente el\u00e9trica e muito ru\u00eddo. Tip Utilizamos o c\u00f3digo Gray para montar o Mapa de Karnaugh Comparador \u00b6 Comparadores s\u00e3o componentes que podem possuir diversos atributos, tais como comparar: se duas entradas s\u00e3o iguais se a entrada A \u00e9 maior que entrada B se entrada A \u00e9 igual a zero ... A seguir um exemplo de um comparador que possui apenas uma entrada x[1..0] e compara se essa entrada \u00e9 igual a zero ( x == 0 ), ou maior que zero ( x > 0 ). x (inteiro) x bin\u00e1rio eq gt 0 00 1 0 1 01 0 1 -1 11 0 0 -2 10 0 0 |-----------| | | eq x[1..0] | |----------> ----/------>| comparador| | | gt | |----------> |-----------| entity COMPARADOR is port ( x : in std_logic_vector ( 1 downto 0 ); eq : out std_logic ; gt : out std_logic ); end entity ; Somadores \u00b6 Os somadores s\u00e3o componentes que realizam a soma de dois n\u00fameros bin\u00e1rios, eles podem ser constru\u00eddos de diversas maneiras. in0[1..0] |-----------| ----/------>| | | | out[2..0] | ADDER |-----/-----> in1[1..0] | | ----/------>| | |-----------| entity ADDER is port ( in0 : in std_logic ( 1 downto 0 ); in1 : in std_logic ( 1 downto 0 ); o : out std_logic_vector ( 2 downto 0 ) ); end entity ; Um somador de dois vetores de dois bits cada possui o seguinte comportamento: in0 in1 out 00 00 000 00 01 001 01 01 010 10 01 011 10 11 101 11 11 110","title":"Componentes Digitais"},{"location":"Teoria-Componentes/#componentes-digitais","text":"Essa lista descreve os principais componentes digitais utilizados em projetos diversos e no do nosso Z01!","title":"Componentes Digitais"},{"location":"Teoria-Componentes/#portas-logicas","text":"buffer not and or nand nor xor","title":"portas l\u00f3gicas"},{"location":"Teoria-Componentes/#multiplexado-mux","text":"fonte wikipedia : Schematic of a 2-to-1 Multiplexer. It can be equated to a controlled switch. entity mux is port ( in0 : in std_logic ; in1 : in std_logic ; sel : in std_logic ; o : out std_logic ); end entity ; O mux como \u00e9 chamado o Multiplexador \u00e9 um componente que possui n entradas e uma sa\u00edda q , um sinal chamado de seletor sel seleciona qual entrada ir\u00e1 ser copiada para a sa\u00edda. As entradas n e a sa\u00edda q podem ser bin\u00e1rias ou vetor de tamanho m . A seguir uma tabela verdade para um mux de 2 entradas: in 0 in 1 Sel out 1 X 0 1 X 0 1 0 0 X 0 0 X 1 1 1 Note A tabela verdade do mux de 2 entradas possuir 3^2 linhas (o seletor conta como entrada), logo deveria ter 8 linhas. Por\u00e9m para simplificar, utilizamos o X que significa tanto faz 0 ou 1 , logo cada linha que possui X seria expandida para duas linhas, totalizando 8. Tip O tamanho do seletor deve ser um numero inteiro: log2(size(n)) log2(size(n)) . Quantidade de entras Tamanho do seletor 2 1 3 2 4 2 5 3 8 3","title":"Multiplexado (mux)"},{"location":"Teoria-Componentes/#demutiplexador-demux","text":"\u00c9 similar com o mux s\u00f3 que possui uma entrada in e n sa\u00eddas q , o demux conecta a entrada a alguma das sa\u00eddas, sendo controlado pelo seletor. fonte wikipedia : Schematic of a 1-to-2 Demultiplexer. Like a multiplexer, it can be equated to a controlled switch. entity demux is port ( in0 : in std_logic ; sel : in std_logic ; out0 : out std_logic ; out1 : out std_logic ); end entity ; A entrada in e a sa\u00edda q podem ser bin\u00e1rias ou de vetorer de tamanho m . A seguir uma tabela verdade para um demux de 2 sa\u00eddas: in Sel out 0 out 1 1 0 1 0 1 1 0 1 0 1 0 0 0 0 0 0","title":"Demutiplexador  (demux)"},{"location":"Teoria-Componentes/#enconders","text":"Enconders s\u00e3o componentes que codificam uma entrada em uma sa\u00edda de outro formato, algum exemplos s\u00e3o: BCD Gray code SevenSeg Priority Encoder","title":"Enconders"},{"location":"Teoria-Componentes/#bcd","text":"Binary-coded decimal (BCD) \u00e9 uma forma de codifica\u00e7\u00e3o de n\u00fameros inteiros em bin\u00e1rio na qual utiliza-se para cada d\u00edgito de um n\u00famero inteiro, 4 bits em bin\u00e1rio. Decimal Number BCD 8421 Code 0 0000 0000 01 0000 0001 02 0000 0010 03 0000 0011 04 0000 0100 05 0000 0101 06 0000 0110 07 0000 0111 08 0000 1000 09 0000 1001 10 (1+0) 0001 0000 11 (1+1) 0001 0001 12 (1+2) 0001 0010 continua em blocos de 4 |-----------| | | out1[3..0] x[n..0] | Binary |-----/--------> ----/------>| to | .... | BCD | outm[3..0] | |-----/--------> |-----------| entity binaryToBCD is port ( x : in std_logic ( 4 downto 0 ); out0 : out std_logic_vector ( 3 downto 0 ); -- Unidade out1 : out std_logic_vector ( 3 downto 0 ) -- Dezena ); end entity ; Tip O maior valor que um bloco de 4 bits do BCD assume \u00e9 o 1001 que \u00e9 referente ao n\u00famero inteiro 9. O BCD \u00e9 bastante utilizado para o controle de displays de 7 segmentos, como demonstrado na figura a seguir que usa o chip fonte electronics-tutorials","title":"BCD"},{"location":"Teoria-Componentes/#codigo-gray","text":"O c\u00f3digo gray \u00e9 uma forma de codificar n\u00fameros bin\u00e1rios, nessa codifica\u00e7\u00e3o apenas um bit muda por vez. C\u00f3digo decimal C\u00f3digo Bin\u00e1rio C\u00f3digo Gray 0 0000 0000 1 0001 0001 2 0010 0011 3 0011 0010 4 0100 0110 5 0101 0111 6 0110 0101 7 0111 0100 8 1000 1100 9 1001 1101 10 1010 1111 11 1011 1110 12 1100 1010 13 1101 1011 14 1110 1001 15 1111 1000 Note Esse sistema era muito utilizado antigamente quando rel\u00e9s eram utilizados no lugar de transistor, em um contador bin\u00e1rio comum ocorre de muitos bits mudarem de uma \u00fanica vez (0111 -> 1000) isso gerava um pico de corrente el\u00e9trica e muito ru\u00eddo. Tip Utilizamos o c\u00f3digo Gray para montar o Mapa de Karnaugh","title":"C\u00f3digo Gray"},{"location":"Teoria-Componentes/#comparador","text":"Comparadores s\u00e3o componentes que podem possuir diversos atributos, tais como comparar: se duas entradas s\u00e3o iguais se a entrada A \u00e9 maior que entrada B se entrada A \u00e9 igual a zero ... A seguir um exemplo de um comparador que possui apenas uma entrada x[1..0] e compara se essa entrada \u00e9 igual a zero ( x == 0 ), ou maior que zero ( x > 0 ). x (inteiro) x bin\u00e1rio eq gt 0 00 1 0 1 01 0 1 -1 11 0 0 -2 10 0 0 |-----------| | | eq x[1..0] | |----------> ----/------>| comparador| | | gt | |----------> |-----------| entity COMPARADOR is port ( x : in std_logic_vector ( 1 downto 0 ); eq : out std_logic ; gt : out std_logic ); end entity ;","title":"Comparador"},{"location":"Teoria-Componentes/#somadores","text":"Os somadores s\u00e3o componentes que realizam a soma de dois n\u00fameros bin\u00e1rios, eles podem ser constru\u00eddos de diversas maneiras. in0[1..0] |-----------| ----/------>| | | | out[2..0] | ADDER |-----/-----> in1[1..0] | | ----/------>| | |-----------| entity ADDER is port ( in0 : in std_logic ( 1 downto 0 ); in1 : in std_logic ( 1 downto 0 ); o : out std_logic_vector ( 2 downto 0 ) ); end entity ; Um somador de dois vetores de dois bits cada possui o seguinte comportamento: in0 in1 out 00 00 000 00 01 001 01 01 010 10 01 011 10 11 101 11 11 110","title":"Somadores"},{"location":"Teoria-Dados/","text":"Dados Digitais \u00b6 Estudando Bibliografia [Cap 3,5. NISAN, 2005] [Cap 8,11,12. FLOYD, 2011] [Cap 7 TOCCI] Leitura extra: Introduction to Digital Systems - Cap. 1 Introduction to Digital Systems - Cap. 2 V\u00eddeos (extra) KhanAcademy Why Do Computers Use 1s and 0s? Binary and Transistors Explained. Primeiras M\u00e1quinas de Calcular Wilhelm Schickard (1592\u20131635) construiu em 1623 uma calculadora para seu amigo astr\u00f4nomo Johannes Kepler. Esta \u00e9 a mais antiga calculadora mec\u00e2nica conhecida dequatro fun\u00e7\u00f5es, que foi descoberta por esbo\u00e7os da sua cria\u00e7\u00e3o. Fonte: http://people.idsia.ch/~juergen/schickard.html Hist\u00f3ria Blaise Pascal (1623-1662) inventou e produziu em 1642 a Pascaline. Ela s\u00f3 podia fazer adi\u00e7\u00e3o e subtra\u00e7\u00e3o, manipulando os n\u00fameros inscritos em seus mostradores. Ele construiu 50 deles ao longo de 10 anos, embora s\u00f3 tenha vendido 15. Fonte: http://www.computerhistory.org/revolution/calculators/1/47 Primeiras M\u00e1quinas de Calcular Gottfried Wilhelm von Leibniz (1646-1716) \u00e9 creditado como um dos inventores do c\u00e1lculo diferencial e integral. Por\u00e9m foi o primeiro a documentar e estudar profundamente o sistema bin\u00e1rio de numera\u00e7\u00e3o (base 2). Em 1672 Leibniz come\u00e7ou a inventar uma m\u00e1quina capaz de fazer as 4 opera\u00e7\u00f5es aritm\u00e9ticas, o Staffelwalze. Fonte: https://en.wikipedia.org/wiki/Gottfried_Wilhelm_Leibniz Sistemas num\u00e9ricos \u00e9 a maneira como os seres humanos representam n\u00fameros, ao decorrer da hist\u00f3ria as civiliza\u00e7\u00f5es assumiam maneiras diferentes de representar n\u00fameros, muitas vezes possuindo diferentes maneiras de codificar n\u00fameros na forma horal e escrita. O sistema decimal \u00e9 o mais utilizado pelas civiliza\u00e7\u00f5es modernas, nele utilizamos 9 s\u00edmbolos: 0 , 1 ... 9 para representar qualquer n\u00famero, essa nota\u00e7\u00e3o remonta do fato de possuirmos 10 dedos em nossas m\u00e3os. Nesse sistema, cada digito possui um peso da ordem 10^n 10^n : Algarismos indo-ar\u00e1bicos O sistema de numera\u00e7\u00e3o hindu como a conhecemos hoje, pode ser atribu\u00eddo a dois homens: o astr\u00f4nomo Ariabata (\u0906\u0930\u094d\u092f\u092d\u091f) e seu pupilo Bh\u0101skara I, durante 499-522 ac. Eles inventaram um sistema que se baseia na utiliza\u00e7\u00e3o da combina\u00e7\u00e3o de s\u00edlabas para formar os n\u00fameros, em um sistema incluindo a nota\u00e7\u00e3o do zero. Fonte: https://kids.britannica.com/kids/assembly/view/89478 Base 2 \u00b6 No sistema de base 2 possu\u00edmos apenas duas op\u00e7\u00f5es de s\u00edmbolo: 0 e 1 . Nesse base, cada posi\u00e7\u00e3o possui um peso da ordem 2^n 2^n : Dessa maneira podemos construir o valor que desejarmos de decimal ( m m ) em bin\u00e1rio, para isso ser\u00e1 necess\u00e1rio ocupar ceil(log2(m)) ceil(log2(m)) bits para armazenar o valor. A tabela a seguir ilustra algumas situa\u00e7\u00f5es: ceil : arredondar para cima Valor decimal Bits necess\u00e1rio 0 .. 1 0 .. 1 1 0 .. 3 0 .. 3 ceil(log2(4)) = 2 0 .. 4 0 .. 4 2 0 .. 6 0 .. 6 3 0 .. 7 0 .. 7 3 0 .. 15 0 .. 15 4 0 .. 31 0 .. 31 5 0 .. 63 0 .. 63 6 0 .. 127 0 .. 127 7 Supondo que possu\u00edmos um bin\u00e1rio de tr\u00eas d\u00edgitos, um contador de 0 a 7 em decimal seria em bin\u00e1rio: 000 -> 001 -> 010 -> 011 -> 100 -> 101 -> 110 -> 111 ... . O n\u00famero 45 em bin\u00e1rio \u00e9 0b101101 : 5 4 3 2 1 0 posi\u00e7\u00e3o 2^5 2^4 2^3 2^2 2^1 2^0 peso 32 16 8 4 2 1 valor 1 0 1 1 0 1 n\u00famero bin\u00e1rio Tip N\u00e3o tem muito segredo, para interpretar n\u00fameros bin\u00e1rios facilmente \u00e9 necess\u00e1rio pr\u00e1tica! Tip Para saber qual o valor m\u00e1ximo de decimal que \u00e9 poss\u00edvel armazenar com n n bits: 0 .. 2^n-1 0 .. 2^n-1 Nomenclatura Iremos utilizar os prefixos: : Para indicar um n\u00famero em decimal 0b : Para indicar um n\u00famero em bin\u00e1rio 0x : Para indicar um n\u00famero em hexadecimal Exemplo: hex bin dec 0x100 != 0b100 != 100 Defini\u00e7\u00f5es \u00b6 Em muitas linguagens de programa\u00e7\u00e3o \u00e9 necess\u00e1rio definirmos o tamanho da vari\u00e1vel que iremos armazenar um dado, para facilitar o entendimento damos nome a quantidade de bits que ela ir\u00e1 ocupar: 4 bits: nibble 8 bits: byte 16 bits: halfword 32 bits: word Convers\u00e3o Decimal <-> Bin\u00e1rio \u00b6 Existem diversas t\u00e9cnicas de convers\u00e3o bin\u00e1rio <-> decimal, a seguir detalhes de como realizar essas convers\u00f5es, o segredo \u00e9 entender os pesos de cada casa de um bit no sistema bin\u00e1rio e ent\u00e3o fazer a conta inversa. Base 16 \u00b6 A base 16, ou hexadecimal, \u00e9 uma outra maneira de representarmos n\u00fameros utilizando n\u00e3o s\u00f3 2 ou 10 s\u00edmbolos como acabamos de ver, mas 16 s\u00edmbolos!! \u00c9 como se conseguimos representar o valor 10 com um \u00fanico car\u00e1cter, no caso iremos utilizar o A . Nessa base, cada unidade possui um peso na forma 2^{16} 2^{16} : Um contador no formato hexadecimal possui a seguinte forma: Decimal Bin\u00e1rio Hexadecimal 0 0000 0 1 0001 1 2 0010 2 3 0011 3 4 0100 4 5 0101 5 6 0110 6 7 0111 7 8 1000 8 9 1001 9 10 1010 A 11 1011 B 12 1100 C 13 1101 D 14 1110 E 15 1111 F 16 0001 0000 10 Base 16 <-> Base 2 \u00b6 A convers\u00e3o de n\u00famero na base 16 para a base 2 e vice versa acontece de forma trivial. Da base 2 para a base 16 basta separar os bits da palavra em unidades de 4 casas e ent\u00e3o realizar a convers\u00e3o de cada grupo de 4 bits para o seu equivalente em Hexa. Para a convers\u00e3o de hexa para bin\u00e1rio, basta converter cada s\u00edmbolo de hexa para o seu equivalente em bin\u00e1rio (4 d\u00edgitos), seguindo a tabela anterior. Exemplos: a) 0xA01 para bin\u00e1rio: A 0 1 | \\ \\ | \\ \\ 1010 0000 0001 -> 0b1010_1000_00001 b) 0b1111_0101_1000 para hexa: 1111 0101 1000 | | | | | | F 5 8 -> 0xF58 Base 16 <-> Base 10 \u00b6 Para converter de Hexa para Decimal basta aplicar os pesos em cada um das unidades, como demonstrado a seguir: a) 0x10A para decimal: A 0 1 | | | | | | A.16^2 0.16^1 1.16^1 -> 10.256 + 0 + 1.16 = 2576 Para converter de Decimal para Hexa, uma das solu\u00e7\u00f5es mais triviais \u00e9 a de converter primeiro para bin\u00e1rio e ent\u00e3o agrupar os bits de 4 em 4 e converter para hexa: Decimal -> Bin\u00e1rio -> Hexa b) 42 -> 0x ??? 32 + 8 + 2 = 42 \\ | / --------------- \\ | / | | \\ | / | v 42 -> 0b101010 -> 0010 1010 -> 0x2A | ^ | | ---------- ----|---- | Blocos de 4 bits Base 8 \u00b6 Similar as outras bases de n\u00famero, o sistema octal \u00e9 composto por 8 s\u00edmbolos: 0 .. 7 , e nele cada posi\u00e7\u00e3o possui valor na forma de: 8^n 8^n . Veja o exemplo a seguir: a) 137 em octal para decimal: 1.8^2 + 3.8^1 + 7.8^0=95 1.8^2 + 3.8^1 + 7.8^0=95 2 1 0 posi\u00e7\u00e3o 8^2 8^1 8^0 peso 64 8 1 peso 1 3 7 valor octal 1*64 3*8 7*1 64+24+7=95 64+24+7=95 Para representarmos um valor octal em bin\u00e1rio, \u00e9 necess\u00e1rio reservarmos 3 bits para cada s\u00edmbolo do n\u00famero octal, a convers\u00e3o \u00e9 feita como no sistema hexadecimal, por\u00e9m aqui separando blocos de 3 bits: b) 137 para bin\u00e1rio: 001 011 111 O sistema octal \u00e9 utilizado no Linux para permiss\u00f5es de arquivos onde s\u00e3o necess\u00e1rios 3 bits para controlar se um usu\u00e1rio possui: acesso de leitura, escrita e/ou execu\u00e7\u00e3o de um determinado arquivo: Permission rwx Binary octal read, write and execute rwx 111 7 read and write rw- 110 6 read and execute r-x 101 5 read only r-- 100 4 write and execute -wx 011 3 write only -w- 010 2 execute only --x 001 1 none --- 000 0 Para modificar a permis\u00e3o de um arquivo no linux \u00e9 necess\u00e1rio fornecer a informa\u00e7\u00e3o para tr\u00eas grupos diferentes: usu\u00e1rio , grupos na qual o usu\u00e1rio faz parte e qualquer outro user. Para isso basta escrever no terminal: / others / $ chmod 754 FILE | \\ | \\ group user Isso da permiss\u00e3o de: user: read/write/execute group: read/execute others: read Povos Alguns povos da Am\u00e9rica do norte, Mexico e Europa utilizam o sistema octal pois consideram a quantidade dos v\u00e3os dos dedos, e n\u00e3o os dedos. Fonte: https://en.wikipedia.org/wiki/Octal#By_Native_Americans In\u00edcio da computa\u00e7\u00e3o Para que serve o sistema octal? No come\u00e7o da computa\u00e7\u00e3o a IBM possu\u00eda mem\u00f3rias com: 6-bit, 12-bit, 24-bit e 36-bit. Sendo todas as unidades divis\u00edveis por 3, o que facilita a interpreta\u00e7\u00e3o em um sistema octal. Outros sistemas \u00b6 Existem in\u00fameras maneiras de codifica\u00e7\u00e3o de n\u00fameros e/ou caracteres diversos, as mais utilizadas s\u00e3o: BCD ASCII UTF-8 BCD \u00b6 No sistema Binary-coded decimal (BCD) cada unidade de um sistema decimal \u00e9 convertido para 4 bits , muito parecido com a convers\u00e3o para Hexadecimal. Ele \u00e9 muito utilizado em rel\u00f3gios e quando h\u00e1 a necessidade de exibi\u00e7\u00e3o do valor em decimal em bin\u00e1rio (Display de 7 segmentos). Exemplo, 356 em BCD: 3 5 6 : Decimal 0011 0101 0110 : BCD ASCII \u00b6 ASCII (do ingl\u00eas American Standard Code for Information Interchange; \"C\u00f3digo Padr\u00e3o Americano para o Interc\u00e2mbio de Informa\u00e7\u00e3o\") \u00e9 uma maneira de codificar em bin\u00e1rio (8 bits) 95 sinais gr\u00e1ficos (letras, s\u00edmbolos e n\u00fameros) e alguns sinais de controle. \u00c9 muito utilizada pelos programas para armazenarem 'caracteres' e 'strings'. Fonte: www.asciitable.com Por exemplo, a palavra Insper convertido para ASCII fica da seguinte maneira (em decimal):","title":"Dados Digitais"},{"location":"Teoria-Dados/#dados-digitais","text":"Estudando Bibliografia [Cap 3,5. NISAN, 2005] [Cap 8,11,12. FLOYD, 2011] [Cap 7 TOCCI] Leitura extra: Introduction to Digital Systems - Cap. 1 Introduction to Digital Systems - Cap. 2 V\u00eddeos (extra) KhanAcademy Why Do Computers Use 1s and 0s? Binary and Transistors Explained. Primeiras M\u00e1quinas de Calcular Wilhelm Schickard (1592\u20131635) construiu em 1623 uma calculadora para seu amigo astr\u00f4nomo Johannes Kepler. Esta \u00e9 a mais antiga calculadora mec\u00e2nica conhecida dequatro fun\u00e7\u00f5es, que foi descoberta por esbo\u00e7os da sua cria\u00e7\u00e3o. Fonte: http://people.idsia.ch/~juergen/schickard.html Hist\u00f3ria Blaise Pascal (1623-1662) inventou e produziu em 1642 a Pascaline. Ela s\u00f3 podia fazer adi\u00e7\u00e3o e subtra\u00e7\u00e3o, manipulando os n\u00fameros inscritos em seus mostradores. Ele construiu 50 deles ao longo de 10 anos, embora s\u00f3 tenha vendido 15. Fonte: http://www.computerhistory.org/revolution/calculators/1/47 Primeiras M\u00e1quinas de Calcular Gottfried Wilhelm von Leibniz (1646-1716) \u00e9 creditado como um dos inventores do c\u00e1lculo diferencial e integral. Por\u00e9m foi o primeiro a documentar e estudar profundamente o sistema bin\u00e1rio de numera\u00e7\u00e3o (base 2). Em 1672 Leibniz come\u00e7ou a inventar uma m\u00e1quina capaz de fazer as 4 opera\u00e7\u00f5es aritm\u00e9ticas, o Staffelwalze. Fonte: https://en.wikipedia.org/wiki/Gottfried_Wilhelm_Leibniz Sistemas num\u00e9ricos \u00e9 a maneira como os seres humanos representam n\u00fameros, ao decorrer da hist\u00f3ria as civiliza\u00e7\u00f5es assumiam maneiras diferentes de representar n\u00fameros, muitas vezes possuindo diferentes maneiras de codificar n\u00fameros na forma horal e escrita. O sistema decimal \u00e9 o mais utilizado pelas civiliza\u00e7\u00f5es modernas, nele utilizamos 9 s\u00edmbolos: 0 , 1 ... 9 para representar qualquer n\u00famero, essa nota\u00e7\u00e3o remonta do fato de possuirmos 10 dedos em nossas m\u00e3os. Nesse sistema, cada digito possui um peso da ordem 10^n 10^n : Algarismos indo-ar\u00e1bicos O sistema de numera\u00e7\u00e3o hindu como a conhecemos hoje, pode ser atribu\u00eddo a dois homens: o astr\u00f4nomo Ariabata (\u0906\u0930\u094d\u092f\u092d\u091f) e seu pupilo Bh\u0101skara I, durante 499-522 ac. Eles inventaram um sistema que se baseia na utiliza\u00e7\u00e3o da combina\u00e7\u00e3o de s\u00edlabas para formar os n\u00fameros, em um sistema incluindo a nota\u00e7\u00e3o do zero. Fonte: https://kids.britannica.com/kids/assembly/view/89478","title":"Dados Digitais"},{"location":"Teoria-Dados/#base-2","text":"No sistema de base 2 possu\u00edmos apenas duas op\u00e7\u00f5es de s\u00edmbolo: 0 e 1 . Nesse base, cada posi\u00e7\u00e3o possui um peso da ordem 2^n 2^n : Dessa maneira podemos construir o valor que desejarmos de decimal ( m m ) em bin\u00e1rio, para isso ser\u00e1 necess\u00e1rio ocupar ceil(log2(m)) ceil(log2(m)) bits para armazenar o valor. A tabela a seguir ilustra algumas situa\u00e7\u00f5es: ceil : arredondar para cima Valor decimal Bits necess\u00e1rio 0 .. 1 0 .. 1 1 0 .. 3 0 .. 3 ceil(log2(4)) = 2 0 .. 4 0 .. 4 2 0 .. 6 0 .. 6 3 0 .. 7 0 .. 7 3 0 .. 15 0 .. 15 4 0 .. 31 0 .. 31 5 0 .. 63 0 .. 63 6 0 .. 127 0 .. 127 7 Supondo que possu\u00edmos um bin\u00e1rio de tr\u00eas d\u00edgitos, um contador de 0 a 7 em decimal seria em bin\u00e1rio: 000 -> 001 -> 010 -> 011 -> 100 -> 101 -> 110 -> 111 ... . O n\u00famero 45 em bin\u00e1rio \u00e9 0b101101 : 5 4 3 2 1 0 posi\u00e7\u00e3o 2^5 2^4 2^3 2^2 2^1 2^0 peso 32 16 8 4 2 1 valor 1 0 1 1 0 1 n\u00famero bin\u00e1rio Tip N\u00e3o tem muito segredo, para interpretar n\u00fameros bin\u00e1rios facilmente \u00e9 necess\u00e1rio pr\u00e1tica! Tip Para saber qual o valor m\u00e1ximo de decimal que \u00e9 poss\u00edvel armazenar com n n bits: 0 .. 2^n-1 0 .. 2^n-1 Nomenclatura Iremos utilizar os prefixos: : Para indicar um n\u00famero em decimal 0b : Para indicar um n\u00famero em bin\u00e1rio 0x : Para indicar um n\u00famero em hexadecimal Exemplo: hex bin dec 0x100 != 0b100 != 100","title":"Base 2"},{"location":"Teoria-Dados/#definicoes","text":"Em muitas linguagens de programa\u00e7\u00e3o \u00e9 necess\u00e1rio definirmos o tamanho da vari\u00e1vel que iremos armazenar um dado, para facilitar o entendimento damos nome a quantidade de bits que ela ir\u00e1 ocupar: 4 bits: nibble 8 bits: byte 16 bits: halfword 32 bits: word","title":"Defini\u00e7\u00f5es"},{"location":"Teoria-Dados/#conversao-decimal-binario","text":"Existem diversas t\u00e9cnicas de convers\u00e3o bin\u00e1rio <-> decimal, a seguir detalhes de como realizar essas convers\u00f5es, o segredo \u00e9 entender os pesos de cada casa de um bit no sistema bin\u00e1rio e ent\u00e3o fazer a conta inversa.","title":"Convers\u00e3o Decimal &lt;-&gt; Bin\u00e1rio"},{"location":"Teoria-Dados/#base-16","text":"A base 16, ou hexadecimal, \u00e9 uma outra maneira de representarmos n\u00fameros utilizando n\u00e3o s\u00f3 2 ou 10 s\u00edmbolos como acabamos de ver, mas 16 s\u00edmbolos!! \u00c9 como se conseguimos representar o valor 10 com um \u00fanico car\u00e1cter, no caso iremos utilizar o A . Nessa base, cada unidade possui um peso na forma 2^{16} 2^{16} : Um contador no formato hexadecimal possui a seguinte forma: Decimal Bin\u00e1rio Hexadecimal 0 0000 0 1 0001 1 2 0010 2 3 0011 3 4 0100 4 5 0101 5 6 0110 6 7 0111 7 8 1000 8 9 1001 9 10 1010 A 11 1011 B 12 1100 C 13 1101 D 14 1110 E 15 1111 F 16 0001 0000 10","title":"Base 16"},{"location":"Teoria-Dados/#base-16-base-2","text":"A convers\u00e3o de n\u00famero na base 16 para a base 2 e vice versa acontece de forma trivial. Da base 2 para a base 16 basta separar os bits da palavra em unidades de 4 casas e ent\u00e3o realizar a convers\u00e3o de cada grupo de 4 bits para o seu equivalente em Hexa. Para a convers\u00e3o de hexa para bin\u00e1rio, basta converter cada s\u00edmbolo de hexa para o seu equivalente em bin\u00e1rio (4 d\u00edgitos), seguindo a tabela anterior. Exemplos: a) 0xA01 para bin\u00e1rio: A 0 1 | \\ \\ | \\ \\ 1010 0000 0001 -> 0b1010_1000_00001 b) 0b1111_0101_1000 para hexa: 1111 0101 1000 | | | | | | F 5 8 -> 0xF58","title":"Base 16 &lt;-&gt; Base 2"},{"location":"Teoria-Dados/#base-16-base-10","text":"Para converter de Hexa para Decimal basta aplicar os pesos em cada um das unidades, como demonstrado a seguir: a) 0x10A para decimal: A 0 1 | | | | | | A.16^2 0.16^1 1.16^1 -> 10.256 + 0 + 1.16 = 2576 Para converter de Decimal para Hexa, uma das solu\u00e7\u00f5es mais triviais \u00e9 a de converter primeiro para bin\u00e1rio e ent\u00e3o agrupar os bits de 4 em 4 e converter para hexa: Decimal -> Bin\u00e1rio -> Hexa b) 42 -> 0x ??? 32 + 8 + 2 = 42 \\ | / --------------- \\ | / | | \\ | / | v 42 -> 0b101010 -> 0010 1010 -> 0x2A | ^ | | ---------- ----|---- | Blocos de 4 bits","title":"Base 16 &lt;-&gt; Base 10"},{"location":"Teoria-Dados/#base-8","text":"Similar as outras bases de n\u00famero, o sistema octal \u00e9 composto por 8 s\u00edmbolos: 0 .. 7 , e nele cada posi\u00e7\u00e3o possui valor na forma de: 8^n 8^n . Veja o exemplo a seguir: a) 137 em octal para decimal: 1.8^2 + 3.8^1 + 7.8^0=95 1.8^2 + 3.8^1 + 7.8^0=95 2 1 0 posi\u00e7\u00e3o 8^2 8^1 8^0 peso 64 8 1 peso 1 3 7 valor octal 1*64 3*8 7*1 64+24+7=95 64+24+7=95 Para representarmos um valor octal em bin\u00e1rio, \u00e9 necess\u00e1rio reservarmos 3 bits para cada s\u00edmbolo do n\u00famero octal, a convers\u00e3o \u00e9 feita como no sistema hexadecimal, por\u00e9m aqui separando blocos de 3 bits: b) 137 para bin\u00e1rio: 001 011 111 O sistema octal \u00e9 utilizado no Linux para permiss\u00f5es de arquivos onde s\u00e3o necess\u00e1rios 3 bits para controlar se um usu\u00e1rio possui: acesso de leitura, escrita e/ou execu\u00e7\u00e3o de um determinado arquivo: Permission rwx Binary octal read, write and execute rwx 111 7 read and write rw- 110 6 read and execute r-x 101 5 read only r-- 100 4 write and execute -wx 011 3 write only -w- 010 2 execute only --x 001 1 none --- 000 0 Para modificar a permis\u00e3o de um arquivo no linux \u00e9 necess\u00e1rio fornecer a informa\u00e7\u00e3o para tr\u00eas grupos diferentes: usu\u00e1rio , grupos na qual o usu\u00e1rio faz parte e qualquer outro user. Para isso basta escrever no terminal: / others / $ chmod 754 FILE | \\ | \\ group user Isso da permiss\u00e3o de: user: read/write/execute group: read/execute others: read Povos Alguns povos da Am\u00e9rica do norte, Mexico e Europa utilizam o sistema octal pois consideram a quantidade dos v\u00e3os dos dedos, e n\u00e3o os dedos. Fonte: https://en.wikipedia.org/wiki/Octal#By_Native_Americans In\u00edcio da computa\u00e7\u00e3o Para que serve o sistema octal? No come\u00e7o da computa\u00e7\u00e3o a IBM possu\u00eda mem\u00f3rias com: 6-bit, 12-bit, 24-bit e 36-bit. Sendo todas as unidades divis\u00edveis por 3, o que facilita a interpreta\u00e7\u00e3o em um sistema octal.","title":"Base 8"},{"location":"Teoria-Dados/#outros-sistemas","text":"Existem in\u00fameras maneiras de codifica\u00e7\u00e3o de n\u00fameros e/ou caracteres diversos, as mais utilizadas s\u00e3o: BCD ASCII UTF-8","title":"Outros sistemas"},{"location":"Teoria-Dados/#bcd","text":"No sistema Binary-coded decimal (BCD) cada unidade de um sistema decimal \u00e9 convertido para 4 bits , muito parecido com a convers\u00e3o para Hexadecimal. Ele \u00e9 muito utilizado em rel\u00f3gios e quando h\u00e1 a necessidade de exibi\u00e7\u00e3o do valor em decimal em bin\u00e1rio (Display de 7 segmentos). Exemplo, 356 em BCD: 3 5 6 : Decimal 0011 0101 0110 : BCD","title":"BCD"},{"location":"Teoria-Dados/#ascii","text":"ASCII (do ingl\u00eas American Standard Code for Information Interchange; \"C\u00f3digo Padr\u00e3o Americano para o Interc\u00e2mbio de Informa\u00e7\u00e3o\") \u00e9 uma maneira de codificar em bin\u00e1rio (8 bits) 95 sinais gr\u00e1ficos (letras, s\u00edmbolos e n\u00fameros) e alguns sinais de controle. \u00c9 muito utilizada pelos programas para armazenarem 'caracteres' e 'strings'. Fonte: www.asciitable.com Por exemplo, a palavra Insper convertido para ASCII fica da seguinte maneira (em decimal):","title":"ASCII"},{"location":"Teoria-Logica-Sequencial/","text":"L\u00f3gica Sequencial \u00b6 Colossus O Colossus foi um computador Brit\u00e2nico de 1700 v\u00e1lvulas, feito em 1943 para decifrar c\u00f3digos nazistas durante a segunda guerra mundial. O computador e planos foram destru\u00eddos para manter o projeto em segredo. Uma caracter\u00edsta importante desse computador \u00e9 que ele podia ser programado e reprogramado para decifrar as mensagens nazistas. Essa flexibilidade de programa\u00e7\u00e3o foi revolucion\u00e1ria. O computador usava um mecanismo de mem\u00f3ria chamado de flip-flops, que foi desenvolvido muitos anos antes pelos professores http://www.britannica.com/technology/computer/images-videos/The-Colossus-computer-at-Bletchley-Park-Buckinghamshire-England-1943/19626 http://www.computerhistory.org/revolution/digital-logic/12/269 https://en.wikipedia.org/wiki/Flip-flop_(electronics ) At\u00e9 o momento s\u00f3 usamos circuitos criados com l\u00f3gica combinacional. Por\u00e9m nem todos os tipos de l\u00f3gica digital podem ser enquadrados nessa categoria. Nessas l\u00f3gicas uma tabela verdade define bem a sa\u00edda de um circuito. Por exemplo, podemos dizer que ao se colocar os sinais nas entradas de uma unidade l\u00f3gica aritm\u00e9tica temos quase que instantaneamente uma sa\u00edda v\u00e1lida e independente dos sinais que estavam anteriormente no circuito. J\u00e1 na l\u00f3gica sequencial o estado anterior das entradas influencia na sa\u00edda, ou seja, essa l\u00f3gica possui uma mem\u00f3ria. E \u00e9 justamente essa caracter\u00edstica de mem\u00f3ria de estados anteriores que nos interessa. Podemos por exemplo armazenar valores para uso futuro, ou tomar uma decis\u00e3o com base no estado anterior/atual. http://www.inf.pucrs.br/~emoreno/undergraduate/SI/orgarq/class_files/Aula06.pdf http://www.ee.surrey.ac.uk/Projects/CAL/seq-switching/General_seq_circ.htm Sistemas sequ\u00eancias s\u00e3o em sua grande combinados com sistema s\u00edncrono, onde todos o circuito digital opera em um determinado ritmo, esse sinal \u00e9 conhecido como clock do sistema. Circuitos biest\u00e1veis \u00b6 Um dos circuitos sequenciais mais simples existentes s\u00e3o os circuitos biest\u00e1veis, que s\u00e3o chamados assim pois permanecem em um dos dois estados bin\u00e1rios ( 0 ou 1 ) enquanto estiver energizado. Eles s\u00e3o usados para armazenar e recuperar os estados dos bits dos computadores. http://hyperphysics.phy-astr.gsu.edu/hbase/electronic/nandlatch.html#c1 O latch SR \u00e9 um circuito biest\u00e1vel composto de duas portas NOR que armazenam um valor simples. Fonte: WikiBook Nesse circuito normalmente as entradas S e R , conhecidas como Set e Reset, ficam em n\u00edvel baixo. Enquanto estiverem assim o valor das sa\u00eddas Q e \\bar{Q} \\bar{Q} , que \u00e9 sempre o inverso do Q, se mantem inalterados. Se o n\u00edvel do S subir ( 1 ) a sa\u00edda Q fica em n\u00edvel alto, ou podemos dizer 1 , j\u00e1 se o n\u00edvel do R , Q fica em n\u00edvel l\u00f3gico baixo, ou seja 0 . A tabela a seguir ilustra o texto: S S R R Q Q \\bar{Q} \\bar{Q} 0 0 Armazenado !Armazenado 1 0 1 0 0 1 0 1 1 1 metaest\u00e1vel metaest\u00e1vel Um outro circuito biest\u00e1vel \u00e9 o latch tipo D, nesse caso o circuito mantem o valor da entrada de Dados D enquanto a entrada de Enable E estiver em n\u00edvel alto, se o sinal E for para n\u00edvel baixo o circuito n\u00e3o muda de estado. Esse componente possui a tabela verdade a seguir: E E D D Q Q \\bar{Q} \\bar{Q} 0 0 Armazenado !Armazenado 0 1 Armazenado !Armazenado 1 0 Copia Entrada D : 0 Copia Entrada D negada: 1 0 1 Copia Entrada D : 1 Copia Entrada D negada: 0 Clock \u00b6 Em sistemas digitais, precisamos considerar que cada porta l\u00f3gica possui um tempo de propaga\u00e7\u00e3o do resultado, a resposta de uma porta AND n\u00e3o \u00e9 imediata, leva alguns ns para que o resultado da opera\u00e7\u00e3o a and b estabilize na sa\u00edda. Cada porta possui tempos de propaga\u00e7\u00e3o distintos (at\u00e9 uma mesma porta AND possui diferen\u00e7a de tempo entre elas). Agora imagine um sistema com centenas de milhares de portas l\u00f3gicas onde um sinal pode percorrer por diversos caminhos distintos, mas precisa chegar na sa\u00edda ao mesmo tempo. Muito dif\u00edcil ne? Para isso utilizamos um sistema s\u00edncrono, que pretende resolver esse problema. Podemos fazer analogia com uma banda que possui um saxofonista muito virtuoso chamado de Nand-Parker e um guitarrista mais calmo chamado de Or-Brubeck, o que aconteceria se cada um tocasse em seu tempo? O resultado com certeza n\u00e3o serial bom! Para isso tem o ritmo/ batida, na qual os m\u00fasicos por mais 'velozes/lentos' que sejam, precisam seguir. Em um sistema digital, esse \u00e9 um dos papeis do clock! fazer com que todos executem ao mesmo tempo. O clock \u00e9 um sinal el\u00e9trico peri\u00f3dico utilizado para sincronizar sistemas digitais, utilizado em todo circuito s\u00edncrono, serve como o 'baterista' da banda, dando o ritmo de execu\u00e7\u00e3o para a eletr\u00f4nica. A cada novo clock (instante que ocorre uma mudan\u00e7a no sinal 1 -> 0 ou de 0 -> 1 ), o sistema come\u00e7a uma nova opera\u00e7\u00e3o. O sinal do clock \u00e9 geralmente peri\u00f3dico e de modula\u00e7\u00e3o 50% (50% em alto e 50% em baixo): Clock de 3Ghz S\u00e3o 3 bilh\u00f5es 3_000_000_000 de bordas ( 0 -> 1 ) em um segundo!! Imagine que a cada borda, uma opera\u00e7\u00e3o \u00e9 realizada no computador, s\u00e3o 3 bilh\u00f5es de opera\u00e7\u00f5es em um \u00fanico segundo.... Overclock? Muitos de voc\u00eas j\u00e1 ouviram falar overclock? Nessa t\u00e9cnica, aumentasse o clock para uma frequ\u00eancia na qual o sistema n\u00e3o foi projetado para operar, consequ\u00eancias disso s\u00e3o: Poss\u00edveis erros de processamento (dado que parte do circuito pode ser mais lento que o 1/f) Superaquecimento do chip, j\u00e1 que a tecnologia atual utilizada para fabrica\u00e7\u00e3o de componentes eletr\u00f4nicos (MOSFET) 'gasta' energia a cada clock. Com um aumento no clock, mais energia \u00e9 gasta por segundo. Borda Nem todo sistema digital trabalha com borda de subida ( rising_edge ) ( 0 -> 1 ), outras op\u00e7\u00f5es s\u00e3o: borda de descida ( falling_edge ): 1 -> 0 . double data rate (DDR): Uma nova mudan\u00e7a a cada borda, subida e descida. ( Dai que vem o nome da mem\u00f3ria DDR4 do seu computador! ) http://slideplayer.com.br/slide/370185/ http://www.plantation-productions.com/Webster/www.artofasm.com/Linux/HTML/SystemOrganizationa4.html http://www.gitam.edu/eresource/comp/gvr/6.1.htm Flip-Flop \u00b6 Flip-Flop (FF) \u00e9 um circuito similar ao LATCH por\u00e9m s\u00edncrono, ou seja, a mudan\u00e7a na sa\u00edda ( Q ) s\u00f3 ocorre na borda do clock. Tip FF s\u00e3o usados por diversas raz\u00f5es, nesse curso vamos explorar o uso do FF para a cria\u00e7\u00e3o de uma unidade de armazenamento de bits. Note Sabe o CI 555? Aquele usado em acionamentos para gerar o PWM? Internamente ele possui um FF do tipo D: Fonte: https://www.electronics-tutorials.ws/waveforms/555_timer.html Existem diversos tipos de FF, mas vamos olhar apenas para o FF do tipo D. FF tipo D \u00b6 O FF tipo D possui as seguintes portas: D D entrada do de Dado Q Q sa\u00edda do dado copiado \\bar{Q} \\bar{Q} sa\u00edda do dado copiado CLK CLK entrada do clock Toda vez que o clock \u00e9 mudado, o sinal que est\u00e1 na entrada D \u00e9 copiado para a sa\u00edda Q , conforme diagrama a seguir: A tabela verdade desse componente \u00e9: D D (in) clk clk (in) Q Q (out) 0 0 Q* 1 1 Q* 0 ^ 0 1 ^ 1 ^ : borda de subida Q* : Q armazenado anteriormente Clear e Preset \u00b6 FF do tipo D podem possuir mais dois sinais de controle: clear e preset . O sinal clear faz com que a sa\u00edda Q v\u00e1 para 0 independe da entada D e do clock . O sinal preset faz com que a sa\u00edda Q v\u00e1 para 1 independente da entrada D e do clock . A tabela verdade com esses sinais a mais fica: D D (in) clr clr set set clk clk (in) Q Q (out) x 0 0 x Q* x 1 0 x 0 x 0 1 x 1 0 0 0 ^ 0 1 0 0 ^ 1","title":"L\u00f3gica Sequencial"},{"location":"Teoria-Logica-Sequencial/#logica-sequencial","text":"Colossus O Colossus foi um computador Brit\u00e2nico de 1700 v\u00e1lvulas, feito em 1943 para decifrar c\u00f3digos nazistas durante a segunda guerra mundial. O computador e planos foram destru\u00eddos para manter o projeto em segredo. Uma caracter\u00edsta importante desse computador \u00e9 que ele podia ser programado e reprogramado para decifrar as mensagens nazistas. Essa flexibilidade de programa\u00e7\u00e3o foi revolucion\u00e1ria. O computador usava um mecanismo de mem\u00f3ria chamado de flip-flops, que foi desenvolvido muitos anos antes pelos professores http://www.britannica.com/technology/computer/images-videos/The-Colossus-computer-at-Bletchley-Park-Buckinghamshire-England-1943/19626 http://www.computerhistory.org/revolution/digital-logic/12/269 https://en.wikipedia.org/wiki/Flip-flop_(electronics ) At\u00e9 o momento s\u00f3 usamos circuitos criados com l\u00f3gica combinacional. Por\u00e9m nem todos os tipos de l\u00f3gica digital podem ser enquadrados nessa categoria. Nessas l\u00f3gicas uma tabela verdade define bem a sa\u00edda de um circuito. Por exemplo, podemos dizer que ao se colocar os sinais nas entradas de uma unidade l\u00f3gica aritm\u00e9tica temos quase que instantaneamente uma sa\u00edda v\u00e1lida e independente dos sinais que estavam anteriormente no circuito. J\u00e1 na l\u00f3gica sequencial o estado anterior das entradas influencia na sa\u00edda, ou seja, essa l\u00f3gica possui uma mem\u00f3ria. E \u00e9 justamente essa caracter\u00edstica de mem\u00f3ria de estados anteriores que nos interessa. Podemos por exemplo armazenar valores para uso futuro, ou tomar uma decis\u00e3o com base no estado anterior/atual. http://www.inf.pucrs.br/~emoreno/undergraduate/SI/orgarq/class_files/Aula06.pdf http://www.ee.surrey.ac.uk/Projects/CAL/seq-switching/General_seq_circ.htm Sistemas sequ\u00eancias s\u00e3o em sua grande combinados com sistema s\u00edncrono, onde todos o circuito digital opera em um determinado ritmo, esse sinal \u00e9 conhecido como clock do sistema.","title":"L\u00f3gica Sequencial"},{"location":"Teoria-Logica-Sequencial/#circuitos-biestaveis","text":"Um dos circuitos sequenciais mais simples existentes s\u00e3o os circuitos biest\u00e1veis, que s\u00e3o chamados assim pois permanecem em um dos dois estados bin\u00e1rios ( 0 ou 1 ) enquanto estiver energizado. Eles s\u00e3o usados para armazenar e recuperar os estados dos bits dos computadores. http://hyperphysics.phy-astr.gsu.edu/hbase/electronic/nandlatch.html#c1 O latch SR \u00e9 um circuito biest\u00e1vel composto de duas portas NOR que armazenam um valor simples. Fonte: WikiBook Nesse circuito normalmente as entradas S e R , conhecidas como Set e Reset, ficam em n\u00edvel baixo. Enquanto estiverem assim o valor das sa\u00eddas Q e \\bar{Q} \\bar{Q} , que \u00e9 sempre o inverso do Q, se mantem inalterados. Se o n\u00edvel do S subir ( 1 ) a sa\u00edda Q fica em n\u00edvel alto, ou podemos dizer 1 , j\u00e1 se o n\u00edvel do R , Q fica em n\u00edvel l\u00f3gico baixo, ou seja 0 . A tabela a seguir ilustra o texto: S S R R Q Q \\bar{Q} \\bar{Q} 0 0 Armazenado !Armazenado 1 0 1 0 0 1 0 1 1 1 metaest\u00e1vel metaest\u00e1vel Um outro circuito biest\u00e1vel \u00e9 o latch tipo D, nesse caso o circuito mantem o valor da entrada de Dados D enquanto a entrada de Enable E estiver em n\u00edvel alto, se o sinal E for para n\u00edvel baixo o circuito n\u00e3o muda de estado. Esse componente possui a tabela verdade a seguir: E E D D Q Q \\bar{Q} \\bar{Q} 0 0 Armazenado !Armazenado 0 1 Armazenado !Armazenado 1 0 Copia Entrada D : 0 Copia Entrada D negada: 1 0 1 Copia Entrada D : 1 Copia Entrada D negada: 0","title":"Circuitos biest\u00e1veis"},{"location":"Teoria-Logica-Sequencial/#clock","text":"Em sistemas digitais, precisamos considerar que cada porta l\u00f3gica possui um tempo de propaga\u00e7\u00e3o do resultado, a resposta de uma porta AND n\u00e3o \u00e9 imediata, leva alguns ns para que o resultado da opera\u00e7\u00e3o a and b estabilize na sa\u00edda. Cada porta possui tempos de propaga\u00e7\u00e3o distintos (at\u00e9 uma mesma porta AND possui diferen\u00e7a de tempo entre elas). Agora imagine um sistema com centenas de milhares de portas l\u00f3gicas onde um sinal pode percorrer por diversos caminhos distintos, mas precisa chegar na sa\u00edda ao mesmo tempo. Muito dif\u00edcil ne? Para isso utilizamos um sistema s\u00edncrono, que pretende resolver esse problema. Podemos fazer analogia com uma banda que possui um saxofonista muito virtuoso chamado de Nand-Parker e um guitarrista mais calmo chamado de Or-Brubeck, o que aconteceria se cada um tocasse em seu tempo? O resultado com certeza n\u00e3o serial bom! Para isso tem o ritmo/ batida, na qual os m\u00fasicos por mais 'velozes/lentos' que sejam, precisam seguir. Em um sistema digital, esse \u00e9 um dos papeis do clock! fazer com que todos executem ao mesmo tempo. O clock \u00e9 um sinal el\u00e9trico peri\u00f3dico utilizado para sincronizar sistemas digitais, utilizado em todo circuito s\u00edncrono, serve como o 'baterista' da banda, dando o ritmo de execu\u00e7\u00e3o para a eletr\u00f4nica. A cada novo clock (instante que ocorre uma mudan\u00e7a no sinal 1 -> 0 ou de 0 -> 1 ), o sistema come\u00e7a uma nova opera\u00e7\u00e3o. O sinal do clock \u00e9 geralmente peri\u00f3dico e de modula\u00e7\u00e3o 50% (50% em alto e 50% em baixo): Clock de 3Ghz S\u00e3o 3 bilh\u00f5es 3_000_000_000 de bordas ( 0 -> 1 ) em um segundo!! Imagine que a cada borda, uma opera\u00e7\u00e3o \u00e9 realizada no computador, s\u00e3o 3 bilh\u00f5es de opera\u00e7\u00f5es em um \u00fanico segundo.... Overclock? Muitos de voc\u00eas j\u00e1 ouviram falar overclock? Nessa t\u00e9cnica, aumentasse o clock para uma frequ\u00eancia na qual o sistema n\u00e3o foi projetado para operar, consequ\u00eancias disso s\u00e3o: Poss\u00edveis erros de processamento (dado que parte do circuito pode ser mais lento que o 1/f) Superaquecimento do chip, j\u00e1 que a tecnologia atual utilizada para fabrica\u00e7\u00e3o de componentes eletr\u00f4nicos (MOSFET) 'gasta' energia a cada clock. Com um aumento no clock, mais energia \u00e9 gasta por segundo. Borda Nem todo sistema digital trabalha com borda de subida ( rising_edge ) ( 0 -> 1 ), outras op\u00e7\u00f5es s\u00e3o: borda de descida ( falling_edge ): 1 -> 0 . double data rate (DDR): Uma nova mudan\u00e7a a cada borda, subida e descida. ( Dai que vem o nome da mem\u00f3ria DDR4 do seu computador! ) http://slideplayer.com.br/slide/370185/ http://www.plantation-productions.com/Webster/www.artofasm.com/Linux/HTML/SystemOrganizationa4.html http://www.gitam.edu/eresource/comp/gvr/6.1.htm","title":"Clock"},{"location":"Teoria-Logica-Sequencial/#flip-flop","text":"Flip-Flop (FF) \u00e9 um circuito similar ao LATCH por\u00e9m s\u00edncrono, ou seja, a mudan\u00e7a na sa\u00edda ( Q ) s\u00f3 ocorre na borda do clock. Tip FF s\u00e3o usados por diversas raz\u00f5es, nesse curso vamos explorar o uso do FF para a cria\u00e7\u00e3o de uma unidade de armazenamento de bits. Note Sabe o CI 555? Aquele usado em acionamentos para gerar o PWM? Internamente ele possui um FF do tipo D: Fonte: https://www.electronics-tutorials.ws/waveforms/555_timer.html Existem diversos tipos de FF, mas vamos olhar apenas para o FF do tipo D.","title":"Flip-Flop"},{"location":"Teoria-Logica-Sequencial/#ff-tipo-d","text":"O FF tipo D possui as seguintes portas: D D entrada do de Dado Q Q sa\u00edda do dado copiado \\bar{Q} \\bar{Q} sa\u00edda do dado copiado CLK CLK entrada do clock Toda vez que o clock \u00e9 mudado, o sinal que est\u00e1 na entrada D \u00e9 copiado para a sa\u00edda Q , conforme diagrama a seguir: A tabela verdade desse componente \u00e9: D D (in) clk clk (in) Q Q (out) 0 0 Q* 1 1 Q* 0 ^ 0 1 ^ 1 ^ : borda de subida Q* : Q armazenado anteriormente","title":"FF tipo D"},{"location":"Teoria-Logica-Sequencial/#clear-e-preset","text":"FF do tipo D podem possuir mais dois sinais de controle: clear e preset . O sinal clear faz com que a sa\u00edda Q v\u00e1 para 0 independe da entada D e do clock . O sinal preset faz com que a sa\u00edda Q v\u00e1 para 1 independente da entrada D e do clock . A tabela verdade com esses sinais a mais fica: D D (in) clr clr set set clk clk (in) Q Q (out) x 0 0 x Q* x 1 0 x 0 x 0 1 x 1 0 0 0 ^ 0 1 0 0 ^ 1","title":"Clear e Preset"},{"location":"Teoria-Numeros-Binarios/","text":"N\u00fameros bin\u00e1rios \u00b6 Conte\u00fado: Complemento de um/ Complemento de dois/ Ponto fixo/ Soma bin\u00e1ria/ Podemos utilizar n\u00fameros bin\u00e1rios para codificar qualquer tipo de dado, como vimos na teoria de dados digitais. Mas ainda n\u00e3o sabemos como utilizar n\u00fameros bin\u00e1rios para representar: n\u00fameros inteiros que possam ser negativos e n\u00fameros reais (exe: 1,032 ). Essa teoria ir\u00e1 tratar desses temas e tamb\u00e9m da parte referente a opera\u00e7\u00f5es com n\u00fameros bin\u00e1rios (soma e subtra\u00e7\u00e3o). Soma bin\u00e1ria \u00b6 A soma bin\u00e1ria \u00e9 realizada de maneira similar a soma de decimais, s\u00f3 que precisamos notar que 1 + 1 em bin\u00e1rio ( esse um \u00e9 de soma n\u00e3o de OR ), resulta em 10 , esse 1 do estouro e que passa para a pr\u00f3xima casa \u00e9 chamado de carry . Esse carry \u00e9 similar ao vai um em uma soma decimal, no caso quando somamos 9 + 3 o resultado \u00e9 12 . Exemplos consideram Somador de 8 bits N\u00fameros inteiros n\u00e3o sinalizados 0xAA + 0x55 = 0xFF : Carry 1 0 1 0 1 0 1 0 : A 0 1 0 1 0 1 0 1 + : B --------------- 1 1 1 1 1 1 1 1 : Resultado (A+B) Precisamos perceber que cada bit \u00e9 armazenado 'real', um sistema com 8 bits n\u00e3o consegue armazenar 9 bits, e se houver um estouro no \u00faltimo bit essa informa\u00e7\u00e3o ser\u00e1 perdida. 0x80 + 0x80 = 0x100, mas resulta em 0x00 por conta do somador ser 8 bits: carry \u00e9 perdido 1 \\ 1 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 + --------------- 0 0 0 0 0 0 0 0 0x03 + 0x81 = 0x84 1 1 : carry (vai um) \\ 0 0 0 0 0 0 1 1 1 0 0 0 0 0 0 1 + --------------- 1 0 0 0 0 1 0 0 complemento de 1 \u00b6 Warning Forma 'errada' de armazenar n\u00fameros sinalizados (+, -) No complemento de 1, utilizamos a casa mais significativa de um vetor de bits para representar se o n\u00famero \u00e9 positivo ( 0 ) ou negativo ( 1 ). Exemplo (utilizando 4 bits): Valor +1 em bin\u00e1rio, com complemento de 1 0001 ^ | indica que o valor \u00e9 positivo Valor -1 em bin\u00e1rio, com complemento de 1 1001 ^ | indica que o valor \u00e9 negativo O problema do complemento de 1 \u00e9 que: Possu\u00edmos duas representa\u00e7\u00f5es para o valor 0: 0000 e 1000 Opera\u00e7\u00f5es de soma n\u00e3o funcionam corretamente entre os dois n\u00fameros codificados em complemento de 1. Complemento de 2 \u00b6 O complemento de dois \u00e9 uma outra maneira de representar n\u00fameros sinalizados com bits, para obter um n\u00famero positivo <-> negativo nessa nota\u00e7\u00e3o \u00e9 necess\u00e1rio seguir os seguintes passos: Inverter todos os bits (not bit a bit) da palavra original Somar um a palavra invertida","title":"N\u00fameros bin\u00e1rios"},{"location":"Teoria-Numeros-Binarios/#numeros-binarios","text":"Conte\u00fado: Complemento de um/ Complemento de dois/ Ponto fixo/ Soma bin\u00e1ria/ Podemos utilizar n\u00fameros bin\u00e1rios para codificar qualquer tipo de dado, como vimos na teoria de dados digitais. Mas ainda n\u00e3o sabemos como utilizar n\u00fameros bin\u00e1rios para representar: n\u00fameros inteiros que possam ser negativos e n\u00fameros reais (exe: 1,032 ). Essa teoria ir\u00e1 tratar desses temas e tamb\u00e9m da parte referente a opera\u00e7\u00f5es com n\u00fameros bin\u00e1rios (soma e subtra\u00e7\u00e3o).","title":"N\u00fameros bin\u00e1rios"},{"location":"Teoria-Numeros-Binarios/#soma-binaria","text":"A soma bin\u00e1ria \u00e9 realizada de maneira similar a soma de decimais, s\u00f3 que precisamos notar que 1 + 1 em bin\u00e1rio ( esse um \u00e9 de soma n\u00e3o de OR ), resulta em 10 , esse 1 do estouro e que passa para a pr\u00f3xima casa \u00e9 chamado de carry . Esse carry \u00e9 similar ao vai um em uma soma decimal, no caso quando somamos 9 + 3 o resultado \u00e9 12 . Exemplos consideram Somador de 8 bits N\u00fameros inteiros n\u00e3o sinalizados 0xAA + 0x55 = 0xFF : Carry 1 0 1 0 1 0 1 0 : A 0 1 0 1 0 1 0 1 + : B --------------- 1 1 1 1 1 1 1 1 : Resultado (A+B) Precisamos perceber que cada bit \u00e9 armazenado 'real', um sistema com 8 bits n\u00e3o consegue armazenar 9 bits, e se houver um estouro no \u00faltimo bit essa informa\u00e7\u00e3o ser\u00e1 perdida. 0x80 + 0x80 = 0x100, mas resulta em 0x00 por conta do somador ser 8 bits: carry \u00e9 perdido 1 \\ 1 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 + --------------- 0 0 0 0 0 0 0 0 0x03 + 0x81 = 0x84 1 1 : carry (vai um) \\ 0 0 0 0 0 0 1 1 1 0 0 0 0 0 0 1 + --------------- 1 0 0 0 0 1 0 0","title":"Soma bin\u00e1ria"},{"location":"Teoria-Numeros-Binarios/#complemento-de-1","text":"Warning Forma 'errada' de armazenar n\u00fameros sinalizados (+, -) No complemento de 1, utilizamos a casa mais significativa de um vetor de bits para representar se o n\u00famero \u00e9 positivo ( 0 ) ou negativo ( 1 ). Exemplo (utilizando 4 bits): Valor +1 em bin\u00e1rio, com complemento de 1 0001 ^ | indica que o valor \u00e9 positivo Valor -1 em bin\u00e1rio, com complemento de 1 1001 ^ | indica que o valor \u00e9 negativo O problema do complemento de 1 \u00e9 que: Possu\u00edmos duas representa\u00e7\u00f5es para o valor 0: 0000 e 1000 Opera\u00e7\u00f5es de soma n\u00e3o funcionam corretamente entre os dois n\u00fameros codificados em complemento de 1.","title":"complemento de 1"},{"location":"Teoria-Numeros-Binarios/#complemento-de-2","text":"O complemento de dois \u00e9 uma outra maneira de representar n\u00fameros sinalizados com bits, para obter um n\u00famero positivo <-> negativo nessa nota\u00e7\u00e3o \u00e9 necess\u00e1rio seguir os seguintes passos: Inverter todos os bits (not bit a bit) da palavra original Somar um a palavra invertida","title":"Complemento de 2"},{"location":"Teoria-RTL/","text":"Resistor-Transistor Logic (RTL) \u00b6 Estudando Bibliografia [Cap7. FLOYD, 2005] [Cap8. TOCCI, 2011] Note Tempo estimado de estudo: 10 minutos. Leitura das p\u00e1ginas 1 - 13 (ler at\u00e9 buffer) do livro: RTL (Resistor-Transistor Logic) Cookbook by Don Lancaster. O livro est\u00e1 dispon\u00edvel em: https://archive.org/details/RTL_Resistor-Transistor_Logic_Cookbook/mode/2up Warning Ler at\u00e9 p\u00e1gina 13!!! Tip Mais informa\u00e7\u00f5es em: https://en.wikipedia.org/wiki/Resistor%E2%80%93transistor_logic","title":"Resistor-Transistor Logic (RTL)"},{"location":"Teoria-RTL/#resistor-transistor-logic-rtl","text":"Estudando Bibliografia [Cap7. FLOYD, 2005] [Cap8. TOCCI, 2011] Note Tempo estimado de estudo: 10 minutos. Leitura das p\u00e1ginas 1 - 13 (ler at\u00e9 buffer) do livro: RTL (Resistor-Transistor Logic) Cookbook by Don Lancaster. O livro est\u00e1 dispon\u00edvel em: https://archive.org/details/RTL_Resistor-Transistor_Logic_Cookbook/mode/2up Warning Ler at\u00e9 p\u00e1gina 13!!! Tip Mais informa\u00e7\u00f5es em: https://en.wikipedia.org/wiki/Resistor%E2%80%93transistor_logic","title":"Resistor-Transistor Logic (RTL)"},{"location":"Teoria-Sequencial-Componentes/","text":"Componentes S\u00edncronos \u00b6 Leitura necess\u00e1ria The Elements of Computing Systems (Livro texto do curso), cap 3 Binary digit - bits \u00b6 Criado com um FlipFlop tipo D, esse componente (que vamos chamar de bit ) \u00e9 capaz de armazenar um bit e ser\u00e1 usado na constru\u00e7\u00e3o das unidades de mem\u00f3ria utilizadas na CPU. DFF = FlipFlop do tipo D Esse componente funciona da seguinte maneira: load = '0' FF \u00e9 realimentando e mant\u00e9m o valor que foi armazenado. load = '1' , na subida do clock o componente 'captura' o valor da entrada in. Pseudo c\u00f3digo que descreve o funcionamento do bit \u00e9: if load = '1' then : q = d d = d Registrador \u00b6 O registrador \u00e9 um componente formado por v\u00e1rios bits e \u00e9 capaz de armazenar um vetore de bits: 8 bits; 16 bits; 32 bits; ... . Pseudo c\u00f3digo que descreve o funcionamento do register e if load = '1' then : q [ 7 : 0 ] = d [ 7 : 0 ] d [ 7 : 0 ] = d [ 7 : 0 ] Internamente o register \u00e9 formado por diversos bits , um para cada index do vetor de bits de entrada: Ele \u00e9 utilizado geralmente dentro da CPU, como uma mem\u00f3ria do tipo 'r\u00e1pida'. Note Podemos utilizar registradores de largura w para construir registradores de largura m* w : -------------------------------- | ------------- ------------- | | | reg_8 | | reg_8 | | | ------------- ------------- | -------------------------------- reg_16 uso Na nossa CPU do lab 10, o registrador \u00e9 o HW que armazena a sa\u00edda da ULA, nesse caso ele possui 16 bits de largura! Mem\u00f3ria RAM \u00b6 Uma mem\u00f3ria \u00e9 um array de registradores, ela funciona como uma tabela, onde conseguimos armazenar um vetor de bits em algum endere\u00e7o (linha), a RAM possui as seguintes portas: in clk: entrada de clock in d: entrada do dado a ser armazenado (vetor de bits) in address: endere\u00e7o onde o word ser\u00e1 armazenado in load load = '0' : n\u00e3o armazena word load = '1' : armazena nova word out q: sa\u00edda do valor armazenado no endere\u00e7o address O sinal load funciona como um controle se a opera\u00e7\u00e3o a ser realizada na mem\u00f3ria \u00e9 a de gravar ( load = 1 ) ou apenas ler o que j\u00e1 foi salvo ( load = 0 ). Pseudo c\u00f3digo que descreve o funcionamento da mem\u00f3ria RAM if load = '1' then : ram [ address ] = d else : q = ram [ address ]","title":"Componentes S\u00edncronos"},{"location":"Teoria-Sequencial-Componentes/#componentes-sincronos","text":"Leitura necess\u00e1ria The Elements of Computing Systems (Livro texto do curso), cap 3","title":"Componentes S\u00edncronos"},{"location":"Teoria-Sequencial-Componentes/#binary-digit-bits","text":"Criado com um FlipFlop tipo D, esse componente (que vamos chamar de bit ) \u00e9 capaz de armazenar um bit e ser\u00e1 usado na constru\u00e7\u00e3o das unidades de mem\u00f3ria utilizadas na CPU. DFF = FlipFlop do tipo D Esse componente funciona da seguinte maneira: load = '0' FF \u00e9 realimentando e mant\u00e9m o valor que foi armazenado. load = '1' , na subida do clock o componente 'captura' o valor da entrada in. Pseudo c\u00f3digo que descreve o funcionamento do bit \u00e9: if load = '1' then : q = d d = d","title":"Binary digit - bits"},{"location":"Teoria-Sequencial-Componentes/#registrador","text":"O registrador \u00e9 um componente formado por v\u00e1rios bits e \u00e9 capaz de armazenar um vetore de bits: 8 bits; 16 bits; 32 bits; ... . Pseudo c\u00f3digo que descreve o funcionamento do register e if load = '1' then : q [ 7 : 0 ] = d [ 7 : 0 ] d [ 7 : 0 ] = d [ 7 : 0 ] Internamente o register \u00e9 formado por diversos bits , um para cada index do vetor de bits de entrada: Ele \u00e9 utilizado geralmente dentro da CPU, como uma mem\u00f3ria do tipo 'r\u00e1pida'. Note Podemos utilizar registradores de largura w para construir registradores de largura m* w : -------------------------------- | ------------- ------------- | | | reg_8 | | reg_8 | | | ------------- ------------- | -------------------------------- reg_16 uso Na nossa CPU do lab 10, o registrador \u00e9 o HW que armazena a sa\u00edda da ULA, nesse caso ele possui 16 bits de largura!","title":"Registrador"},{"location":"Teoria-Sequencial-Componentes/#memoria-ram","text":"Uma mem\u00f3ria \u00e9 um array de registradores, ela funciona como uma tabela, onde conseguimos armazenar um vetor de bits em algum endere\u00e7o (linha), a RAM possui as seguintes portas: in clk: entrada de clock in d: entrada do dado a ser armazenado (vetor de bits) in address: endere\u00e7o onde o word ser\u00e1 armazenado in load load = '0' : n\u00e3o armazena word load = '1' : armazena nova word out q: sa\u00edda do valor armazenado no endere\u00e7o address O sinal load funciona como um controle se a opera\u00e7\u00e3o a ser realizada na mem\u00f3ria \u00e9 a de gravar ( load = 1 ) ou apenas ler o que j\u00e1 foi salvo ( load = 0 ). Pseudo c\u00f3digo que descreve o funcionamento da mem\u00f3ria RAM if load = '1' then : ram [ address ] = d else : q = ram [ address ]","title":"Mem\u00f3ria RAM"},{"location":"Teoria-ULA/","text":"ULA \u00b6 Unidade L\u00f3gica Aritm\u00e9tica (ULA) \u00e9 a parte da Unidade de Processamento (CPU) respons\u00e1vel por realizar opera\u00e7\u00f5es bin\u00e1rias. Nesse hardware Leitura necess\u00e1ria The Elements of Computing Systems (Livro texto do curso), cap 2.2.2 Warning Estudar pelo livro, o restante dessa teoria \u00e9 apenas um resumo e algumas notas. Tip No coursera temos os autores do livro dando uma aula sobre esse t\u00f3pico. https://www.coursera.org/lecture/build-a-computer/unit-2-4-arithmetic-logic-unit-6ZS46 Arquitetura \u00b6 A ULA utilizada no curso tem a seguinte arquitetura interna: Opera\u00e7\u00f5es \u00b6 zx nx zy ny f no out 1 0 1 0 1 0 0 1 1 1 1 1 1 1 1 1 1 0 1 0 -1 0 0 1 1 0 0 x 1 1 0 0 0 0 y 0 0 1 1 0 1 !x 1 1 0 0 0 1 !y 0 0 1 1 1 1 -x 1 1 0 0 1 1 -y 0 1 1 1 1 1 x+1 1 1 0 1 1 1 y+1 0 0 1 1 1 0 x-1 1 1 0 0 1 0 y-1 0 0 0 0 1 0 x+y 0 1 0 0 1 1 x-y 0 0 0 1 1 1 y-x 0 0 0 0 0 0 x&y 0 1 0 1 0 1 x or y Opera\u00e7\u00e3o n\u00e3o trivial \u00b6 A maioria das opera\u00e7\u00f5es da nossa ULA s\u00e3o imediatas, a menos imediata de entender \u00e9 a opera\u00e7\u00e3o y-x , nesse caso, se olharmos a opera\u00e7\u00e3o que \u00e9 realizada na ULA para executar isso notamos que: y-x=\\overline{x+\\bar{y}} y-x=\\overline{x+\\bar{y}} esse + \u00e9 de opera\u00e7\u00e3o de soma, n\u00e3o OR! Precisamos fazer um truque, note que: \\bar{y}=-y-1 \\bar{y}=-y-1 Substituindo: \\overline{x+ (-y -1)} \\overline{x+ (-y -1)} Podemos chamar: x+ (-y -1) = z x+ (-y -1) = z \\overline{z} \\overline{z} , aplicando a mesma substitui\u00e7\u00e3o que 2. \\overline{z}=-z-1 \\overline{z}=-z-1 , recuperando z -y-x=-(x -y -1)-1 -y-x=-(x -y -1)-1 y-x=-x+y y-x=-x+y","title":"ULA"},{"location":"Teoria-ULA/#ula","text":"Unidade L\u00f3gica Aritm\u00e9tica (ULA) \u00e9 a parte da Unidade de Processamento (CPU) respons\u00e1vel por realizar opera\u00e7\u00f5es bin\u00e1rias. Nesse hardware Leitura necess\u00e1ria The Elements of Computing Systems (Livro texto do curso), cap 2.2.2 Warning Estudar pelo livro, o restante dessa teoria \u00e9 apenas um resumo e algumas notas. Tip No coursera temos os autores do livro dando uma aula sobre esse t\u00f3pico. https://www.coursera.org/lecture/build-a-computer/unit-2-4-arithmetic-logic-unit-6ZS46","title":"ULA"},{"location":"Teoria-ULA/#arquitetura","text":"A ULA utilizada no curso tem a seguinte arquitetura interna:","title":"Arquitetura"},{"location":"Teoria-ULA/#operacoes","text":"zx nx zy ny f no out 1 0 1 0 1 0 0 1 1 1 1 1 1 1 1 1 1 0 1 0 -1 0 0 1 1 0 0 x 1 1 0 0 0 0 y 0 0 1 1 0 1 !x 1 1 0 0 0 1 !y 0 0 1 1 1 1 -x 1 1 0 0 1 1 -y 0 1 1 1 1 1 x+1 1 1 0 1 1 1 y+1 0 0 1 1 1 0 x-1 1 1 0 0 1 0 y-1 0 0 0 0 1 0 x+y 0 1 0 0 1 1 x-y 0 0 0 1 1 1 y-x 0 0 0 0 0 0 x&y 0 1 0 1 0 1 x or y","title":"Opera\u00e7\u00f5es"},{"location":"Teoria-ULA/#operacao-nao-trivial","text":"A maioria das opera\u00e7\u00f5es da nossa ULA s\u00e3o imediatas, a menos imediata de entender \u00e9 a opera\u00e7\u00e3o y-x , nesse caso, se olharmos a opera\u00e7\u00e3o que \u00e9 realizada na ULA para executar isso notamos que: y-x=\\overline{x+\\bar{y}} y-x=\\overline{x+\\bar{y}} esse + \u00e9 de opera\u00e7\u00e3o de soma, n\u00e3o OR! Precisamos fazer um truque, note que: \\bar{y}=-y-1 \\bar{y}=-y-1 Substituindo: \\overline{x+ (-y -1)} \\overline{x+ (-y -1)} Podemos chamar: x+ (-y -1) = z x+ (-y -1) = z \\overline{z} \\overline{z} , aplicando a mesma substitui\u00e7\u00e3o que 2. \\overline{z}=-z-1 \\overline{z}=-z-1 , recuperando z -y-x=-(x -y -1)-1 -y-x=-(x -y -1)-1 y-x=-x+y y-x=-x+y","title":"Opera\u00e7\u00e3o n\u00e3o trivial"},{"location":"Teoria-multimidia/","text":"V\u00eddeos \u00b6 \u00c1lgebra Booleana \u00b6 Exerc\u00edcios \u00b6 v\u00eddeos \u00b6 Quiz \u00b6 L\u00f3gica booleana - Tabela Verdade Responda sobre tabela verdade \u00c9 correto afirmar sobre a tabela verdade: (pode existir mais de um item correto) Considerando um circuito de 4 entradas (A,B, C, D) quantas s\u00e3o as linhas da tabela verdade? \ufeffQual tabela verdade a seguir foi montada correta? Considerando a equa\u00e7\u00e3o: X = not(B) + A , e a tabela verdade da imagem, qual resposta est\u00e1 correta (na sequ\u00eancia da tabela)? Resposta na sequ\u00eancia: X0; X1; X2; X3 \ufeffL\u00f3gica booleana 1 Quest\u00f5es b\u00e1sicas O que \u00e9 correto afirmar sobre bits? 1 AND 0 Se aplicarmos as entradas 1 e 0 a porta, a sa\u00edda ser\u00e1: 1 OR 0 Se aplicarmos as entradas 1 e 0 a porta, a sa\u00edda ser\u00e1:","title":"V\u00eddeos"},{"location":"Teoria-multimidia/#videos","text":"","title":"V\u00eddeos"},{"location":"Teoria-multimidia/#algebra-booleana","text":"","title":"\u00c1lgebra Booleana"},{"location":"Teoria-multimidia/#exercicios","text":"","title":"Exerc\u00edcios"},{"location":"Teoria-multimidia/#videos_1","text":"","title":"v\u00eddeos"},{"location":"Teoria-multimidia/#quiz","text":"","title":"Quiz"},{"location":"Util-Aulas/","text":"Resumo Aulas \u00b6 Aula 9 - 25/3 \u00b6 Bem Vindos de Volta! Recados: Adapta\u00e7\u00e3o na disciplina (devido ao corona) Novas datas de avalia\u00e7\u00e3o N\u00e3o vamos ter mais FPGA! Novo formato de avalia\u00e7\u00e3o individual D\u00favidas individuais ou em grupo? Preencher o forms! Precisam fazer: Migrar do Slack para Teams (comunica\u00e7\u00e3o e grupos) Outline da aula: Recados Simulado V2 (15 min teoria e 10 min pr\u00e1tica) Lab","title":"Resumo Aulas"},{"location":"Util-Aulas/#resumo-aulas","text":"","title":"Resumo Aulas"},{"location":"Util-Aulas/#aula-9-253","text":"Bem Vindos de Volta! Recados: Adapta\u00e7\u00e3o na disciplina (devido ao corona) Novas datas de avalia\u00e7\u00e3o N\u00e3o vamos ter mais FPGA! Novo formato de avalia\u00e7\u00e3o individual D\u00favidas individuais ou em grupo? Preencher o forms! Precisam fazer: Migrar do Slack para Teams (comunica\u00e7\u00e3o e grupos) Outline da aula: Recados Simulado V2 (15 min teoria e 10 min pr\u00e1tica) Lab","title":"Aula 9 - 25/3"},{"location":"Util-Comecando-novo-projeto/","text":"Come\u00e7ando novo projeto \u00b6 Linux Usar o Linux fornecido! Scrum Master O grupo deve escolher um mediador Dica: Aconselh\u00e1vel no primeiro projeto algu\u00e9m com facilidade de Linux e git. Voc\u00ea deve fazer a sec\u00e7\u00e3o do seu papel: Mediador/ Desenvolvedor Antes de come\u00e7ar - Mediador \u00b6 Scrum Master Somente Scrum, mas todos devem acompanhar (uma hora ser\u00e1 sua vez). Antes de come\u00e7ar ser\u00e1 necess\u00e1rio atualizar o reposit\u00f3rio de voc\u00eas com os novos arquivos no reposit\u00f3rio oficial da disciplina, e tamb\u00e9m configurar o Travis para executar os testes nesse novo projeto. upstream \u00b6 Referenciando reposit\u00f3rio original da disciplina $ git remote add upstream https://github.com/insper/Z01.1 Atualizando reposit\u00f3rio do grupo com altera\u00e7\u00f5es feitas no reposit\u00f3rio da disciplina: $ git fetch upstream $ git checkout master $ git merge upstream/master Feito isso, deve ter aparecido uma nova pasta dentro do reposit\u00f3rio de voc\u00eas: Projetos/C-LogicaCombinacional/ . travis \u00b6 Edite o arquivo .travis.yml localizado na raiz do reposit\u00f3rio modificando o final do arquivo para ficar como: script: ## run scripts - python3 Projetos/A-AmbienteDesenvolvimento/testeAmbienteDesenvolvimento.py - python3 Projetos/B-LogicaCombinacional/testeLogicaCombinacional.py + - python3 Projetos/C-UnidadeLogicaAritmetica/testeULA.py Agora vamos realizar um commit e submeter aos demais colegas do grupo as altera\u00e7\u00f5es: $ git add .travis.yml $ git commit -m \"configurando travis para novo projeto\" SCRUM_MASTER.json \u00b6 O Scrum Master deve editar o arquivo SCRUM_MASTER.json localizado na pasta do projeto (no caso exemplo para o projeto B: Projetos/B-LogicaCombinacional/SCRUM_MASTER.json ) com os seus dados. $ git commit -am \"configurado scrum do projeto\" Agora podemos enviar as atualiza\u00e7\u00f5es para os demais integrantes $ git push origin master Atualizar tools \u00b6 Voc\u00ea deve atualizar os scripts de teste, executando o comando a seguir: $ ./updateZ01tools.sh Antes de come\u00e7ar - Desenvolvedores \u00b6 Desenvolvedores Todos do grupo devem realizar isso. Warning Fazer isso somente depois que o mediador fez a parte dele! Agora todos os integrantes do grupo devem atualizar o reposit\u00f3rio: $ git pull origin master E atualizar os scripts de teste, executando o comando a seguir: $ ./updateZ01tools.sh Isso ir\u00e1 baixar as depend\u00eancias phython (via pip) e tamb\u00e9m clonar um reposit\u00f3rio chamado Z01-Tools na raiz do usu\u00e1rio: $HOME/Z01-Tools/ .","title":"Come\u00e7ando novo projeto"},{"location":"Util-Comecando-novo-projeto/#comecando-novo-projeto","text":"Linux Usar o Linux fornecido! Scrum Master O grupo deve escolher um mediador Dica: Aconselh\u00e1vel no primeiro projeto algu\u00e9m com facilidade de Linux e git. Voc\u00ea deve fazer a sec\u00e7\u00e3o do seu papel: Mediador/ Desenvolvedor","title":"Come\u00e7ando novo projeto"},{"location":"Util-Comecando-novo-projeto/#antes-de-comecar-mediador","text":"Scrum Master Somente Scrum, mas todos devem acompanhar (uma hora ser\u00e1 sua vez). Antes de come\u00e7ar ser\u00e1 necess\u00e1rio atualizar o reposit\u00f3rio de voc\u00eas com os novos arquivos no reposit\u00f3rio oficial da disciplina, e tamb\u00e9m configurar o Travis para executar os testes nesse novo projeto.","title":"Antes de come\u00e7ar - Mediador"},{"location":"Util-Comecando-novo-projeto/#upstream","text":"Referenciando reposit\u00f3rio original da disciplina $ git remote add upstream https://github.com/insper/Z01.1 Atualizando reposit\u00f3rio do grupo com altera\u00e7\u00f5es feitas no reposit\u00f3rio da disciplina: $ git fetch upstream $ git checkout master $ git merge upstream/master Feito isso, deve ter aparecido uma nova pasta dentro do reposit\u00f3rio de voc\u00eas: Projetos/C-LogicaCombinacional/ .","title":"upstream"},{"location":"Util-Comecando-novo-projeto/#travis","text":"Edite o arquivo .travis.yml localizado na raiz do reposit\u00f3rio modificando o final do arquivo para ficar como: script: ## run scripts - python3 Projetos/A-AmbienteDesenvolvimento/testeAmbienteDesenvolvimento.py - python3 Projetos/B-LogicaCombinacional/testeLogicaCombinacional.py + - python3 Projetos/C-UnidadeLogicaAritmetica/testeULA.py Agora vamos realizar um commit e submeter aos demais colegas do grupo as altera\u00e7\u00f5es: $ git add .travis.yml $ git commit -m \"configurando travis para novo projeto\"","title":"travis"},{"location":"Util-Comecando-novo-projeto/#scrum_masterjson","text":"O Scrum Master deve editar o arquivo SCRUM_MASTER.json localizado na pasta do projeto (no caso exemplo para o projeto B: Projetos/B-LogicaCombinacional/SCRUM_MASTER.json ) com os seus dados. $ git commit -am \"configurado scrum do projeto\" Agora podemos enviar as atualiza\u00e7\u00f5es para os demais integrantes $ git push origin master","title":"SCRUM_MASTER.json"},{"location":"Util-Comecando-novo-projeto/#atualizar-tools","text":"Voc\u00ea deve atualizar os scripts de teste, executando o comando a seguir: $ ./updateZ01tools.sh","title":"Atualizar tools"},{"location":"Util-Comecando-novo-projeto/#antes-de-comecar-desenvolvedores","text":"Desenvolvedores Todos do grupo devem realizar isso. Warning Fazer isso somente depois que o mediador fez a parte dele! Agora todos os integrantes do grupo devem atualizar o reposit\u00f3rio: $ git pull origin master E atualizar os scripts de teste, executando o comando a seguir: $ ./updateZ01tools.sh Isso ir\u00e1 baixar as depend\u00eancias phython (via pip) e tamb\u00e9m clonar um reposit\u00f3rio chamado Z01-Tools na raiz do usu\u00e1rio: $HOME/Z01-Tools/ .","title":"Antes de come\u00e7ar - Desenvolvedores"},{"location":"Util-Corona/","text":"On-line - Corona \u00b6 Elementos de Sistemas n\u00e3o sofrer\u00e1 grandes mudan\u00e7as, continuaremos com as din\u00e2micas atuais de aula: Teoria passada antes da aula por material no site da disciplina (V\u00eddeos + Texto + Livros + Links) As entregas de projetos semanais se mant\u00e9m (um facilitador por projeto) S\u00f3 n\u00e3o teremos mais a FPGA, algumas rubricas de projetos ter\u00e3o que ser adequadas. Conseguimos fazer tudo em um ambiente simulado, como se fosse o real! Avalia\u00e7\u00e3o: (se mant\u00e9m) 4 Provas Provas 100% remotas Devem acumular 60 pts de HW e 60 pts de SW Devem possuir no m\u00ednimo C em todos os projetos Nota individual / Grupo Novas rubricas individual! Note Vai come\u00e7ar valer s\u00f3 no pr\u00f3ximo projeto! Calend\u00e1rio \u00b6 Atendimento Segunda (se mant\u00e9m \u00e0s 12h) Quarta feira ser\u00e1 aula \"normal\" (no teams), irei trazer uma atividade para fazermos. AV1 adiada para Sexta - 27/3 Projeto C adiado para Ter\u00e7a - 31/3 AV2 adiada para fora da AI O calend\u00e1rio a seguir ser\u00e1 seguido: Ferramentas \u00b6 Linux! Microsoft teams (precisa instalar) Temos uma sala l\u00e1 chamada de 3s-Elementos. Cada grupo ter\u00e1 um canal Eu irei acabar com o Travis para n\u00e3o termos uma ferramenta concorrendo com outro. Plugin no vs code: live share","title":"On-line - Corona"},{"location":"Util-Corona/#on-line-corona","text":"Elementos de Sistemas n\u00e3o sofrer\u00e1 grandes mudan\u00e7as, continuaremos com as din\u00e2micas atuais de aula: Teoria passada antes da aula por material no site da disciplina (V\u00eddeos + Texto + Livros + Links) As entregas de projetos semanais se mant\u00e9m (um facilitador por projeto) S\u00f3 n\u00e3o teremos mais a FPGA, algumas rubricas de projetos ter\u00e3o que ser adequadas. Conseguimos fazer tudo em um ambiente simulado, como se fosse o real! Avalia\u00e7\u00e3o: (se mant\u00e9m) 4 Provas Provas 100% remotas Devem acumular 60 pts de HW e 60 pts de SW Devem possuir no m\u00ednimo C em todos os projetos Nota individual / Grupo Novas rubricas individual! Note Vai come\u00e7ar valer s\u00f3 no pr\u00f3ximo projeto!","title":"On-line - Corona"},{"location":"Util-Corona/#calendario","text":"Atendimento Segunda (se mant\u00e9m \u00e0s 12h) Quarta feira ser\u00e1 aula \"normal\" (no teams), irei trazer uma atividade para fazermos. AV1 adiada para Sexta - 27/3 Projeto C adiado para Ter\u00e7a - 31/3 AV2 adiada para fora da AI O calend\u00e1rio a seguir ser\u00e1 seguido:","title":"Calend\u00e1rio"},{"location":"Util-Corona/#ferramentas","text":"Linux! Microsoft teams (precisa instalar) Temos uma sala l\u00e1 chamada de 3s-Elementos. Cada grupo ter\u00e1 um canal Eu irei acabar com o Travis para n\u00e3o termos uma ferramenta concorrendo com outro. Plugin no vs code: live share","title":"Ferramentas"},{"location":"Util-Dicas-GIT/","text":"Dicas git \u00b6 Clonando reposit\u00f3rio \u00b6 $ git clone URL_DO_SEU_REP Instalando/Atualizando Z01-tools \u00b6 $ cd SEU_REP $ ./updateZ01tools.sh O script updateZ01tools.sh clona o reposit\u00f3rio http://github.com/Insper/z01-tools e o salva em sua pasta $HOME (/home/user/). O script serve para instalar e/ou atualizar a infra da disciplina, deve ser executado sempre que indicado pelo professor. Configurando upstream (Z01.1 professor) \u00b6 Referenciando reposit\u00f3rio original da disciplina: $ git remote add upstream https://github.com/insper/Z01.1 Atualizando reposit\u00f3rio do grupo \u00b6 Atualizando reposit\u00f3rio do grupo com altera\u00e7\u00f5es feitas no reposit\u00f3rio da disciplina: $ git fetch upstream $ git checkout master $ git merge upstream/master $ git push origin master","title":"Dicas git"},{"location":"Util-Dicas-GIT/#dicas-git","text":"","title":"Dicas git"},{"location":"Util-Dicas-GIT/#clonando-repositorio","text":"$ git clone URL_DO_SEU_REP","title":"Clonando reposit\u00f3rio"},{"location":"Util-Dicas-GIT/#instalandoatualizando-z01-tools","text":"$ cd SEU_REP $ ./updateZ01tools.sh O script updateZ01tools.sh clona o reposit\u00f3rio http://github.com/Insper/z01-tools e o salva em sua pasta $HOME (/home/user/). O script serve para instalar e/ou atualizar a infra da disciplina, deve ser executado sempre que indicado pelo professor.","title":"Instalando/Atualizando Z01-tools"},{"location":"Util-Dicas-GIT/#configurando-upstream-z011-professor","text":"Referenciando reposit\u00f3rio original da disciplina: $ git remote add upstream https://github.com/insper/Z01.1","title":"Configurando upstream (Z01.1 professor)"},{"location":"Util-Dicas-GIT/#atualizando-repositorio-do-grupo","text":"Atualizando reposit\u00f3rio do grupo com altera\u00e7\u00f5es feitas no reposit\u00f3rio da disciplina: $ git fetch upstream $ git checkout master $ git merge upstream/master $ git push origin master","title":"Atualizando reposit\u00f3rio do grupo"},{"location":"Util-Dicas-Travis/","text":"Dicas Travis \u00b6 Adicionando teste ao projeto \u00b6 Edite o arquivo .travis.yml localizado na raiz do reposit\u00f3rio, adicionando o script que deseja testar. Exemplos, para testarmos o projeto B \u00e9 necess\u00e1rio adicionar ao Travis a seguinte linha: python3 Projetos/B-LogicaCombinacional/testeLogicaCombinacional.py Isso deve ser feito na parte referente ao script script: ## Instal Z01.1 tools - bash updateZ01tools.sh ## run scripts - python3 Projetos/A-AmbienteDesenvolvimento/testeAmbienteDesenvolvimento.py - python3 Projetos/B-LogicaCombinacional/testeLogicaCombinacional.py Warning Voc\u00ea n\u00e3o deve remover os testes antigos","title":"Dicas Travis"},{"location":"Util-Dicas-Travis/#dicas-travis","text":"","title":"Dicas Travis"},{"location":"Util-Dicas-Travis/#adicionando-teste-ao-projeto","text":"Edite o arquivo .travis.yml localizado na raiz do reposit\u00f3rio, adicionando o script que deseja testar. Exemplos, para testarmos o projeto B \u00e9 necess\u00e1rio adicionar ao Travis a seguinte linha: python3 Projetos/B-LogicaCombinacional/testeLogicaCombinacional.py Isso deve ser feito na parte referente ao script script: ## Instal Z01.1 tools - bash updateZ01tools.sh ## run scripts - python3 Projetos/A-AmbienteDesenvolvimento/testeAmbienteDesenvolvimento.py - python3 Projetos/B-LogicaCombinacional/testeLogicaCombinacional.py Warning Voc\u00ea n\u00e3o deve remover os testes antigos","title":"Adicionando teste ao projeto"},{"location":"Util-Infraestrutura/","text":"Os softwares que ser\u00e3o utilizados ao longo do semestre s\u00e3o: Intel Quartus : Software da Intel/ Altera utilizado para programar FPGAs (compilador, IDE, ...). ModelSim : Software da MentorGraphics utilizado para simular HDL (VHDL/Verilog) Python 3 : Para automatizar os testes Java JDK 8 : Java Development Kit Editor de texto : Editor de texto para programa\u00e7\u00e3o em VHDL/Java IDE de programa\u00e7\u00e3o JAVA : Eclipse / IntelliJ IDEA Voc\u00ea ir\u00e1 receber um SSD com Linux e a infra de elementos j\u00e1 instalada.","title":"Infraestrutura"},{"location":"Util-InstructionSet/","text":"Download em PDF","title":"Instruction Set"},{"location":"Util-Resumo-Assembly/","text":"Tipo A LEA - Carregamento Efetivo do Endere\u00e7o Tipo C MOV - Copia Valores ADD - Adi\u00e7\u00e3o de Inteiros SUB - Subtra\u00e7\u00e3o de Inteiros RSUB - Subtra\u00e7\u00e3o de Inteiros Reversa INC - Incrementa Inteiro DEC - Decrementa Inteiro NOT - Nega\u00e7\u00e3o por Complemento de Um NEG - Nega\u00e7\u00e3o por Complemento de dois AND - Operador E (and) OR - Operador OU (or) JMP - Jump JE - Desvia Execu\u00e7\u00e3o se Igual a Zero JNE - Desvia Execu\u00e7\u00e3o se Diferente de Zero JG - Desvia Execu\u00e7\u00e3o se Maior que Zero JGE - Desvia Execu\u00e7\u00e3o se Maior Igual a Zero JL - Desvia Execu\u00e7\u00e3o se Menor que Zero JLE - Desvia Execu\u00e7\u00e3o se Menor Igual a Zero NOP - N\u00e3o faz nada (No Operation) Nota\u00e7\u00e3o \u00b6 reg : Registrador ( %A , %D , %S ) mem : Acesso a mem\u00f3ria (%A) im : Imediato, pode ser: ( $1 , $0 , $-1 ) const : Constante positiva ( $0 , $9 , ....) Instru\u00e7\u00f5es \u00b6 LEA - Carregamento Efetivo do Endere\u00e7o (Valor) \u00b6 leaw const, reg Restri\u00e7\u00e3o A opera\u00e7\u00e3o de leaw s\u00f3 aceita o registrador %A A instru\u00e7\u00e3o lea armazena o valor passado ( const ) no registrador especificado ; Exemplo: %A = 15 leaw $ 15 , % A MOV - Copia Valores \u00b6 movw im*/reg/mem, reg/mem {, reg/mem, reg/mem} Dica A opera\u00e7\u00e3o de mov faz na verde uma c\u00f3pia, deixando a origem com o dado original. A instru\u00e7\u00e3o mov, copia o valor da primeira posi\u00e7\u00e3o para a segunda posi\u00e7\u00e3o (terceira e quarta opcional). ; Exemplo: S = RAM[A] movw ( % A ), % S ADD - Adi\u00e7\u00e3o de Inteiros \u00b6 addw reg/mem, reg/mem/im*, reg/mem {, reg/mem, reg/mem} Dica A opera\u00e7\u00e3o permite salvar o resultado em mais de um destino. instru\u00e7\u00e3o add, soma o primeiro valor ao segundo valor e armazena o resultado no terceiro par\u00e2metro (quarto e quinto opcional). ; Exemplo: S = RAM[A]+D addw ( % A ), % D , % S SUB - Subtra\u00e7\u00e3o de Inteiros \u00b6 subw reg/mem, rem/mem/im*, reg/mem {, reg/mem, reg/mem} A instru\u00e7\u00e3o sub, subtrai o segundo valor do primeiro valor e armazena o resultado no terceiro par\u00e2metro (quarto e quinto opcional). ; Exemplo: A = D - RAM[A] subw % D , ( % A ), % A RSUB - Subtra\u00e7\u00e3o de Inteiros Reversa \u00b6 rsubw reg/mem/im*, rem/mem, reg/mem {, reg/mem, reg/mem} A instru\u00e7\u00e3o rsub, subtrai o segundo valor do primeiro valor e armazena o resultado no terceiro par\u00e2metro (quarto e quinto opcional). ; Exemplo: A = RAM[A] - D rsubw % D , ( % A ), % A INC - Incrementa Inteiro \u00b6 incw reg/mem Restri\u00e7\u00e3o O destino \u00e9 o pr\u00f3prio registrador! A opera\u00e7\u00e3o n\u00e3o permite salvar em um registrador diferente. Dica Se quiser fazer a opera\u00e7\u00e3o de inc e salvar em outro registrador, pode utilizar a opera\u00e7\u00e3o de addw : ; D = A + 1 addw $ 1 , % A , % D A instru\u00e7\u00e3o inc, adiciona um (1) ao valor do registrador ou mem\u00f3ria. ; Exemplo: D = D + 1 incw % D DEC - Decrementa Inteiro \u00b6 decw reg/mem A instru\u00e7\u00e3o dec, subtrai um (1) do valor do registrador ou mem\u00f3ria. ; Exemplo: A = A-1 decw % A NOT - Nega\u00e7\u00e3o por Complemento de Um \u00b6 notw reg A instru\u00e7\u00e3o not, inverte o valor de cada bit do reg origem, ou seja, se um bit tem valor 0 fica com 1 e vice-versa. ; Exemplo: D = !D notw % D NEG - Nega\u00e7\u00e3o por Complemento de dois \u00b6 negw reg/mem A instru\u00e7\u00e3o neg, faz o valor ficar negativo, ou seja, um valor de x \u00e9 modificado para -x. ; Exemplo: A = -A negw % A AND - Operador E (and) \u00b6 andw reg/mem, rem/mem A instru\u00e7\u00e3o and executa o operador l\u00f3gico E (and). ; Exemplo: D = A&D andw % A , % D , % D OR - Operador OU (or) \u00b6 orw reg/mem, rem/mem A instru\u00e7\u00e3o or executa o operador l\u00f3gico Ou (or). ; Exemplo: D = RAM[A] | D orw ( % A ), % D , % D JMP - Jump \u00b6 jmp A instru\u00e7\u00e3o jmp executa um desvio, no fluxo de execu\u00e7\u00e3o, para o endere\u00e7o armazenado em %A. jmp JE - Desvia Execu\u00e7\u00e3o se Igual a Zero \u00b6 je reg A instru\u00e7\u00e3o je faz um desvio, no fluxo de execu\u00e7\u00e3o, para o endere\u00e7o armazenado em %A, somente se o valor do reg. for igual a zero. je % S JNE - Desvia Execu\u00e7\u00e3o se Diferente de Zero \u00b6 jne reg A instru\u00e7\u00e3o jne faz um desvio, no fluxo de execu\u00e7\u00e3o, para o endere\u00e7o armazenado em %A, somente se o valor do reg. for diferente de zero. jne % D JG - Desvia Execu\u00e7\u00e3o se Maior que Zero \u00b6 jg reg A instru\u00e7\u00e3o jg desvia, o fluxo de execu\u00e7\u00e3o, para o endere\u00e7o armazenado em %A, somente se o valor do reg. for maior que zero. jg % s JGE - Desvia Execu\u00e7\u00e3o se Maior Igual a Zero \u00b6 jge reg A instru\u00e7\u00e3o jge faz um desvio, no fluxo de execu\u00e7\u00e3o, para o endere\u00e7o armazenado em %A, somente se o valor do reg. for maior ou igual a zero. jge % S JL - Desvia Execu\u00e7\u00e3o se Menor que Zero \u00b6 jl reg A instru\u00e7\u00e3o jl faz desvio, no fluxo de execu\u00e7\u00e3o, para o endere\u00e7o armazenado em %A, somente se o valor do reg. for menor que zero. jl % S JLE - Desvia Execu\u00e7\u00e3o se Menor Igual a Zero \u00b6 jle reg A instru\u00e7\u00e3o jle faz um desvio, no fluxo de execu\u00e7\u00e3o, para o endere\u00e7o armazenado em %A, somente se o valor do reg. for menor ou igual a zero. jle % D NOP - N\u00e3o faz nada (No Operation) \u00b6 nop A instru\u00e7\u00e3o nop n\u00e3o faz nada, usado para pular um ciclo de execu\u00e7\u00e3o. nop Descri\u00e7\u00e3o Detalhada \u00b6 Formato das Instru\u00e7\u00f5es Em Assembly, codificamos uma instru\u00e7\u00e3o por linha e ela \u00e9 constru\u00edda a partir do mnem\u00f4nico da opera\u00e7\u00e3o e seus argumentos. Al\u00e9m disso, temos marcadores de posi\u00e7\u00e3o (endere\u00e7o usado em desvios), constantes e poss\u00edveis vari\u00e1veis. O formato das instru\u00e7\u00f5es na sintaxe AT&T segue o seguinte formato: mnem\u00f4nico origem, destino Registradores Todos os registradores devem ter como prefixo o sinal de porcentagem '%\\', por exemplo: %A ou %D ou %S. Valores Literais Todos os valores literais devem ter como prefixo o sinal de cifr\u00e3o '$\\', por exemplo: $55, $376, sendo o maior valor 2047 (15 bits). Endere\u00e7amento de Mem\u00f3ria Na sintaxe AT&T, a mem\u00f3ria \u00e9 referenciada com par\u00eantese em volta do registrador que armazena o endere\u00e7o: por exemplo (%A). Tamanho dos operadores Algumas instru\u00e7\u00f5es podem trabalhar com diferentes tamanhos de dados, assim as instru\u00e7\u00f5es podem ter um sufixo, informando o tamanho do dado que ir\u00e1 manipular, sendo b (8 bits), w (16 bits) e l (32 bits). Por exemplo: movw $2000, (%A) Instru\u00e7\u00f5es de Transfer\u00eancia de Controle As instru\u00e7\u00f5es de jump, fazem o fluxo do programa desviar de uma posi\u00e7\u00e3o do programa para outra. Para marcar as posi\u00e7\u00f5es no programa, s\u00e3o usados marcadores (labels) que sempre terminam com dois pontos (:). Por exemplo: loop: Registradores virtuais Os s\u00edmbolos R0, ..., R15 s\u00e3o automaticamente predefinidos para se referir aos endere\u00e7os de RAM 0, ..., 15 Ponteiros de I/O Os s\u00edmbolos SCREEN e KBD s\u00e3o automaticamente predefinidos para se referir aos endere\u00e7os de RAM 16384 e 24576, respectivamente. Ponteiros de controle da VM Os s\u00edmbolos SP, LCL, ARG, THIS, e THAT s\u00e3o automaticamente predefinidos para se referir aos endere\u00e7os de RAM 0-4, respectivamente. Nota\u00e7\u00f5es: im : valor imediato (somente os valores 1, 0 e -1). reg : registrador. mem: mem\u00f3ria, ou seja (%A). Limita\u00e7\u00f5es: A arquitetura n\u00e3o permite somar o valor da mem\u00f3ria apontada por (%A) com o valor de %A, ou de (%A) com (%A), tampouco %A com %A. N\u00e3o \u00e9 poss\u00edvel somar (ou subtrair, se \u00e9 que isso faz sentido) o registrador com o mesmo, por exemplo somar %D com %D. N\u00e3o \u00e9 poss\u00edvel ler e gravar a mem\u00f3ria ao mesmo tempo. Por exemplo, as instru\u00e7\u00f5es abaixo n\u00e3o funcionam no nosso computador: incw (%A); subw (%A),%D,(%A). Observa\u00e7\u00e3o: A linguagem Assembly apresentada \u00e9 especifica para o processador produzido no curso. Embora muito similar a outras usadas em produtos de mercado, as instru\u00e7\u00f5es possuem limita\u00e7\u00f5es inerentes a cada hardware.","title":"Resumo Assembly"},{"location":"Util-Resumo-Assembly/#notacao","text":"reg : Registrador ( %A , %D , %S ) mem : Acesso a mem\u00f3ria (%A) im : Imediato, pode ser: ( $1 , $0 , $-1 ) const : Constante positiva ( $0 , $9 , ....)","title":"Nota\u00e7\u00e3o"},{"location":"Util-Resumo-Assembly/#instrucoes","text":"","title":"Instru\u00e7\u00f5es"},{"location":"Util-Resumo-Assembly/#lea-carregamento-efetivo-do-endereco-valor","text":"leaw const, reg Restri\u00e7\u00e3o A opera\u00e7\u00e3o de leaw s\u00f3 aceita o registrador %A A instru\u00e7\u00e3o lea armazena o valor passado ( const ) no registrador especificado ; Exemplo: %A = 15 leaw $ 15 , % A","title":"LEA - Carregamento Efetivo do Endere\u00e7o (Valor)"},{"location":"Util-Resumo-Assembly/#mov-copia-valores","text":"movw im*/reg/mem, reg/mem {, reg/mem, reg/mem} Dica A opera\u00e7\u00e3o de mov faz na verde uma c\u00f3pia, deixando a origem com o dado original. A instru\u00e7\u00e3o mov, copia o valor da primeira posi\u00e7\u00e3o para a segunda posi\u00e7\u00e3o (terceira e quarta opcional). ; Exemplo: S = RAM[A] movw ( % A ), % S","title":"MOV - Copia Valores"},{"location":"Util-Resumo-Assembly/#add-adicao-de-inteiros","text":"addw reg/mem, reg/mem/im*, reg/mem {, reg/mem, reg/mem} Dica A opera\u00e7\u00e3o permite salvar o resultado em mais de um destino. instru\u00e7\u00e3o add, soma o primeiro valor ao segundo valor e armazena o resultado no terceiro par\u00e2metro (quarto e quinto opcional). ; Exemplo: S = RAM[A]+D addw ( % A ), % D , % S","title":"ADD - Adi\u00e7\u00e3o de Inteiros"},{"location":"Util-Resumo-Assembly/#sub-subtracao-de-inteiros","text":"subw reg/mem, rem/mem/im*, reg/mem {, reg/mem, reg/mem} A instru\u00e7\u00e3o sub, subtrai o segundo valor do primeiro valor e armazena o resultado no terceiro par\u00e2metro (quarto e quinto opcional). ; Exemplo: A = D - RAM[A] subw % D , ( % A ), % A","title":"SUB - Subtra\u00e7\u00e3o de Inteiros"},{"location":"Util-Resumo-Assembly/#rsub-subtracao-de-inteiros-reversa","text":"rsubw reg/mem/im*, rem/mem, reg/mem {, reg/mem, reg/mem} A instru\u00e7\u00e3o rsub, subtrai o segundo valor do primeiro valor e armazena o resultado no terceiro par\u00e2metro (quarto e quinto opcional). ; Exemplo: A = RAM[A] - D rsubw % D , ( % A ), % A","title":"RSUB - Subtra\u00e7\u00e3o de Inteiros Reversa"},{"location":"Util-Resumo-Assembly/#inc-incrementa-inteiro","text":"incw reg/mem Restri\u00e7\u00e3o O destino \u00e9 o pr\u00f3prio registrador! A opera\u00e7\u00e3o n\u00e3o permite salvar em um registrador diferente. Dica Se quiser fazer a opera\u00e7\u00e3o de inc e salvar em outro registrador, pode utilizar a opera\u00e7\u00e3o de addw : ; D = A + 1 addw $ 1 , % A , % D A instru\u00e7\u00e3o inc, adiciona um (1) ao valor do registrador ou mem\u00f3ria. ; Exemplo: D = D + 1 incw % D","title":"INC - Incrementa Inteiro"},{"location":"Util-Resumo-Assembly/#dec-decrementa-inteiro","text":"decw reg/mem A instru\u00e7\u00e3o dec, subtrai um (1) do valor do registrador ou mem\u00f3ria. ; Exemplo: A = A-1 decw % A","title":"DEC - Decrementa Inteiro"},{"location":"Util-Resumo-Assembly/#not-negacao-por-complemento-de-um","text":"notw reg A instru\u00e7\u00e3o not, inverte o valor de cada bit do reg origem, ou seja, se um bit tem valor 0 fica com 1 e vice-versa. ; Exemplo: D = !D notw % D","title":"NOT - Nega\u00e7\u00e3o por Complemento de Um"},{"location":"Util-Resumo-Assembly/#neg-negacao-por-complemento-de-dois","text":"negw reg/mem A instru\u00e7\u00e3o neg, faz o valor ficar negativo, ou seja, um valor de x \u00e9 modificado para -x. ; Exemplo: A = -A negw % A","title":"NEG - Nega\u00e7\u00e3o por Complemento de dois"},{"location":"Util-Resumo-Assembly/#and-operador-e-and","text":"andw reg/mem, rem/mem A instru\u00e7\u00e3o and executa o operador l\u00f3gico E (and). ; Exemplo: D = A&D andw % A , % D , % D","title":"AND - Operador E (and)"},{"location":"Util-Resumo-Assembly/#or-operador-ou-or","text":"orw reg/mem, rem/mem A instru\u00e7\u00e3o or executa o operador l\u00f3gico Ou (or). ; Exemplo: D = RAM[A] | D orw ( % A ), % D , % D","title":"OR - Operador OU (or)"},{"location":"Util-Resumo-Assembly/#jmp-jump","text":"jmp A instru\u00e7\u00e3o jmp executa um desvio, no fluxo de execu\u00e7\u00e3o, para o endere\u00e7o armazenado em %A. jmp","title":"JMP - Jump"},{"location":"Util-Resumo-Assembly/#je-desvia-execucao-se-igual-a-zero","text":"je reg A instru\u00e7\u00e3o je faz um desvio, no fluxo de execu\u00e7\u00e3o, para o endere\u00e7o armazenado em %A, somente se o valor do reg. for igual a zero. je % S","title":"JE - Desvia Execu\u00e7\u00e3o se Igual a Zero"},{"location":"Util-Resumo-Assembly/#jne-desvia-execucao-se-diferente-de-zero","text":"jne reg A instru\u00e7\u00e3o jne faz um desvio, no fluxo de execu\u00e7\u00e3o, para o endere\u00e7o armazenado em %A, somente se o valor do reg. for diferente de zero. jne % D","title":"JNE - Desvia Execu\u00e7\u00e3o se Diferente de Zero"},{"location":"Util-Resumo-Assembly/#jg-desvia-execucao-se-maior-que-zero","text":"jg reg A instru\u00e7\u00e3o jg desvia, o fluxo de execu\u00e7\u00e3o, para o endere\u00e7o armazenado em %A, somente se o valor do reg. for maior que zero. jg % s","title":"JG - Desvia Execu\u00e7\u00e3o se Maior que Zero"},{"location":"Util-Resumo-Assembly/#jge-desvia-execucao-se-maior-igual-a-zero","text":"jge reg A instru\u00e7\u00e3o jge faz um desvio, no fluxo de execu\u00e7\u00e3o, para o endere\u00e7o armazenado em %A, somente se o valor do reg. for maior ou igual a zero. jge % S","title":"JGE - Desvia Execu\u00e7\u00e3o se Maior Igual a Zero"},{"location":"Util-Resumo-Assembly/#jl-desvia-execucao-se-menor-que-zero","text":"jl reg A instru\u00e7\u00e3o jl faz desvio, no fluxo de execu\u00e7\u00e3o, para o endere\u00e7o armazenado em %A, somente se o valor do reg. for menor que zero. jl % S","title":"JL - Desvia Execu\u00e7\u00e3o se Menor que Zero"},{"location":"Util-Resumo-Assembly/#jle-desvia-execucao-se-menor-igual-a-zero","text":"jle reg A instru\u00e7\u00e3o jle faz um desvio, no fluxo de execu\u00e7\u00e3o, para o endere\u00e7o armazenado em %A, somente se o valor do reg. for menor ou igual a zero. jle % D","title":"JLE - Desvia Execu\u00e7\u00e3o se Menor Igual a Zero"},{"location":"Util-Resumo-Assembly/#nop-nao-faz-nada-no-operation","text":"nop A instru\u00e7\u00e3o nop n\u00e3o faz nada, usado para pular um ciclo de execu\u00e7\u00e3o. nop","title":"NOP - N\u00e3o faz nada (No Operation)"},{"location":"Util-Resumo-Assembly/#descricao-detalhada","text":"Formato das Instru\u00e7\u00f5es Em Assembly, codificamos uma instru\u00e7\u00e3o por linha e ela \u00e9 constru\u00edda a partir do mnem\u00f4nico da opera\u00e7\u00e3o e seus argumentos. Al\u00e9m disso, temos marcadores de posi\u00e7\u00e3o (endere\u00e7o usado em desvios), constantes e poss\u00edveis vari\u00e1veis. O formato das instru\u00e7\u00f5es na sintaxe AT&T segue o seguinte formato: mnem\u00f4nico origem, destino Registradores Todos os registradores devem ter como prefixo o sinal de porcentagem '%\\', por exemplo: %A ou %D ou %S. Valores Literais Todos os valores literais devem ter como prefixo o sinal de cifr\u00e3o '$\\', por exemplo: $55, $376, sendo o maior valor 2047 (15 bits). Endere\u00e7amento de Mem\u00f3ria Na sintaxe AT&T, a mem\u00f3ria \u00e9 referenciada com par\u00eantese em volta do registrador que armazena o endere\u00e7o: por exemplo (%A). Tamanho dos operadores Algumas instru\u00e7\u00f5es podem trabalhar com diferentes tamanhos de dados, assim as instru\u00e7\u00f5es podem ter um sufixo, informando o tamanho do dado que ir\u00e1 manipular, sendo b (8 bits), w (16 bits) e l (32 bits). Por exemplo: movw $2000, (%A) Instru\u00e7\u00f5es de Transfer\u00eancia de Controle As instru\u00e7\u00f5es de jump, fazem o fluxo do programa desviar de uma posi\u00e7\u00e3o do programa para outra. Para marcar as posi\u00e7\u00f5es no programa, s\u00e3o usados marcadores (labels) que sempre terminam com dois pontos (:). Por exemplo: loop: Registradores virtuais Os s\u00edmbolos R0, ..., R15 s\u00e3o automaticamente predefinidos para se referir aos endere\u00e7os de RAM 0, ..., 15 Ponteiros de I/O Os s\u00edmbolos SCREEN e KBD s\u00e3o automaticamente predefinidos para se referir aos endere\u00e7os de RAM 16384 e 24576, respectivamente. Ponteiros de controle da VM Os s\u00edmbolos SP, LCL, ARG, THIS, e THAT s\u00e3o automaticamente predefinidos para se referir aos endere\u00e7os de RAM 0-4, respectivamente. Nota\u00e7\u00f5es: im : valor imediato (somente os valores 1, 0 e -1). reg : registrador. mem: mem\u00f3ria, ou seja (%A). Limita\u00e7\u00f5es: A arquitetura n\u00e3o permite somar o valor da mem\u00f3ria apontada por (%A) com o valor de %A, ou de (%A) com (%A), tampouco %A com %A. N\u00e3o \u00e9 poss\u00edvel somar (ou subtrair, se \u00e9 que isso faz sentido) o registrador com o mesmo, por exemplo somar %D com %D. N\u00e3o \u00e9 poss\u00edvel ler e gravar a mem\u00f3ria ao mesmo tempo. Por exemplo, as instru\u00e7\u00f5es abaixo n\u00e3o funcionam no nosso computador: incw (%A); subw (%A),%D,(%A). Observa\u00e7\u00e3o: A linguagem Assembly apresentada \u00e9 especifica para o processador produzido no curso. Embora muito similar a outras usadas em produtos de mercado, as instru\u00e7\u00f5es possuem limita\u00e7\u00f5es inerentes a cada hardware.","title":"Descri\u00e7\u00e3o Detalhada"},{"location":"Util-Resumo-Labs/","text":"Resumo \u00b6 Atual Projeto ID Laborat\u00f3rio Descri\u00e7\u00e3o X - Mundo Real J - VM Translator 17 J VM Translator Lab 1 Tradu\u00e7\u00e3o de vm para nasm I - VM 16 I VM Lab 1 Programas em linguagem VM H - Assembler 15 H Assembler Lab 1 Implementando m\u00e9todos em java G - CPU 14 G CPU Lab 1 F - Assembly 13 F Assembly Lab 3 12 F Assembly Lab 2 11 F Assembly Lab 1 E - Sequencial 10 E Sequencial Lab 1 D - ULA 9 D ULA Lab 1 8 D ULA Lab 2 C - L\u00f3gica Combinacional 7 C L\u00f3gica Combinacional Lab 2 6 C L\u00f3gica Combinacional Lab 1 5 C Combinacional Lab 1 B - CI 4 B CI Lab 2 3 B Lab 1 A - Transistores 2 A Transistores Lab 2 1 A Transistores Lab 1","title":"Resumo"},{"location":"Util-Resumo-Labs/#resumo","text":"Atual Projeto ID Laborat\u00f3rio Descri\u00e7\u00e3o X - Mundo Real J - VM Translator 17 J VM Translator Lab 1 Tradu\u00e7\u00e3o de vm para nasm I - VM 16 I VM Lab 1 Programas em linguagem VM H - Assembler 15 H Assembler Lab 1 Implementando m\u00e9todos em java G - CPU 14 G CPU Lab 1 F - Assembly 13 F Assembly Lab 3 12 F Assembly Lab 2 11 F Assembly Lab 1 E - Sequencial 10 E Sequencial Lab 1 D - ULA 9 D ULA Lab 1 8 D ULA Lab 2 C - L\u00f3gica Combinacional 7 C L\u00f3gica Combinacional Lab 2 6 C L\u00f3gica Combinacional Lab 1 5 C Combinacional Lab 1 B - CI 4 B CI Lab 2 3 B Lab 1 A - Transistores 2 A Transistores Lab 2 1 A Transistores Lab 1","title":"Resumo"},{"location":"Util-Resumo-Projetos/","text":"Resumo \u00b6 Atual Projeto ID Laborat\u00f3rio Descri\u00e7\u00e3o X - Mundo Real J - VM Translator 17 J VM Translator Lab 1 Tradu\u00e7\u00e3o de vm para nasm I - VM 16 I VM Lab 1 Programas em linguagem VM H - Assembler 15 H Assembler Lab 1 Implementando m\u00e9todos em java G - CPU 14 G CPU Lab 1 F - Assembly 13 F Assembly Lab 3 12 F Assembly Lab 2 11 F Assembly Lab 1 E - Sequencial 10 E Sequencial Lab 1 D - ULA 9 D ULA Lab 1 8 D ULA Lab 2 C - L\u00f3gica Combinacional 7 C L\u00f3gica Combinacional Lab 2 6 C L\u00f3gica Combinacional Lab 1 5 C Combinacional Lab 1 B - CI 4 B CI Lab 2 3 B Lab 1 A - Transistores 2 A Transistores Lab 2 1 A Transistores Lab 1","title":"Resumo"},{"location":"Util-Resumo-Projetos/#resumo","text":"Atual Projeto ID Laborat\u00f3rio Descri\u00e7\u00e3o X - Mundo Real J - VM Translator 17 J VM Translator Lab 1 Tradu\u00e7\u00e3o de vm para nasm I - VM 16 I VM Lab 1 Programas em linguagem VM H - Assembler 15 H Assembler Lab 1 Implementando m\u00e9todos em java G - CPU 14 G CPU Lab 1 F - Assembly 13 F Assembly Lab 3 12 F Assembly Lab 2 11 F Assembly Lab 1 E - Sequencial 10 E Sequencial Lab 1 D - ULA 9 D ULA Lab 1 8 D ULA Lab 2 C - L\u00f3gica Combinacional 7 C L\u00f3gica Combinacional Lab 2 6 C L\u00f3gica Combinacional Lab 1 5 C Combinacional Lab 1 B - CI 4 B CI Lab 2 3 B Lab 1 A - Transistores 2 A Transistores Lab 2 1 A Transistores Lab 1","title":"Resumo"},{"location":"Util-Resumo-VM/","text":"Linguagem VM \u00b6 Nota\u00e7\u00e3o \u00b6 Pilha : Local onde a opera\u00e7\u00e3o \u00e9 executada Primeiro endere\u00e7o : Dado no topo da pilha Segundo endere\u00e7o : Segundo dado no topo da pilha Stack Pointer : Ponteiro para o endere\u00e7o do dado no topo da pilha ... ... X <- Segundo Valor Y <- Primeiro Valor SP -> Opera\u00e7\u00e3o Argumentos retorno Descri\u00e7\u00e3o add : Adi\u00e7\u00e3o X, Y X X = X + Y sub : Subtra\u00e7\u00e3o X, Y X X = X - Y neg : Nega\u00e7\u00e3o Y Y Y = - Y not : Not bit a bit Y Y Y = ! Y and : And bit a bit X, Y X X = X and Y or : Or bit a bit X, Y X X = X or Y eq : Equal X, Y X X = True if X = Y else False gt : Greater Than X, Y X X = True if X > Y else False lt : Less Than X, Y X X = True if X < Y else False Opera\u00e7\u00f5es \u00b6 add - Adi\u00e7\u00e3o \u00b6 add X = X + Y A opera\u00e7\u00e3o add adiciona dois valores da pilha, e retorna o resultado no local do segundo valor. Pilha ---------------------------------------- | Antes | Depois | -------------------|-------------------- .... | .... X | X+Y Y | SP -> SP -> | sub - Subtra\u00e7\u00e3o \u00b6 sub X = X-Y A opera\u00e7\u00e3o sub subtrai dois valores da pilha, e retorna o resultado no local do segundo valor. neg - Nega\u00e7\u00e3o \u00b6 neg Y = -Y A opera\u00e7\u00e3o neg nega (complemento de dois) o valor no topo da pilha, e retorna o resultado no mesmo local. Pilha ---------------------------------------- | Antes | Depois | -------------------|-------------------- .... | .... X | X Y | -Y SP -> | SP -> not - not bit a bit \u00b6 and Y = !Y A opera\u00e7\u00e3o not inverte (bit a bit) o valor no topo da pilha, e retorna o resultado no mesmo local. or - Or bit a bit \u00b6 or Y = X or Y A opera\u00e7\u00e3o or aplica um or (bit a bit) com os valores no topo da pilha, e retorna o resultado no segundo endere\u00e7o. and - and bit a bit \u00b6 and Y = X and Y A opera\u00e7\u00e3o and aplica um or (bit a bit) com os valores no topo da pilha, e retorna o resultado no segundo endere\u00e7o. eq - Equal \u00b6 eq X = True se X==Y ou False A opera\u00e7\u00e3o eq verifica se os dois valores no topo da pilha s\u00e3o iguais, re retorna o resultado (True ou False) no segundo valor da pilha. True/false 'True' \u00e9 representando por todos os bits em '1': '0xFFFF' 'False' \u00e9 representando por todos os bits em '0': 0x0000' Pilha Essa opera\u00e7\u00e3o consume os dois valores da pilha, veja exemplo. Pilha ---------------------------------------- | Antes | Depois | -------------------|-------------------- .... | .... X | True/False Y | SP -> SP -> | gt - Greater Than \u00b6 gt X = True se X>Y ou False A opera\u00e7\u00e3o qt verifica se o valor no topo da pilha \u00e9 maior que o anterior, retorna o resultado (True ou False) no segundo valor da pilha. lt - Less Than \u00b6 lt X = True se X<Y ou False A opera\u00e7\u00e3o qt verifica se o valor no topo da pilha \u00e9 menor que o anterior, retorna o resultado (True ou False) no segundo valor da pilha. Label \u00b6 Labels s\u00e3o definidos pelo keyword label seguido de seu nome : label nome S\u00e3o utilizados para endere\u00e7ar o c\u00f3digo em uma condi\u00e7\u00e3o de goto. Goto \u00b6 Existem dois tipos de GOTO, condicional ( if-goto ) e incondicional ( goto ). No condicional o salto \u00e9 realizado caso a condi\u00e7\u00e3o n\u00e3o for Falsa (verifica sempre o \u00faltimo valor da pilha). goto nome if-goto nome Fun\u00e7\u00e3o \u00b6 A seguir defini\u00e7\u00f5es de fun\u00e7\u00f5es: Declara\u00e7\u00e3o de fun\u00e7\u00e3o \u00b6 Uma fun\u00e7\u00e3o \u00e9 definida pelo keyword function seguido do seu nome e quantidade de vari\u00e1veis locais n na estrutura a seguir : function nome n Toda fun\u00e7\u00e3o em VM deve possuir um retorno, definido pelo keyword return Exemplo declara\u00e7\u00e3o de fun\u00e7\u00e3o funcion add 2 push argument 0 push argument 1 add Chamada de fun\u00e7\u00e3o \u00b6 Uma fun\u00e7\u00e3o em VM \u00e9 chamada pelo keyword: call seguido do nome da fun\u00e7\u00e3o e da quantidade m de par\u00e2metros passados para essa fun\u00e7\u00e3o. call nome m Exemplo chamada de fun\u00e7\u00e3o push constant 3 push constant 2 call m ult 2 Par\u00e2metros \u00b6 Os par\u00e2metros de uma fun\u00e7\u00e3o s\u00e3o passados na pr\u00f3pria pilha.","title":"Resumo VM"},{"location":"Util-Resumo-VM/#linguagem-vm","text":"","title":"Linguagem VM"},{"location":"Util-Resumo-VM/#notacao","text":"Pilha : Local onde a opera\u00e7\u00e3o \u00e9 executada Primeiro endere\u00e7o : Dado no topo da pilha Segundo endere\u00e7o : Segundo dado no topo da pilha Stack Pointer : Ponteiro para o endere\u00e7o do dado no topo da pilha ... ... X <- Segundo Valor Y <- Primeiro Valor SP -> Opera\u00e7\u00e3o Argumentos retorno Descri\u00e7\u00e3o add : Adi\u00e7\u00e3o X, Y X X = X + Y sub : Subtra\u00e7\u00e3o X, Y X X = X - Y neg : Nega\u00e7\u00e3o Y Y Y = - Y not : Not bit a bit Y Y Y = ! Y and : And bit a bit X, Y X X = X and Y or : Or bit a bit X, Y X X = X or Y eq : Equal X, Y X X = True if X = Y else False gt : Greater Than X, Y X X = True if X > Y else False lt : Less Than X, Y X X = True if X < Y else False","title":"Nota\u00e7\u00e3o"},{"location":"Util-Resumo-VM/#operacoes","text":"","title":"Opera\u00e7\u00f5es"},{"location":"Util-Resumo-VM/#add-adicao","text":"add X = X + Y A opera\u00e7\u00e3o add adiciona dois valores da pilha, e retorna o resultado no local do segundo valor. Pilha ---------------------------------------- | Antes | Depois | -------------------|-------------------- .... | .... X | X+Y Y | SP -> SP -> |","title":"add - Adi\u00e7\u00e3o"},{"location":"Util-Resumo-VM/#sub-subtracao","text":"sub X = X-Y A opera\u00e7\u00e3o sub subtrai dois valores da pilha, e retorna o resultado no local do segundo valor.","title":"sub - Subtra\u00e7\u00e3o"},{"location":"Util-Resumo-VM/#neg-negacao","text":"neg Y = -Y A opera\u00e7\u00e3o neg nega (complemento de dois) o valor no topo da pilha, e retorna o resultado no mesmo local. Pilha ---------------------------------------- | Antes | Depois | -------------------|-------------------- .... | .... X | X Y | -Y SP -> | SP ->","title":"neg - Nega\u00e7\u00e3o"},{"location":"Util-Resumo-VM/#not-not-bit-a-bit","text":"and Y = !Y A opera\u00e7\u00e3o not inverte (bit a bit) o valor no topo da pilha, e retorna o resultado no mesmo local.","title":"not - not bit a bit"},{"location":"Util-Resumo-VM/#or-or-bit-a-bit","text":"or Y = X or Y A opera\u00e7\u00e3o or aplica um or (bit a bit) com os valores no topo da pilha, e retorna o resultado no segundo endere\u00e7o.","title":"or - Or bit a bit"},{"location":"Util-Resumo-VM/#and-and-bit-a-bit","text":"and Y = X and Y A opera\u00e7\u00e3o and aplica um or (bit a bit) com os valores no topo da pilha, e retorna o resultado no segundo endere\u00e7o.","title":"and - and bit a bit"},{"location":"Util-Resumo-VM/#eq-equal","text":"eq X = True se X==Y ou False A opera\u00e7\u00e3o eq verifica se os dois valores no topo da pilha s\u00e3o iguais, re retorna o resultado (True ou False) no segundo valor da pilha. True/false 'True' \u00e9 representando por todos os bits em '1': '0xFFFF' 'False' \u00e9 representando por todos os bits em '0': 0x0000' Pilha Essa opera\u00e7\u00e3o consume os dois valores da pilha, veja exemplo. Pilha ---------------------------------------- | Antes | Depois | -------------------|-------------------- .... | .... X | True/False Y | SP -> SP -> |","title":"eq - Equal"},{"location":"Util-Resumo-VM/#gt-greater-than","text":"gt X = True se X>Y ou False A opera\u00e7\u00e3o qt verifica se o valor no topo da pilha \u00e9 maior que o anterior, retorna o resultado (True ou False) no segundo valor da pilha.","title":"gt - Greater Than"},{"location":"Util-Resumo-VM/#lt-less-than","text":"lt X = True se X<Y ou False A opera\u00e7\u00e3o qt verifica se o valor no topo da pilha \u00e9 menor que o anterior, retorna o resultado (True ou False) no segundo valor da pilha.","title":"lt - Less Than"},{"location":"Util-Resumo-VM/#label","text":"Labels s\u00e3o definidos pelo keyword label seguido de seu nome : label nome S\u00e3o utilizados para endere\u00e7ar o c\u00f3digo em uma condi\u00e7\u00e3o de goto.","title":"Label"},{"location":"Util-Resumo-VM/#goto","text":"Existem dois tipos de GOTO, condicional ( if-goto ) e incondicional ( goto ). No condicional o salto \u00e9 realizado caso a condi\u00e7\u00e3o n\u00e3o for Falsa (verifica sempre o \u00faltimo valor da pilha). goto nome if-goto nome","title":"Goto"},{"location":"Util-Resumo-VM/#funcao","text":"A seguir defini\u00e7\u00f5es de fun\u00e7\u00f5es:","title":"Fun\u00e7\u00e3o"},{"location":"Util-Resumo-VM/#declaracao-de-funcao","text":"Uma fun\u00e7\u00e3o \u00e9 definida pelo keyword function seguido do seu nome e quantidade de vari\u00e1veis locais n na estrutura a seguir : function nome n Toda fun\u00e7\u00e3o em VM deve possuir um retorno, definido pelo keyword return Exemplo declara\u00e7\u00e3o de fun\u00e7\u00e3o funcion add 2 push argument 0 push argument 1 add","title":"Declara\u00e7\u00e3o de fun\u00e7\u00e3o"},{"location":"Util-Resumo-VM/#chamada-de-funcao","text":"Uma fun\u00e7\u00e3o em VM \u00e9 chamada pelo keyword: call seguido do nome da fun\u00e7\u00e3o e da quantidade m de par\u00e2metros passados para essa fun\u00e7\u00e3o. call nome m Exemplo chamada de fun\u00e7\u00e3o push constant 3 push constant 2 call m ult 2","title":"Chamada de fun\u00e7\u00e3o"},{"location":"Util-Resumo-VM/#parametros","text":"Os par\u00e2metros de uma fun\u00e7\u00e3o s\u00e3o passados na pr\u00f3pria pilha.","title":"Par\u00e2metros"},{"location":"Util-Status-Travis-Grupos/","text":"GRUPO A B C D E F G H I","title":"Util Status Travis Grupos"},{"location":"Util-VM-Linux/","text":"Boot SSD via VirtualBox \u00b6 Atrav\u00e9s deste guia, voc\u00ea conseguir\u00e1 criar uma m\u00e1quina virtual no VirtualBox que realiza o boot de um HD Externo, este roteiro foi feito e testado no Windows 10 (mas com o devido cuidado funciona no Mac OS e Linux tamb\u00e9m). Antes, verifique se n\u00e3o h\u00e1 nenhum pendrive, se sim, ejete ele no Windows Explorer. Conecte o HD Externo de tipo A (MBR) no Windows, neste momento dever\u00e1 aparecer uma mensagem dizendo para formatar a unidade para poder utiliza-la, clique em N\u00e3o. Agora, abra o Painel de Controle, procure por Ferramentas Administrativas e em seguida Gerenciamento do Computador (Cuidado para n\u00e3o confundir com Gerenciador de Dispositivos!). Agora no menu lateral, procure por Gerenciamento de Discos, na parte central, voc\u00ea deve ser capaz de ver o seu HD e o HD Externo conectado, caso contr\u00e1rio, verifique a conex\u00e3o USB e certifique-se que clicou no bot\u00e3o Ignorar ao conecta-lo. Com foco no HD Externo e procure pelo n\u00famero do Disco (geralmente fica na parte inferior em baixo do nome, no gr\u00e1fico de barras). Deve haver algo como Disco 2 ou Disco 1 . Agora, abra uma Linha de Comando como Administrador (bot\u00e3o direito, e executar como Administrador). Navegue at\u00e9 a pasta do VirtualBox em C:\\Program Files\\Oracle\\VirtualBox e execute o seguinte comando, substituindo o N pelo n\u00famero de disco corresponde visto anteriormente (deve-se manter o \\.\\PhysicalDrive). VBoxManage internalcommands createrawvmdk -filename Elementos.vmdk -rawdisk \\\\.\\PhysicalDriveN Se tudo ocorrer bem, deve aparecer a mensagem RAW host disk access VMDK file Elementos.vmdk created successfully. Caso sim, continue, caso contr\u00e1rio, verifique o comando digitado. No passo 6, criamos um disco virtual, que na realidade n\u00e3o armazena dados e sim diz ao VirtualBox procurar pelo HD Externo. No entanto, este acesso ao HD Externo em n\u00edvel de parti\u00e7\u00f5es de boot, necessita de acesso de administrador ao computador. Portanto, vamos ter que abrir o VirtualBox como administrador no Windows. Primeiro, certifique-se que o VirtualBox est\u00e1 fechado completamente. Procure qualquer atalho ou no menu Iniciar pelo VirtualBox e clique com bot\u00e3o direito e Executar como Administrador. Com \u00eaxito, a janela do VirtualBox deve aparecer. Clique para criar uma nova m\u00e1quina virtual, clique em seguida no modo Expert, de um nome apropriado a m\u00e1quina virtual, na pasta da m\u00e1quina virtual, sugiro que mude o caminho para C:\\Users\\SEU_USUARIO\\VirtualBox VMs (crie caso n\u00e3o exista). Ele ir\u00e1 utilizar esta pasta apenas para arquivos de configura\u00e7\u00e3o. Troque o Tipo para Linux e Vers\u00e3o para Ubuntu (64-bits). \u00c9 recomend\u00e1vel que aloque pelo menos 4GB (4096 MB) para o sistema. Na op\u00e7\u00e3o de Disco R\u00edgido, escolha a op\u00e7\u00e3o Utilizar um disco virtual existente, e selecione o arquivo Elementos.vmdk criado no passo 6. Clique em Criar. Clique para executar a m\u00e1quina virtual criada, se tudo ocorrer bem, voc\u00ea deve ver o boot do Ubuntu iniciando, n\u00e3o esque\u00e7a depois de ligar, de verificar a resolu\u00e7\u00e3o da tela e se a acelera\u00e7\u00e3o de v\u00eddeo est\u00e1 habilitada.","title":"Boot SSD via VirtualBox"},{"location":"Util-VM-Linux/#boot-ssd-via-virtualbox","text":"Atrav\u00e9s deste guia, voc\u00ea conseguir\u00e1 criar uma m\u00e1quina virtual no VirtualBox que realiza o boot de um HD Externo, este roteiro foi feito e testado no Windows 10 (mas com o devido cuidado funciona no Mac OS e Linux tamb\u00e9m). Antes, verifique se n\u00e3o h\u00e1 nenhum pendrive, se sim, ejete ele no Windows Explorer. Conecte o HD Externo de tipo A (MBR) no Windows, neste momento dever\u00e1 aparecer uma mensagem dizendo para formatar a unidade para poder utiliza-la, clique em N\u00e3o. Agora, abra o Painel de Controle, procure por Ferramentas Administrativas e em seguida Gerenciamento do Computador (Cuidado para n\u00e3o confundir com Gerenciador de Dispositivos!). Agora no menu lateral, procure por Gerenciamento de Discos, na parte central, voc\u00ea deve ser capaz de ver o seu HD e o HD Externo conectado, caso contr\u00e1rio, verifique a conex\u00e3o USB e certifique-se que clicou no bot\u00e3o Ignorar ao conecta-lo. Com foco no HD Externo e procure pelo n\u00famero do Disco (geralmente fica na parte inferior em baixo do nome, no gr\u00e1fico de barras). Deve haver algo como Disco 2 ou Disco 1 . Agora, abra uma Linha de Comando como Administrador (bot\u00e3o direito, e executar como Administrador). Navegue at\u00e9 a pasta do VirtualBox em C:\\Program Files\\Oracle\\VirtualBox e execute o seguinte comando, substituindo o N pelo n\u00famero de disco corresponde visto anteriormente (deve-se manter o \\.\\PhysicalDrive). VBoxManage internalcommands createrawvmdk -filename Elementos.vmdk -rawdisk \\\\.\\PhysicalDriveN Se tudo ocorrer bem, deve aparecer a mensagem RAW host disk access VMDK file Elementos.vmdk created successfully. Caso sim, continue, caso contr\u00e1rio, verifique o comando digitado. No passo 6, criamos um disco virtual, que na realidade n\u00e3o armazena dados e sim diz ao VirtualBox procurar pelo HD Externo. No entanto, este acesso ao HD Externo em n\u00edvel de parti\u00e7\u00f5es de boot, necessita de acesso de administrador ao computador. Portanto, vamos ter que abrir o VirtualBox como administrador no Windows. Primeiro, certifique-se que o VirtualBox est\u00e1 fechado completamente. Procure qualquer atalho ou no menu Iniciar pelo VirtualBox e clique com bot\u00e3o direito e Executar como Administrador. Com \u00eaxito, a janela do VirtualBox deve aparecer. Clique para criar uma nova m\u00e1quina virtual, clique em seguida no modo Expert, de um nome apropriado a m\u00e1quina virtual, na pasta da m\u00e1quina virtual, sugiro que mude o caminho para C:\\Users\\SEU_USUARIO\\VirtualBox VMs (crie caso n\u00e3o exista). Ele ir\u00e1 utilizar esta pasta apenas para arquivos de configura\u00e7\u00e3o. Troque o Tipo para Linux e Vers\u00e3o para Ubuntu (64-bits). \u00c9 recomend\u00e1vel que aloque pelo menos 4GB (4096 MB) para o sistema. Na op\u00e7\u00e3o de Disco R\u00edgido, escolha a op\u00e7\u00e3o Utilizar um disco virtual existente, e selecione o arquivo Elementos.vmdk criado no passo 6. Clique em Criar. Clique para executar a m\u00e1quina virtual criada, se tudo ocorrer bem, voc\u00ea deve ver o boot do Ubuntu iniciando, n\u00e3o esque\u00e7a depois de ligar, de verificar a resolu\u00e7\u00e3o da tela e se a acelera\u00e7\u00e3o de v\u00eddeo est\u00e1 habilitada.","title":"Boot SSD via VirtualBox"},{"location":"Util-VM-MAC/","text":"Atrav\u00e9s deste guia, voc\u00ea conseguir\u00e1 criar uma m\u00e1quina virtual no VirtualBox que realiza o boot de um HD Externo, este roteiro foi feito e testado no Mac OS Mojave (mas com o devido cuidado funciona no Windows e Linux tamb\u00e9m). Antes, verifique se n\u00e3o h\u00e1 nenhum pendrive ou instalador montado (mostrando como unidade), se sim, ejete eles no Finder. Conecte o HD Externo de tipo A (MBR) no Mac OS, neste momento dever\u00e1 aparecer uma mensagem dizendo que o Mac OS n\u00e3o \u00e9 capaz de ler o disco, aten\u00e7\u00e3o, voc\u00ea deve clicar no bot\u00e3o 'Ignorar' Agora, abra o Disk Utility (Utilit\u00e1rio de Disco), ele pode ser encontrado pelo Spotlight ou pelo Launchpad, conforme imagem. Clique no bot\u00e3o Visualizar e selecione Mostrar todos os dispositivos . Agora no menu lateral, voc\u00ea deve ser capaz de ver o HD Externo conectado, caso contr\u00e1rio, verifique a conex\u00e3o USB e certifique-se que clicou no bot\u00e3o Ignorar ao conecta-lo. Selecione o HD Externo no Disk Utility e nas informa\u00e7\u00f5es exibidas procure por Dispositivo: diskN , sendo que haver\u00e1 um n\u00famero no lugar do N, no caso da foto \u00e9 disk2 . Verifique qual o n\u00famero em seu Mac OS. Agora, abra um Terminal. E execute o seguinte comando, substituindo o diskN pelo disco corresponde visto anteriormente (deve-se manter o /dev/ inicial). Ele ir\u00e1 solicitar a sua senha do Mac OS, por favor digite. sudo VBoxManage internalcommands createrawvmdk -filename Elementos.vmdk -rawdisk /dev/diskN Se tudo ocorrer bem, deve aparecer a mensagem RAW host disk access VMDK file Elementos.vmdk created successfully. Caso sim, continue, caso contr\u00e1rio, verifique o comando digitado. No passo 6, criamos um disco virtual, que na realidade n\u00e3o armazena dados e sim diz ao VirtualBox procurar pelo HD Externo. No entanto, este acesso ao HD Externo em n\u00edvel de parti\u00e7\u00f5es de boot, necessita de acesso de administrador ao computador. Portanto, vamos ter que abrir o VirtualBox como administrador no Mac OS. Primeiro, certifique-se que o VirtualBox est\u00e1 fechado completamente. Em seguida, no terminal novamente, digite o comando sudo /Applications/VirtualBox.app/Contents/MacOS/VirtualBox Com \u00eaxito, a janela do VirtualBox deve aparecer. Clique para criar uma nova m\u00e1quina virtual, clique em seguida no modo Expert , de um nome apropriado a m\u00e1quina virtual, na pasta da m\u00e1quina virtual, sugiro que mude o caminho para /Users/SEU_USUARIO/VirtualBox VMs (crie caso n\u00e3o exista). Ele ir\u00e1 utilizar esta pasta apenas para arquivos de configura\u00e7\u00e3o. Troque o Tipo para Linux e Vers\u00e3o para Ubuntu (64-bits). \u00c9 recomend\u00e1vel que aloque pelo menos 4GB (4096 MB) para o sistema. Na op\u00e7\u00e3o de Disco R\u00edgido, escolha a op\u00e7\u00e3o Utilizar um disco virtual existente, e selecione o arquivo Elementos.vmdk criado no passo 6. Clique em Criar. Clique para executar a m\u00e1quina virtual criada, se tudo ocorrer bem, voc\u00ea deve ver o boot do Ubuntu iniciando, n\u00e3o esque\u00e7a depois de ligar, de verificar a resolu\u00e7\u00e3o da tela e se a acelera\u00e7\u00e3o de v\u00eddeo est\u00e1 habilitada.","title":"Util VM MAC"},{"location":"Util-VM-Windows/","text":"Atrav\u00e9s deste guia, voc\u00ea conseguir\u00e1 criar uma m\u00e1quina virtual no VirtualBox que realiza o boot de um HD Externo, este roteiro foi feito e testado no Windows 10 (mas com o devido cuidado funciona no Mac OS e Linux tamb\u00e9m). Antes, verifique se n\u00e3o h\u00e1 nenhum pendrive, se sim, ejete ele no Windows Explorer. Conecte o HD Externo de tipo A (MBR) no Windows, neste momento dever\u00e1 aparecer uma mensagem dizendo para formatar a unidade para poder utiliza-la, clique em N\u00e3o. Agora, abra o Painel de Controle, procure por Ferramentas Administrativas e em seguida Gerenciamento do Computador (Cuidado para n\u00e3o confundir com Gerenciador de Dispositivos!). Agora no menu lateral, procure por Gerenciamento de Discos, na parte central, voc\u00ea deve ser capaz de ver o seu HD e o HD Externo conectado, caso contr\u00e1rio, verifique a conex\u00e3o USB e certifique-se que clicou no bot\u00e3o Ignorar ao conecta-lo. Com foco no HD Externo e procure pelo n\u00famero do Disco (geralmente fica na parte inferior em baixo do nome, no gr\u00e1fico de barras). Deve haver algo como Disco 2 ou Disco 1 . Agora, abra uma Linha de Comando como Administrador (bot\u00e3o direito, e executar como Administrador). Navegue at\u00e9 a pasta do VirtualBox em C:\\Program Files\\Oracle\\VirtualBox e execute o seguinte comando, substituindo o N pelo n\u00famero de disco corresponde visto anteriormente (deve-se manter o \\.\\PhysicalDrive). VBoxManage internalcommands createrawvmdk -filename Elementos.vmdk -rawdisk \\\\.\\PhysicalDriveN Se tudo ocorrer bem, deve aparecer a mensagem RAW host disk access VMDK file Elementos.vmdk created successfully. Caso sim, continue, caso contr\u00e1rio, verifique o comando digitado. No passo 6, criamos um disco virtual, que na realidade n\u00e3o armazena dados e sim diz ao VirtualBox procurar pelo HD Externo. No entanto, este acesso ao HD Externo em n\u00edvel de parti\u00e7\u00f5es de boot, necessita de acesso de administrador ao computador. Portanto, vamos ter que abrir o VirtualBox como administrador no Windows. Primeiro, certifique-se que o VirtualBox est\u00e1 fechado completamente. Procure qualquer atalho ou no menu Iniciar pelo VirtualBox e clique com bot\u00e3o direito e Executar como Administrador. Com \u00eaxito, a janela do VirtualBox deve aparecer. Clique para criar uma nova m\u00e1quina virtual, clique em seguida no modo Expert, de um nome apropriado a m\u00e1quina virtual, na pasta da m\u00e1quina virtual, sugiro que mude o caminho para C:\\Users\\SEU_USUARIO\\VirtualBox VMs (crie caso n\u00e3o exista). Ele ir\u00e1 utilizar esta pasta apenas para arquivos de configura\u00e7\u00e3o. Troque o Tipo para Linux e Vers\u00e3o para Ubuntu (64-bits). \u00c9 recomend\u00e1vel que aloque pelo menos 4GB (4096 MB) para o sistema. Na op\u00e7\u00e3o de Disco R\u00edgido, escolha a op\u00e7\u00e3o Utilizar um disco virtual existente, e selecione o arquivo Elementos.vmdk criado no passo 6. Clique em Criar. Clique para executar a m\u00e1quina virtual criada, se tudo ocorrer bem, voc\u00ea deve ver o boot do Ubuntu iniciando, n\u00e3o esque\u00e7a depois de ligar, de verificar a resolu\u00e7\u00e3o da tela e se a acelera\u00e7\u00e3o de v\u00eddeo est\u00e1 habilitada.","title":"Util VM Windows"},{"location":"Util-Video-Aulas/","text":"Material desenvolvido pelo Prof. Luciano Soares no ano de 2017, pode ser utilizado para estudar! Conte\u00fado de \u00c1lgebra Booleana https://www.youtube.com/watch?v=YYIucfsQKl4 Conte\u00fado Transistores https://www.youtube.com/watch?v=rRg9wdzlPvE Conte\u00fado sobre Circuitos Integrados https://www.youtube.com/watch?v=zX36rn_lIl0 Conte\u00fado sobre L\u00f3gica Combinacional https://www.youtube.com/watch?v=ImFt9YjEHHc Conte\u00fado Dados Digitais https://www.youtube.com/watch?v=dVixMB1uSYA Conte\u00fado de Unidade L\u00f3gica Aritm\u00e9tica https://www.youtube.com/watch?v=zRX3sOtjS10 Conte\u00fado de L\u00f3gica Sequencial https://www.youtube.com/watch?v=lNW2d26S-gI Conte\u00fado de Mem\u00f3rias https://www.youtube.com/watch?v=CAw-cQUZO_g Conte\u00fado de L\u00f3gica de Controle https://www.youtube.com/watch?v=eEXI72tztws Conte\u00fado Linguagem de M\u00e1quina https://www.youtube.com/watch?v=_MhpD0Geqlk Conte\u00fado Assembly https://www.youtube.com/watch?v=xABQNUe3hG0 Conte\u00fado Computador https://www.youtube.com/watch?v=uVgqGkz106Q Conte\u00fado Assembler https://www.youtube.com/watch?v=xFBPHkaFIlk Conte\u00fado M\u00e1quina Virtual https://www.youtube.com/watch?v=U9DRGBVp8Eg Conte\u00fado Pilhas https://www.youtube.com/watch?v=5N0rTGZHdwY Conte\u00fado de Controle https://www.youtube.com/watch?v=Hp4ZwLMvYfg Conte\u00fado Linguagem de Alto N\u00edvel https://www.youtube.com/watch?v=YZucTUVv-n8 Conte\u00fado Linguagem Orientada a Objetos https://www.youtube.com/watch?v=-9Fj-ShFV_8 Conte\u00fado An\u00e1lise L\u00e9xica e Sint\u00e1tica https://www.youtube.com/watch?v=rtHxrs6TC6Y Programa\u00e7\u00e3o de FPGA pelo Quartus https://www.youtube.com/watch?v=QuH2pduAs34 Exemplo MuxVHDLQuartus https://www.youtube.com/watch?v=m3B8Yob3xkE Gravando e atualizando dados numa mem\u00f3ria de uma FPGA pelo Quartus https://www.youtube.com/watch?v=zb4taQX4yL8","title":"V\u00eddeo Aulas (Luciano)"},{"location":"Util-Z01.1-Cheat-Sheet/","text":"DOWNLOAD SOURCE instruction set","title":"Z01.1 Cheat Sheet"},{"location":"Util-online/","text":"On-line - Corona \u00b6 Elementos de Sistemas n\u00e3o sofrer\u00e1 grandes mudan\u00e7as, continuaremos com as din\u00e2micas atuais de aula: Teoria passada antes da aula por material no site da disciplina (V\u00eddeos + Texto + Livros + Links) As entregas de projetos semanais se mant\u00e9m (um facilitador por projeto) S\u00f3 n\u00e3o teremos mais a FPGA, algumas rubricas de projetos ter\u00e3o que ser adequadas. Avalia\u00e7\u00e3o: (se mant\u00e9m) 4 Provas Provas 100% remotas Devem acumular 60 pts de HW e 60 pts de SW Devem possuir no m\u00ednimo C em todos os projetos Nota individual / Grupo vamos mudar como a nota de participa\u00e7\u00e3o individual \u00e9 atribu\u00edda, na quarta eu informo voc\u00eas. Note Vai come\u00e7ar valer s\u00f3 no pr\u00f3ximo projeto! Calend\u00e1rio \u00b6 Atendimento Segunda (se mant\u00e9m \u00e0s 12h) Quarta feira ser\u00e1 aula \"normal\" (no teams), irei trazer uma atividade para fazermos. AV1 adiada para Sexta - 27/3 Projeto C adiado para Ter\u00e7a - 31/3 Ferramentas \u00b6 Microsoft teams (precisa instalar) Temos uma sala l\u00e1, chamada de 3s-Elementos Cada grupo ter\u00e1 uma sala Eu irei acabar com o Travis para n\u00e3o termos uma ferramenta concorrendo com outro. Plugin no vs code: live share","title":"On-line - Corona :tangerine:"},{"location":"Util-online/#on-line-corona","text":"Elementos de Sistemas n\u00e3o sofrer\u00e1 grandes mudan\u00e7as, continuaremos com as din\u00e2micas atuais de aula: Teoria passada antes da aula por material no site da disciplina (V\u00eddeos + Texto + Livros + Links) As entregas de projetos semanais se mant\u00e9m (um facilitador por projeto) S\u00f3 n\u00e3o teremos mais a FPGA, algumas rubricas de projetos ter\u00e3o que ser adequadas. Avalia\u00e7\u00e3o: (se mant\u00e9m) 4 Provas Provas 100% remotas Devem acumular 60 pts de HW e 60 pts de SW Devem possuir no m\u00ednimo C em todos os projetos Nota individual / Grupo vamos mudar como a nota de participa\u00e7\u00e3o individual \u00e9 atribu\u00edda, na quarta eu informo voc\u00eas. Note Vai come\u00e7ar valer s\u00f3 no pr\u00f3ximo projeto!","title":"On-line - Corona"},{"location":"Util-online/#calendario","text":"Atendimento Segunda (se mant\u00e9m \u00e0s 12h) Quarta feira ser\u00e1 aula \"normal\" (no teams), irei trazer uma atividade para fazermos. AV1 adiada para Sexta - 27/3 Projeto C adiado para Ter\u00e7a - 31/3","title":"Calend\u00e1rio"},{"location":"Util-online/#ferramentas","text":"Microsoft teams (precisa instalar) Temos uma sala l\u00e1, chamada de 3s-Elementos Cada grupo ter\u00e1 uma sala Eu irei acabar com o Travis para n\u00e3o termos uma ferramenta concorrendo com outro. Plugin no vs code: live share","title":"Ferramentas"},{"location":"Util-vixi-sou-scrum/","text":"Vixi! Sou scrum master \u00b6 Passos Voc\u00ea \u00e9 o mediador (Scrum Master) do projeto e n\u00e3o sabe por onde come\u00e7ar? A seguir os passos que devem ser realizados! Sincronizar reposit\u00f3rio com upstream Editar SCRUM_MASTER.json com suas informa\u00e7\u00f5es Ler documenta\u00e7\u00e3o do projeto Configurar Travis para executar teste do projeto Criar Project e issues no github (detalhes ao final dessa p\u00e1gina) Discuta com os seus colegas Acompanhe o grupo ajudando o pessoal trabalhar, seu papel \u00e9 entregar!! no prazo!!! Na entrega do projeto, todos os issues devem ter sido resolvidos (e arquivados). Todos as tarefas devem ser movidas para done no projects. Com o projeto finalizado: Criar uma tag no git para marcar o commit que tudo funciona, exemplo: git tag Projeto-C + git push --tag Preencher formul\u00e1rio de relato (ir\u00e1 receber por e-mail) Criar project no github \u00b6 Criando um project no github Adicionando issues Tip Os issues devem ser todos os m\u00f3dulos a serem implementados do projeto. Voc\u00ea deve manter o quadro atualizado.","title":"Vixi! Sou scrum master"},{"location":"Util-vixi-sou-scrum/#vixi-sou-scrum-master","text":"Passos Voc\u00ea \u00e9 o mediador (Scrum Master) do projeto e n\u00e3o sabe por onde come\u00e7ar? A seguir os passos que devem ser realizados! Sincronizar reposit\u00f3rio com upstream Editar SCRUM_MASTER.json com suas informa\u00e7\u00f5es Ler documenta\u00e7\u00e3o do projeto Configurar Travis para executar teste do projeto Criar Project e issues no github (detalhes ao final dessa p\u00e1gina) Discuta com os seus colegas Acompanhe o grupo ajudando o pessoal trabalhar, seu papel \u00e9 entregar!! no prazo!!! Na entrega do projeto, todos os issues devem ter sido resolvidos (e arquivados). Todos as tarefas devem ser movidas para done no projects. Com o projeto finalizado: Criar uma tag no git para marcar o commit que tudo funciona, exemplo: git tag Projeto-C + git push --tag Preencher formul\u00e1rio de relato (ir\u00e1 receber por e-mail)","title":"Vixi! Sou scrum master"},{"location":"Util-vixi-sou-scrum/#criar-project-no-github","text":"Criando um project no github Adicionando issues Tip Os issues devem ser todos os m\u00f3dulos a serem implementados do projeto. Voc\u00ea deve manter o quadro atualizado.","title":"Criar project no github"},{"location":"VHDL-Combinacional/","text":"Combinacional \u00b6 Em sistemas digitais, l\u00f3gica combinacional \u00e9 aquela que n\u00e3o depende do estado anterior (n\u00e3o possui mem\u00f3ria), podemos classificar portas l\u00f3gicas (and, or, nand ...), mux, demux, comparadores, full address e outros componentes como sendo do tipo combinacional. Note Logic is combinational if outputs at a specified time are a function only of the inputs at that time. Examples of combinational logic functions are decoders, multiplexers, and adders. ... Trecho extra\u00eddo do site da intel VHDL \u00b6 Existem duas formas de descrevermos um circuito combinacional em VHDL, uma delas \u00e9 utilizando o process , n\u00e3o iremos tratar dessa alternativa nesse documento. Note O uso de process pode confundir voc\u00eas nesse primeiro momento, por parecer um fun\u00e7\u00e3o de um programa sequ\u00eancial. Para transcrevermos uma l\u00f3gica combinacional em VHDL basta escrever a implementa\u00e7\u00e3o Equa\u00e7\u00f5es \u00b6 Podemos escrever equa\u00e7\u00f5es em VHDL utilizando os seguintes operadores: not , and , or , nor , xor , xnor . Como no exemplo a seguir: X = (\\bar{A} . B) + C) X = (\\bar{A} . B) + C) Transcrevemos para: X <= (( not A ) and B ) or C ; Tip Abuse dos parenteses () para explicitar a l\u00f3gica desejada, por exemplo: not A and B ---> not (A and B) \\ \\-> (not A) and B Tip Quando desenvolvemos projetos para FPGA n\u00e3o tem a necessidade de simplificarmos a equa\u00e7\u00e3o l\u00f3gica, a ferramenta ( Quartus ) faz isso para a gente. Concatenate \u00b6 Em VHDL podemos concatenar bit para formar vetores, isso \u00e9 feito da seguinte forma: signal bit0 , bit1 : std_logic ; signal vec : std_logic_vector ( 1 downto 0 ); begin vec <= bit1 & bit0 ; end ; No exemplo anterior, temos um vetor de 2 bits ( vec ) que \u00e9 formado por: [bit1, bit0] . with select \u00b6 https://insights.sigasi.com/tech/signal-assignments-vhdl-withselect-whenelse-and-case/ O with select em VHDL \u00e9 utilizado quando desejamos que um sinal (ou sa\u00edda) receba diferentes valores com base em um sinal de sele\u00e7\u00e3o. No exemplo a seguir, o sinal b recebe o valor 1000 quando o sinal de sele\u00e7\u00e3o a for 00 , 0100 quando a for 01 , ..., note que no \u00faltimo caso usamos o others , ele entrou no lugar do 11 . signal a : std_logic_vector ( 1 downto 0 ); signal b : std_logic_Vector ( 3 downto 0 ); begin with a select b <= \"1000\" when \"00\" , \"0100\" when \"01\" , \"0010\" when \"10\" , \"0001\" when others ; O hardware gerado pela descri\u00e7\u00e3o anterior seria: Warning Utilizar others na \u00faltima op\u00e7\u00e3o! Tip Precisamos lembrar que no final tudo vai virar um hardware, o with \u00e9 normalmente interpretado como um mux ! when else \u00b6 O construtor when else \u00e9 um pouco mais geral, para cada op\u00e7\u00e3o voc\u00ea pode fornecer uma condi\u00e7\u00e3o diferente. O mesmo exemplo do with ficaria escrito da seguinte maneira: b <= \"1000\" when a = \"00\" else \"0100\" when a = \"01\" else \"0010\" when a = \"10\" else \"0001\" ; Warning A \u00faltima op\u00e7\u00e3o n\u00e3o deve possuir nenhuma condi\u00e7\u00e3o! Por\u00e9m com o when else temos a flexibilidade de realizar algo como: b <= \"1000\" when ( a = \"00\" AND en = '1' ) else \"0100\" when ( a = \"01\" AND en = '1' ) else \"0010\" when ( a = \"10\" AND en = '1' ) else \"0010\" when ( a = \"00\" AND en = '1' ) else \"0000\" ; -- enable desativado Nesse exemplo, temos duas condi\u00e7\u00f5es para cada op\u00e7\u00e3o: a e en devem satisfazer a condi\u00e7\u00e3o, isso n\u00e3o \u00e9 poss\u00edvel com o with select . Note others e else : Precisamos entender que um sinal do tipo std_logic em VHDL n\u00e3o pode assumir apenas os valores 0 e 1 , mas sim: 0 , 1 , X , Z , W , L , H , - , para cobrir todas as op\u00e7\u00f5es (com dois 'bits') dever\u00edamos possuir 64 linhas para cada with ou when que fossemos construir.","title":"Combinacional"},{"location":"VHDL-Combinacional/#combinacional","text":"Em sistemas digitais, l\u00f3gica combinacional \u00e9 aquela que n\u00e3o depende do estado anterior (n\u00e3o possui mem\u00f3ria), podemos classificar portas l\u00f3gicas (and, or, nand ...), mux, demux, comparadores, full address e outros componentes como sendo do tipo combinacional. Note Logic is combinational if outputs at a specified time are a function only of the inputs at that time. Examples of combinational logic functions are decoders, multiplexers, and adders. ... Trecho extra\u00eddo do site da intel","title":"Combinacional"},{"location":"VHDL-Combinacional/#vhdl","text":"Existem duas formas de descrevermos um circuito combinacional em VHDL, uma delas \u00e9 utilizando o process , n\u00e3o iremos tratar dessa alternativa nesse documento. Note O uso de process pode confundir voc\u00eas nesse primeiro momento, por parecer um fun\u00e7\u00e3o de um programa sequ\u00eancial. Para transcrevermos uma l\u00f3gica combinacional em VHDL basta escrever a implementa\u00e7\u00e3o","title":"VHDL"},{"location":"VHDL-Combinacional/#equacoes","text":"Podemos escrever equa\u00e7\u00f5es em VHDL utilizando os seguintes operadores: not , and , or , nor , xor , xnor . Como no exemplo a seguir: X = (\\bar{A} . B) + C) X = (\\bar{A} . B) + C) Transcrevemos para: X <= (( not A ) and B ) or C ; Tip Abuse dos parenteses () para explicitar a l\u00f3gica desejada, por exemplo: not A and B ---> not (A and B) \\ \\-> (not A) and B Tip Quando desenvolvemos projetos para FPGA n\u00e3o tem a necessidade de simplificarmos a equa\u00e7\u00e3o l\u00f3gica, a ferramenta ( Quartus ) faz isso para a gente.","title":"Equa\u00e7\u00f5es"},{"location":"VHDL-Combinacional/#concatenate","text":"Em VHDL podemos concatenar bit para formar vetores, isso \u00e9 feito da seguinte forma: signal bit0 , bit1 : std_logic ; signal vec : std_logic_vector ( 1 downto 0 ); begin vec <= bit1 & bit0 ; end ; No exemplo anterior, temos um vetor de 2 bits ( vec ) que \u00e9 formado por: [bit1, bit0] .","title":"Concatenate"},{"location":"VHDL-Combinacional/#with-select","text":"https://insights.sigasi.com/tech/signal-assignments-vhdl-withselect-whenelse-and-case/ O with select em VHDL \u00e9 utilizado quando desejamos que um sinal (ou sa\u00edda) receba diferentes valores com base em um sinal de sele\u00e7\u00e3o. No exemplo a seguir, o sinal b recebe o valor 1000 quando o sinal de sele\u00e7\u00e3o a for 00 , 0100 quando a for 01 , ..., note que no \u00faltimo caso usamos o others , ele entrou no lugar do 11 . signal a : std_logic_vector ( 1 downto 0 ); signal b : std_logic_Vector ( 3 downto 0 ); begin with a select b <= \"1000\" when \"00\" , \"0100\" when \"01\" , \"0010\" when \"10\" , \"0001\" when others ; O hardware gerado pela descri\u00e7\u00e3o anterior seria: Warning Utilizar others na \u00faltima op\u00e7\u00e3o! Tip Precisamos lembrar que no final tudo vai virar um hardware, o with \u00e9 normalmente interpretado como um mux !","title":"with select"},{"location":"VHDL-Combinacional/#when-else","text":"O construtor when else \u00e9 um pouco mais geral, para cada op\u00e7\u00e3o voc\u00ea pode fornecer uma condi\u00e7\u00e3o diferente. O mesmo exemplo do with ficaria escrito da seguinte maneira: b <= \"1000\" when a = \"00\" else \"0100\" when a = \"01\" else \"0010\" when a = \"10\" else \"0001\" ; Warning A \u00faltima op\u00e7\u00e3o n\u00e3o deve possuir nenhuma condi\u00e7\u00e3o! Por\u00e9m com o when else temos a flexibilidade de realizar algo como: b <= \"1000\" when ( a = \"00\" AND en = '1' ) else \"0100\" when ( a = \"01\" AND en = '1' ) else \"0010\" when ( a = \"10\" AND en = '1' ) else \"0010\" when ( a = \"00\" AND en = '1' ) else \"0000\" ; -- enable desativado Nesse exemplo, temos duas condi\u00e7\u00f5es para cada op\u00e7\u00e3o: a e en devem satisfazer a condi\u00e7\u00e3o, isso n\u00e3o \u00e9 poss\u00edvel com o with select . Note others e else : Precisamos entender que um sinal do tipo std_logic em VHDL n\u00e3o pode assumir apenas os valores 0 e 1 , mas sim: 0 , 1 , X , Z , W , L , H , - , para cobrir todas as op\u00e7\u00f5es (com dois 'bits') dever\u00edamos possuir 64 linhas para cada with ou when que fossemos construir.","title":"when else"},{"location":"VHDL-RTL/","text":"RTL Viewer \u00b6 RTL \u00e9 uma forma de visualiza\u00e7\u00e3o de um circuito digital. Ela nos ajudar\u00e1 a entender o circuito que foi escrito em HDL. Muitas vezes a pr\u00f3pria ferramenta n\u00e3o compreende o hardware que desejamos descrever (lembre que HDL \u00e9 uma linguagem de descri\u00e7\u00e3o de hardware, n\u00e3o de programa\u00e7\u00e3o). Com o RTL conseguimos ter uma no\u00e7\u00e3o de qual foi a 'interpreta\u00e7\u00e3o' do nosso hardware que a ferramenta (no caso o Quartus) entendeu. O RTL Viewer \u00e9 uma ferramenta do Quartus utilizada para visualizar o RTL (interpreta\u00e7\u00e3o do hardware descrito em HDL). Para criarmos esse RTL de um m\u00f3dulo espec\u00edfico devemos no Quartus selecionar o componente em quest\u00e3o como TopLevel , para isso fa\u00e7a o seguinte: Example Exemplo para o projeto D, mas se aplica a qualquer outro! Abra o projeto no Quartus localizado em D-LogicaSequencial/Quartus/ No Project Navigator escolha por Files : Encontre o arquivo que deseja configurar como TopLevel : Clique com o bot\u00e3o direito no arquivo e selecione a op\u00e7\u00e3o: Set as Top Level Entity Agora o Quartus ir\u00e1 enterpretar esse m\u00f3dulo como sendo o \"top\" do projeto (podemos pensar como sendo o main ). Compile o Projeto ( Processing -> Start ) Abra o RTL Viewer ( Tools -> NetList Viewers -> RTL Viewer ) Esse c\u00f3digo em VHDL ir\u00e1 ser interpretada pelo compilador como um FlipFlop tipo D.","title":"RTL Viewer"},{"location":"VHDL-RTL/#rtl-viewer","text":"RTL \u00e9 uma forma de visualiza\u00e7\u00e3o de um circuito digital. Ela nos ajudar\u00e1 a entender o circuito que foi escrito em HDL. Muitas vezes a pr\u00f3pria ferramenta n\u00e3o compreende o hardware que desejamos descrever (lembre que HDL \u00e9 uma linguagem de descri\u00e7\u00e3o de hardware, n\u00e3o de programa\u00e7\u00e3o). Com o RTL conseguimos ter uma no\u00e7\u00e3o de qual foi a 'interpreta\u00e7\u00e3o' do nosso hardware que a ferramenta (no caso o Quartus) entendeu. O RTL Viewer \u00e9 uma ferramenta do Quartus utilizada para visualizar o RTL (interpreta\u00e7\u00e3o do hardware descrito em HDL). Para criarmos esse RTL de um m\u00f3dulo espec\u00edfico devemos no Quartus selecionar o componente em quest\u00e3o como TopLevel , para isso fa\u00e7a o seguinte: Example Exemplo para o projeto D, mas se aplica a qualquer outro! Abra o projeto no Quartus localizado em D-LogicaSequencial/Quartus/ No Project Navigator escolha por Files : Encontre o arquivo que deseja configurar como TopLevel : Clique com o bot\u00e3o direito no arquivo e selecione a op\u00e7\u00e3o: Set as Top Level Entity Agora o Quartus ir\u00e1 enterpretar esse m\u00f3dulo como sendo o \"top\" do projeto (podemos pensar como sendo o main ). Compile o Projeto ( Processing -> Start ) Abra o RTL Viewer ( Tools -> NetList Viewers -> RTL Viewer ) Esse c\u00f3digo em VHDL ir\u00e1 ser interpretada pelo compilador como um FlipFlop tipo D.","title":"RTL Viewer"},{"location":"VHDL-Sequencial/","text":"Sequencial \u00b6 Como trabalhar com l\u00f3gica sequ\u00eancia em VHDL Process VHDL \u00b6 Em VHDL quando desejamos fazer algo sequencial \u00e9 necess\u00e1rio usarmos uma estrutura chamada de process, que possui a declara\u00e7\u00e3o a seguir: process ( optional sensitivity list ) declarations begin sequential statements end process ; Nesse process possu\u00edmos a lista de sensibilidade ( sensitivity list ) que indica quando o process ser\u00e1 executado. Podemos pensar da seguinte maneira, sempre que algum sinal que est\u00e1 listado nessa lista de sensibilidade mudar de valor ( 0 -> 1 , 1 -> 0 ) o processo ser\u00e1 executado. Vamos ver o exemplo a seguir: process ( A ) begin Q <= A ; end process ; Entendendo Sempre que o sinal A (sinal ou porta) alterar de valor o sinal Q ser\u00e1 atribu\u00eddo com o seu valor Agora vamos criar um outro processo ( esse estar\u00e1 errado ): process ( A ) begin Q <= A and B ; end process ; A ideia por traz desse processo seria que o sinal Q receba o sinal A e B sempre que algum dos dois sofram alguma altera\u00e7\u00e3o, por\u00e9m essa implementa\u00e7\u00e3o n\u00e3o ir\u00e1 funcionar j\u00e1 que B n\u00e3o faz parte da lista de sensibilidade e se B mudar de valor o processo n\u00e3o ser\u00e1 chamado, o sinal Q s\u00f3 ser\u00e1 atualizado quando A mudar de valor. Tarefa Reescreva no codeshare do grupo o m\u00f3dulo anterior corrigido. Chame um professor para validar! Clock \u00b6 Para inserirmos um clock (um sistema s\u00edncrono) precisamos necessariamente usar um process , e a arquitetura \u00e9 a seguinte: process ( clock ) begin if ( rising_edge ( clock )) then Q <= D ; end if ; end process ; Sempre que o clock sofrer varia\u00e7\u00e3o ( 0 -> 1 , 1 -> 0 ) o process \u00e9 chamado e verifica-se se a transi\u00e7\u00e3o foi de borda de subida ( rising_edge ) se for, atribui o sinal A ao sinal Q, caso contr\u00e1rio Q mant\u00e9m seu \u00faltimo valor. Note Em FPGA um sinal digital n\u00e3o deve sofrer atualiza\u00e7\u00e3o em ambas as bordas: subida ( rising_edge ) e de descida ( falling_edge ) pois n\u00e3o ser\u00e1 suportado por hardware . Salvo em registradores DDR (duble data rate) especiais, exemplo do que n\u00e3o deve ser feito!: process ( clock ) begin if ( rising_edge ( clock )) then Q <= D ; elsif ( falling_edge ( clock )) then Q <= D ; end if ; end process ;","title":"Sequencial"},{"location":"VHDL-Sequencial/#sequencial","text":"Como trabalhar com l\u00f3gica sequ\u00eancia em VHDL","title":"Sequencial"},{"location":"VHDL-Sequencial/#process-vhdl","text":"Em VHDL quando desejamos fazer algo sequencial \u00e9 necess\u00e1rio usarmos uma estrutura chamada de process, que possui a declara\u00e7\u00e3o a seguir: process ( optional sensitivity list ) declarations begin sequential statements end process ; Nesse process possu\u00edmos a lista de sensibilidade ( sensitivity list ) que indica quando o process ser\u00e1 executado. Podemos pensar da seguinte maneira, sempre que algum sinal que est\u00e1 listado nessa lista de sensibilidade mudar de valor ( 0 -> 1 , 1 -> 0 ) o processo ser\u00e1 executado. Vamos ver o exemplo a seguir: process ( A ) begin Q <= A ; end process ; Entendendo Sempre que o sinal A (sinal ou porta) alterar de valor o sinal Q ser\u00e1 atribu\u00eddo com o seu valor Agora vamos criar um outro processo ( esse estar\u00e1 errado ): process ( A ) begin Q <= A and B ; end process ; A ideia por traz desse processo seria que o sinal Q receba o sinal A e B sempre que algum dos dois sofram alguma altera\u00e7\u00e3o, por\u00e9m essa implementa\u00e7\u00e3o n\u00e3o ir\u00e1 funcionar j\u00e1 que B n\u00e3o faz parte da lista de sensibilidade e se B mudar de valor o processo n\u00e3o ser\u00e1 chamado, o sinal Q s\u00f3 ser\u00e1 atualizado quando A mudar de valor. Tarefa Reescreva no codeshare do grupo o m\u00f3dulo anterior corrigido. Chame um professor para validar!","title":"Process VHDL"},{"location":"VHDL-Sequencial/#clock","text":"Para inserirmos um clock (um sistema s\u00edncrono) precisamos necessariamente usar um process , e a arquitetura \u00e9 a seguinte: process ( clock ) begin if ( rising_edge ( clock )) then Q <= D ; end if ; end process ; Sempre que o clock sofrer varia\u00e7\u00e3o ( 0 -> 1 , 1 -> 0 ) o process \u00e9 chamado e verifica-se se a transi\u00e7\u00e3o foi de borda de subida ( rising_edge ) se for, atribui o sinal A ao sinal Q, caso contr\u00e1rio Q mant\u00e9m seu \u00faltimo valor. Note Em FPGA um sinal digital n\u00e3o deve sofrer atualiza\u00e7\u00e3o em ambas as bordas: subida ( rising_edge ) e de descida ( falling_edge ) pois n\u00e3o ser\u00e1 suportado por hardware . Salvo em registradores DDR (duble data rate) especiais, exemplo do que n\u00e3o deve ser feito!: process ( clock ) begin if ( rising_edge ( clock )) then Q <= D ; elsif ( falling_edge ( clock )) then Q <= D ; end if ; end process ;","title":"Clock"},{"location":"VHDL-basico/","text":"Introdu\u00e7\u00e3o \u00b6 Estudando Leituras (extra) Free Range VHDL BOOK VHDL CookBook VHDL B\u00e1sico: Parte 1 - Entidade VHDL B\u00e1sico: Parte 2 - Arquitetura V\u00eddeos (extra) O VHDL \u00e9 uma linguagem de descri\u00e7\u00e3o de hardware ( Hardware Description Language - HDL ), n\u00e3o sendo uma linguagem de programa\u00e7\u00e3o. Foi criada durante a Guerra Fria no Departamento de Defesa Americano (DoD-DARPA) para a documenta\u00e7\u00e3o de hardwares complexos (complementava/substitu\u00eda os esquem\u00e1ticos). Com a evolu\u00e7\u00e3o da tecnologia agora \u00e9 poss\u00edvel utilizar a linguagem para implementar sistemas digitais em hardwares program\u00e1veis (FPGA/CPL/...). Por n\u00e3o ter sido criada para o fim que a utilizamos, o VHDL \u00e9 no primeiro momento bastante intricado. Mas com o usar, voc\u00eas ir\u00e3o se acostumar com a linguagem e ser\u00e3o capazes de realizar hardwares cada vez mais complexos. Note Algumas vezes iremos utilizar a palavra 'c\u00f3digo' para descrever um projeto em VHDL, tenha em mente que n\u00e3o estamos falando de um programa e sim de uma descri\u00e7\u00e3o de hardware. Um programa em Python / Java / C \u00e9 como uma receita de bolo que ser\u00e1 executada em uma cozinha que j\u00e1 est\u00e1 montada, essa cozinha \u00e9 o sua CPU (processador), e n\u00e3o d\u00e1 para mudar com c\u00f3digo (software), o que voc\u00ea muda de um programa para outro \u00e9 a receita. Uma cozinha \u00e9 capaz de realizar diversas receitas diferentes .... No caso do VHDL n\u00e3o temos essa 'cozinha' pronta, na verdade, podemos criar qualquer cozinha que quisermos. Com o VHDL voc\u00ea ser\u00e1 o arquiteto de cozinhas, capaz de criar praticamente qualquer hardware! E ent\u00e3o realizar suas receitas na cozinha que criou. Regras de Ouro do VHDL \u00b6 VHDL \u00e9 uma descri\u00e7\u00e3o, ou projeto, do hardware e n\u00e3o uma programa\u00e7\u00e3o dele. As linhas de c\u00f3digo n\u00e3o s\u00e3o executadas sequencialmente com exce\u00e7\u00e3o de algumas constru\u00e7\u00f5es da linguagem. As linhas de c\u00f3digo ser\u00e3o executadas simultaneamente. Deve-se possuir uma vis\u00e3o de como o circuito digital final ser\u00e1. Se ele for muito complexo, use uma divis\u00e3o em blocos menores at\u00e9 chegar \u00e0s unidades construtivas b\u00e1sicas. B\u00e1sico \u00b6 Um c\u00f3digo em VHDL possui basicamente tr\u00eas partes: Declara\u00e7\u00e3o de bibliotecas utilizadas library ieee ; use ieee.std_logic_1164. all ; use ieee.numeric_std. all ; use work. all ; Declara\u00e7\u00e3o das entradas e sa\u00eddas desse bloco (entidade) entity TopLevel is port ( a : in std_logic ; b : out std_logic ); end entity ; Implementa\u00e7\u00e3o da l\u00f3gica que relaciona as entradas e sa\u00eddas do m\u00f3dulo (arquitetura) architecture rtl of TopLevel is begin a <= not b ; -- a sa\u00edda A recebe a entrada B end rtl ; Coment\u00e1rios em VHDL Coment\u00e1rios em VHDL s\u00e3o iniciados com dois tra\u00e7os: -- . Exemplo: -- Comen\u00e1rio em VHDL -- a <= not b; Trecho de c\u00f3digo comentado a <= ` 1 ` ; -- coment\u00e1rio Bibliotecas \u00b6 As bibliotecas do VHDL s\u00e3o onde as defini\u00e7\u00f5es dos tipos e das opera\u00e7\u00f5es s\u00e3o realizadas, n\u00e3o ser\u00e1 necess\u00e1rio mexer com isso ao longo do semestre, essa parte j\u00e1 vai estar pronta nos projetos que voc\u00eas forem mexer. Entidade (entity) \u00b6 Podemos pensar na entidade como o trecho de c\u00f3digo que define o m\u00f3dulo como uma caixa preta, ela explicita quem s\u00e3o as entradas e quais s\u00e3o as sa\u00eddas desse m\u00f3dulo. Assim como um CHIP, que possui pinos de entradas e pinos de sa\u00edda. No exemplo anterior, o m\u00f3dulo \u00e9 chamado de TopLevel e possui uma entrada a e uma sa\u00edda b . Tanto a entrada quanto a sa\u00edda s\u00e3o do tipo std_logic . Cada porta tem a descri\u00e7\u00e3o de sua dire\u00e7\u00e3o ( in , out ), como detalhado a seguir: Uma entidade pode ter nenhuma ou 'infinitas' portas, para adicionarmos uma porta nova a uma entidade, basta adicionarmos uma nova linha com as tr\u00eas propriedades: NOME : DIRE\u00c7\u00c3O TIPO; Tip Note a necessidade do ; no final da linha, isso indica para o VHDL que essa descri\u00e7\u00e3o 'acabou'. A quebra de linha Enter n\u00e3o tem uso para o VHDL, s\u00f3 serve para facilitar nossa leitura. Warning O ; n\u00e3o deve aparecer na \u00faltima porta! No exemplo anterior a porta b : out STD_LOGIC n\u00e3o possui ; . Example Adicionando uma entrada x ao m\u00f3dulo anterior: entity TopLevel is port ( a : in std_logic ; b : out std_logic ; x : in std_logic ); end entity ; Nome \u00b6 No VHDL voc\u00ea n\u00e3o pode usar um nome de porta que: Comece com um n\u00famero: ( 0 , 1 , ... ), ex: 0bus : out std_logic; \u00c9 uma das muitas palavras reservadas : in , out , not , ex: bus : out std_logic; Possua espa\u00e7o: entrada 1: in std_logic; Para mais detalhes, d\u00ea uma olhada na documenta\u00e7\u00e3o completa Dire\u00e7\u00e3o \u00b6 A dire\u00e7\u00e3o in , out define se a informa\u00e7\u00e3o ir\u00e1 entrar no m\u00f3dulo ou sair do m\u00f3dulo. Por exemplo, se quisermos 'ler' um bot\u00e3o, devemos declarar essa porta como sendo uma 'entrada' ( in ) do m\u00f3dulo, mas se quisermos acionar um LED, devemos declarar essa porta como 'sa\u00edda' ( out ), pois ela ser\u00e1 controlada por nossa l\u00f3gica. Tipo \u00b6 O tipo define se a porta ser\u00e1 composta por um \u00fanico bit std_logic ou por um vetor de bits std_logic_vector(2 downto 0) (vetor de 3 bits). O tipo STD_LOGIC \u00e9 muito mais complexo que s\u00f3 um bit, mas vamos deixar isso de lado por ora. Exemplos \u00b6 M\u00f3dulo com duas entradas bin\u00e1rias: a , x e uma sa\u00edda b entity Comp1 is port ( a : in std_logic ; x : in std_logic ; b : out std_logic ); end entity ; M\u00f3dulo chamado MUX que possui 4 entradas na forma de um vetor ( I : in std_logic_vector(3 downto 0) ), um seletor de dois bits na forma de um vetor ( S ) e uma sa\u00edda q na forma de um bit. entity mux is port ( I : in std_logic_vector ( 3 downto 0 ); S : in std_logic_vector ( 1 downto 0 ); q : out std_logic ); end entity ; Tip Note que a entrada I foi declarada como sendo um vetor que come\u00e7a em 3 e termina em 0 , possuindo no total 4 bits: 3 , 2 , 1 , 0 Em diagrama el\u00e9trico \u00e9 utilizado a seguinte nota\u00e7\u00e3o para indicar um vetor de bits: Uso de uma / no fio com a indica\u00e7\u00e3o da quantidade de bits Uso de uma linha mais grossa, para indicar um vetor Entidade de uma ULA entity ALU is port ( x , y : in STD_LOGIC_VECTOR ( 15 downto 0 ); -- entradas de dados da ALU zx : in STD_LOGIC ; -- zera a entrada x nx : in STD_LOGIC ; -- inverte a entrada x zy : in STD_LOGIC ; -- zera a entrada y ny : in STD_LOGIC ; -- inverte a entrada y f : in STD_LOGIC ; -- se 0 calcula x & y, sen\u00e3o x + y no : in STD_LOGIC ; -- inverte o valor da sa\u00edda zr : out STD_LOGIC ; -- setado se sa\u00edda igual a zero ng : out STD_LOGIC ; -- setado se sa\u00edda \u00e9 negativa saida : out STD_LOGIC_VECTOR ( 15 downto 0 ) -- sa\u00edda de dados da ALU ); end entity ; nota Note que a primeira linha declara duas portas com nome x e y com a mesma dire\u00e7\u00e3o in e do tipo std_logic_vector(15 downto 0) . Isso \u00e9 um atalho no VHDL e deve ser evitado. O ideal \u00e9 reescrever essa linha como a seguir: port ( x : in STD_LOGIC_VECTOR ( 15 downto 0 ); -- entrada X de dados da ALU y : in STD_LOGIC_VECTOR ( 15 downto 0 ); -- entrada Y de dados da ALU Arquitetura (architecture) \u00b6 A arquitetura ( architecture ) define a rela\u00e7\u00e3o das entradas com as sa\u00eddas da entidade. Nessa parte \u00e9 onde ser\u00e1 constru\u00edda a l\u00f3gica digital desse m\u00f3dulo. Pense que \u00e9 na arquitetura onde transcrevemos uma equa\u00e7\u00e3o l\u00f3gica, ou onde descrevemos uma mem\u00f3ria. architecture rtl of TopLevel is -- Aqui \u00e9 declaro os poss\u00edveis: -- a) sinais internos de uma entidade -- b) outras entidades que essa entidade pode utilizar begin -- Aqui \u00e9 onde a coisa acontece de verdade -- onde \u00e9 feita a descri\u00e7\u00e3o da l\u00f3gica digital a <= not b ; end rtl ; Opera\u00e7\u00f5es b\u00e1sicas \u00b6 Suponha o uso da entidade a seguir para os exemplos que ser\u00e3o apresentados entity Foo is port ( x : in std_logic ; y : in std_logic ; q : out std_logic ; p : out std_logic ); end entity ; No VHDL usamos <= para representar que alguma coisa (a esquerda da seta) recebe algum outro valor (a direita da seta). Exemplos: q <= x; q recebe o valor de x Na pr\u00e1tica estamos conectando um fio de x que liga em q q <= '0'; q recebe o valor 0 Na pr\u00e1tica estamos conectando um fio que sai de q e liga no terra q <= '1'; q recebe o valor 1 Na pr\u00e1tica estamos conectando um fio que sai de q e liga no vcc Note Note que aqui estamos usando aspas simples: '0' e '1' para indicar um n\u00famero bin\u00e1rio ( std_logic ). Aspas dupla \"0101\" em VHDL significa que estamos trabalhando com um vetor de n\u00fameros bin\u00e1rios ( std_logic_vector ). Podemos utilizar portas l\u00f3gicas nas opera\u00e7\u00f5es, alguns operadores implementados pela linguagem, s\u00e3o: not , and , or , nand , nor , xor , xnor . O uso dos operadores \u00e9 feito da seguinte maneira: q <= not x; q recebe o valor de x negado q <= x and y; q recebe o valor de x E y p <= x xor y; q recebe o valor de x XOR y Warning Em VHDL n\u00e3o \u00e9 poss\u00edvel 'ler' uma sa\u00edda, as seguintes opera\u00e7\u00f5es n\u00e3o pode ser realizada: q <= not x ; -- x \u00e9 sa\u00edda p <= q ; -- q \u00e9 sa\u00edda Opera\u00e7\u00e3o com vetores \u00b6 Suponha o uso da entidade a seguir para os exemplos que ser\u00e3o apresentados entity Bar is port ( a : in std_logic ; b : in std_logic_vector ( 3 downto 0 ); q : out std_logic ; p : out std_logic_vector ( 2 downto 0 ) ); end entity ; Exemplos de opera\u00e7\u00e3o com vetores: p <= \"100\" p recebe o valor em bin\u00e1rio 100 p <= not \"100\" p recebe o valor em bin\u00e1rio 011 p <= b(2 downto 0); p recebe os tr\u00eas primeiros bits de b p(0) <= a; p bit 0 recebe o valor da entrada a q <= not b(1); a sa\u00edda bin\u00e1ria q recebe o bit 1 da entrada b negado. Tip \u00c9 comum confundir quando usar aspas simples '' e aspas dupla \"\" , fique atento aos erros de compila\u00e7\u00e3o. signal \u00b6 Sinais s\u00e3o declarados entre a palavra reservada architecture e o begin e servem para facilitar/ possibilitar o desenvolvimento de um sistema digital, eles s\u00f3 s\u00e3o vis\u00edveis dentro de uma entidade e servem como 'fios' internos de um m\u00f3dulo. Sinais s\u00e3o diferente de portas n\u00e3o possuem dire\u00e7\u00e3o, e s\u00e3o declarados da seguinte maneira: signal NAME : TYPE TYPE pode ser: std_logic / std_logic_vector , entre outros. Exemplo: architecture rtl of TopLevel is -- Declara\u00e7\u00e3o de sinais signal aux1 : std_logic ; signal aux2 : std_logic_vector ( 1 downto 0 ); -- inicio da implementa\u00e7\u00e3o begin -------------------- aux1 <= not a ; q <= aux1 ; p ( 0 ) <= aux1 ; -------------------- aux2 <= b ( 3 downto 2 ); p ( 2 downto 1 ) <= aux2 ; end rtl ; No exemplo anterior, criamos um sinal auxiliar chamado de aux1 que recebe a entrada a negada, esse sinal \u00e9 ent\u00e3o atribu\u00eddo a sa\u00edda q e ao bit 0 da sa\u00edda p . Outro sinal aux2 , vetor de 2 bits recebe os dois bits mais significativos da entrada b e ent\u00e3o \u00e9 atribu\u00eddo a sa\u00edda p , bits 2 e 1.","title":"Introdu\u00e7\u00e3o"},{"location":"VHDL-basico/#introducao","text":"Estudando Leituras (extra) Free Range VHDL BOOK VHDL CookBook VHDL B\u00e1sico: Parte 1 - Entidade VHDL B\u00e1sico: Parte 2 - Arquitetura V\u00eddeos (extra) O VHDL \u00e9 uma linguagem de descri\u00e7\u00e3o de hardware ( Hardware Description Language - HDL ), n\u00e3o sendo uma linguagem de programa\u00e7\u00e3o. Foi criada durante a Guerra Fria no Departamento de Defesa Americano (DoD-DARPA) para a documenta\u00e7\u00e3o de hardwares complexos (complementava/substitu\u00eda os esquem\u00e1ticos). Com a evolu\u00e7\u00e3o da tecnologia agora \u00e9 poss\u00edvel utilizar a linguagem para implementar sistemas digitais em hardwares program\u00e1veis (FPGA/CPL/...). Por n\u00e3o ter sido criada para o fim que a utilizamos, o VHDL \u00e9 no primeiro momento bastante intricado. Mas com o usar, voc\u00eas ir\u00e3o se acostumar com a linguagem e ser\u00e3o capazes de realizar hardwares cada vez mais complexos. Note Algumas vezes iremos utilizar a palavra 'c\u00f3digo' para descrever um projeto em VHDL, tenha em mente que n\u00e3o estamos falando de um programa e sim de uma descri\u00e7\u00e3o de hardware. Um programa em Python / Java / C \u00e9 como uma receita de bolo que ser\u00e1 executada em uma cozinha que j\u00e1 est\u00e1 montada, essa cozinha \u00e9 o sua CPU (processador), e n\u00e3o d\u00e1 para mudar com c\u00f3digo (software), o que voc\u00ea muda de um programa para outro \u00e9 a receita. Uma cozinha \u00e9 capaz de realizar diversas receitas diferentes .... No caso do VHDL n\u00e3o temos essa 'cozinha' pronta, na verdade, podemos criar qualquer cozinha que quisermos. Com o VHDL voc\u00ea ser\u00e1 o arquiteto de cozinhas, capaz de criar praticamente qualquer hardware! E ent\u00e3o realizar suas receitas na cozinha que criou.","title":"Introdu\u00e7\u00e3o"},{"location":"VHDL-basico/#regras-de-ouro-do-vhdl","text":"VHDL \u00e9 uma descri\u00e7\u00e3o, ou projeto, do hardware e n\u00e3o uma programa\u00e7\u00e3o dele. As linhas de c\u00f3digo n\u00e3o s\u00e3o executadas sequencialmente com exce\u00e7\u00e3o de algumas constru\u00e7\u00f5es da linguagem. As linhas de c\u00f3digo ser\u00e3o executadas simultaneamente. Deve-se possuir uma vis\u00e3o de como o circuito digital final ser\u00e1. Se ele for muito complexo, use uma divis\u00e3o em blocos menores at\u00e9 chegar \u00e0s unidades construtivas b\u00e1sicas.","title":"Regras de Ouro do VHDL"},{"location":"VHDL-basico/#basico","text":"Um c\u00f3digo em VHDL possui basicamente tr\u00eas partes: Declara\u00e7\u00e3o de bibliotecas utilizadas library ieee ; use ieee.std_logic_1164. all ; use ieee.numeric_std. all ; use work. all ; Declara\u00e7\u00e3o das entradas e sa\u00eddas desse bloco (entidade) entity TopLevel is port ( a : in std_logic ; b : out std_logic ); end entity ; Implementa\u00e7\u00e3o da l\u00f3gica que relaciona as entradas e sa\u00eddas do m\u00f3dulo (arquitetura) architecture rtl of TopLevel is begin a <= not b ; -- a sa\u00edda A recebe a entrada B end rtl ; Coment\u00e1rios em VHDL Coment\u00e1rios em VHDL s\u00e3o iniciados com dois tra\u00e7os: -- . Exemplo: -- Comen\u00e1rio em VHDL -- a <= not b; Trecho de c\u00f3digo comentado a <= ` 1 ` ; -- coment\u00e1rio","title":"B\u00e1sico"},{"location":"VHDL-basico/#bibliotecas","text":"As bibliotecas do VHDL s\u00e3o onde as defini\u00e7\u00f5es dos tipos e das opera\u00e7\u00f5es s\u00e3o realizadas, n\u00e3o ser\u00e1 necess\u00e1rio mexer com isso ao longo do semestre, essa parte j\u00e1 vai estar pronta nos projetos que voc\u00eas forem mexer.","title":"Bibliotecas"},{"location":"VHDL-basico/#entidade-entity","text":"Podemos pensar na entidade como o trecho de c\u00f3digo que define o m\u00f3dulo como uma caixa preta, ela explicita quem s\u00e3o as entradas e quais s\u00e3o as sa\u00eddas desse m\u00f3dulo. Assim como um CHIP, que possui pinos de entradas e pinos de sa\u00edda. No exemplo anterior, o m\u00f3dulo \u00e9 chamado de TopLevel e possui uma entrada a e uma sa\u00edda b . Tanto a entrada quanto a sa\u00edda s\u00e3o do tipo std_logic . Cada porta tem a descri\u00e7\u00e3o de sua dire\u00e7\u00e3o ( in , out ), como detalhado a seguir: Uma entidade pode ter nenhuma ou 'infinitas' portas, para adicionarmos uma porta nova a uma entidade, basta adicionarmos uma nova linha com as tr\u00eas propriedades: NOME : DIRE\u00c7\u00c3O TIPO; Tip Note a necessidade do ; no final da linha, isso indica para o VHDL que essa descri\u00e7\u00e3o 'acabou'. A quebra de linha Enter n\u00e3o tem uso para o VHDL, s\u00f3 serve para facilitar nossa leitura. Warning O ; n\u00e3o deve aparecer na \u00faltima porta! No exemplo anterior a porta b : out STD_LOGIC n\u00e3o possui ; . Example Adicionando uma entrada x ao m\u00f3dulo anterior: entity TopLevel is port ( a : in std_logic ; b : out std_logic ; x : in std_logic ); end entity ;","title":"Entidade (entity)"},{"location":"VHDL-basico/#nome","text":"No VHDL voc\u00ea n\u00e3o pode usar um nome de porta que: Comece com um n\u00famero: ( 0 , 1 , ... ), ex: 0bus : out std_logic; \u00c9 uma das muitas palavras reservadas : in , out , not , ex: bus : out std_logic; Possua espa\u00e7o: entrada 1: in std_logic; Para mais detalhes, d\u00ea uma olhada na documenta\u00e7\u00e3o completa","title":"Nome"},{"location":"VHDL-basico/#direcao","text":"A dire\u00e7\u00e3o in , out define se a informa\u00e7\u00e3o ir\u00e1 entrar no m\u00f3dulo ou sair do m\u00f3dulo. Por exemplo, se quisermos 'ler' um bot\u00e3o, devemos declarar essa porta como sendo uma 'entrada' ( in ) do m\u00f3dulo, mas se quisermos acionar um LED, devemos declarar essa porta como 'sa\u00edda' ( out ), pois ela ser\u00e1 controlada por nossa l\u00f3gica.","title":"Dire\u00e7\u00e3o"},{"location":"VHDL-basico/#tipo","text":"O tipo define se a porta ser\u00e1 composta por um \u00fanico bit std_logic ou por um vetor de bits std_logic_vector(2 downto 0) (vetor de 3 bits). O tipo STD_LOGIC \u00e9 muito mais complexo que s\u00f3 um bit, mas vamos deixar isso de lado por ora.","title":"Tipo"},{"location":"VHDL-basico/#exemplos","text":"M\u00f3dulo com duas entradas bin\u00e1rias: a , x e uma sa\u00edda b entity Comp1 is port ( a : in std_logic ; x : in std_logic ; b : out std_logic ); end entity ; M\u00f3dulo chamado MUX que possui 4 entradas na forma de um vetor ( I : in std_logic_vector(3 downto 0) ), um seletor de dois bits na forma de um vetor ( S ) e uma sa\u00edda q na forma de um bit. entity mux is port ( I : in std_logic_vector ( 3 downto 0 ); S : in std_logic_vector ( 1 downto 0 ); q : out std_logic ); end entity ; Tip Note que a entrada I foi declarada como sendo um vetor que come\u00e7a em 3 e termina em 0 , possuindo no total 4 bits: 3 , 2 , 1 , 0 Em diagrama el\u00e9trico \u00e9 utilizado a seguinte nota\u00e7\u00e3o para indicar um vetor de bits: Uso de uma / no fio com a indica\u00e7\u00e3o da quantidade de bits Uso de uma linha mais grossa, para indicar um vetor Entidade de uma ULA entity ALU is port ( x , y : in STD_LOGIC_VECTOR ( 15 downto 0 ); -- entradas de dados da ALU zx : in STD_LOGIC ; -- zera a entrada x nx : in STD_LOGIC ; -- inverte a entrada x zy : in STD_LOGIC ; -- zera a entrada y ny : in STD_LOGIC ; -- inverte a entrada y f : in STD_LOGIC ; -- se 0 calcula x & y, sen\u00e3o x + y no : in STD_LOGIC ; -- inverte o valor da sa\u00edda zr : out STD_LOGIC ; -- setado se sa\u00edda igual a zero ng : out STD_LOGIC ; -- setado se sa\u00edda \u00e9 negativa saida : out STD_LOGIC_VECTOR ( 15 downto 0 ) -- sa\u00edda de dados da ALU ); end entity ; nota Note que a primeira linha declara duas portas com nome x e y com a mesma dire\u00e7\u00e3o in e do tipo std_logic_vector(15 downto 0) . Isso \u00e9 um atalho no VHDL e deve ser evitado. O ideal \u00e9 reescrever essa linha como a seguir: port ( x : in STD_LOGIC_VECTOR ( 15 downto 0 ); -- entrada X de dados da ALU y : in STD_LOGIC_VECTOR ( 15 downto 0 ); -- entrada Y de dados da ALU","title":"Exemplos"},{"location":"VHDL-basico/#arquitetura-architecture","text":"A arquitetura ( architecture ) define a rela\u00e7\u00e3o das entradas com as sa\u00eddas da entidade. Nessa parte \u00e9 onde ser\u00e1 constru\u00edda a l\u00f3gica digital desse m\u00f3dulo. Pense que \u00e9 na arquitetura onde transcrevemos uma equa\u00e7\u00e3o l\u00f3gica, ou onde descrevemos uma mem\u00f3ria. architecture rtl of TopLevel is -- Aqui \u00e9 declaro os poss\u00edveis: -- a) sinais internos de uma entidade -- b) outras entidades que essa entidade pode utilizar begin -- Aqui \u00e9 onde a coisa acontece de verdade -- onde \u00e9 feita a descri\u00e7\u00e3o da l\u00f3gica digital a <= not b ; end rtl ;","title":"Arquitetura (architecture)"},{"location":"VHDL-basico/#operacoes-basicas","text":"Suponha o uso da entidade a seguir para os exemplos que ser\u00e3o apresentados entity Foo is port ( x : in std_logic ; y : in std_logic ; q : out std_logic ; p : out std_logic ); end entity ; No VHDL usamos <= para representar que alguma coisa (a esquerda da seta) recebe algum outro valor (a direita da seta). Exemplos: q <= x; q recebe o valor de x Na pr\u00e1tica estamos conectando um fio de x que liga em q q <= '0'; q recebe o valor 0 Na pr\u00e1tica estamos conectando um fio que sai de q e liga no terra q <= '1'; q recebe o valor 1 Na pr\u00e1tica estamos conectando um fio que sai de q e liga no vcc Note Note que aqui estamos usando aspas simples: '0' e '1' para indicar um n\u00famero bin\u00e1rio ( std_logic ). Aspas dupla \"0101\" em VHDL significa que estamos trabalhando com um vetor de n\u00fameros bin\u00e1rios ( std_logic_vector ). Podemos utilizar portas l\u00f3gicas nas opera\u00e7\u00f5es, alguns operadores implementados pela linguagem, s\u00e3o: not , and , or , nand , nor , xor , xnor . O uso dos operadores \u00e9 feito da seguinte maneira: q <= not x; q recebe o valor de x negado q <= x and y; q recebe o valor de x E y p <= x xor y; q recebe o valor de x XOR y Warning Em VHDL n\u00e3o \u00e9 poss\u00edvel 'ler' uma sa\u00edda, as seguintes opera\u00e7\u00f5es n\u00e3o pode ser realizada: q <= not x ; -- x \u00e9 sa\u00edda p <= q ; -- q \u00e9 sa\u00edda","title":"Opera\u00e7\u00f5es b\u00e1sicas"},{"location":"VHDL-basico/#operacao-com-vetores","text":"Suponha o uso da entidade a seguir para os exemplos que ser\u00e3o apresentados entity Bar is port ( a : in std_logic ; b : in std_logic_vector ( 3 downto 0 ); q : out std_logic ; p : out std_logic_vector ( 2 downto 0 ) ); end entity ; Exemplos de opera\u00e7\u00e3o com vetores: p <= \"100\" p recebe o valor em bin\u00e1rio 100 p <= not \"100\" p recebe o valor em bin\u00e1rio 011 p <= b(2 downto 0); p recebe os tr\u00eas primeiros bits de b p(0) <= a; p bit 0 recebe o valor da entrada a q <= not b(1); a sa\u00edda bin\u00e1ria q recebe o bit 1 da entrada b negado. Tip \u00c9 comum confundir quando usar aspas simples '' e aspas dupla \"\" , fique atento aos erros de compila\u00e7\u00e3o.","title":"Opera\u00e7\u00e3o com vetores"},{"location":"VHDL-basico/#signal","text":"Sinais s\u00e3o declarados entre a palavra reservada architecture e o begin e servem para facilitar/ possibilitar o desenvolvimento de um sistema digital, eles s\u00f3 s\u00e3o vis\u00edveis dentro de uma entidade e servem como 'fios' internos de um m\u00f3dulo. Sinais s\u00e3o diferente de portas n\u00e3o possuem dire\u00e7\u00e3o, e s\u00e3o declarados da seguinte maneira: signal NAME : TYPE TYPE pode ser: std_logic / std_logic_vector , entre outros. Exemplo: architecture rtl of TopLevel is -- Declara\u00e7\u00e3o de sinais signal aux1 : std_logic ; signal aux2 : std_logic_vector ( 1 downto 0 ); -- inicio da implementa\u00e7\u00e3o begin -------------------- aux1 <= not a ; q <= aux1 ; p ( 0 ) <= aux1 ; -------------------- aux2 <= b ( 3 downto 2 ); p ( 2 downto 1 ) <= aux2 ; end rtl ; No exemplo anterior, criamos um sinal auxiliar chamado de aux1 que recebe a entrada a negada, esse sinal \u00e9 ent\u00e3o atribu\u00eddo a sa\u00edda q e ao bit 0 da sa\u00edda p . Outro sinal aux2 , vetor de 2 bits recebe os dois bits mais significativos da entrada b e ent\u00e3o \u00e9 atribu\u00eddo a sa\u00edda p , bits 2 e 1.","title":"signal"},{"location":"VHDL-exemplos/","text":"Exemplos completos \u00b6 http://esd.cs.ucr.edu/labs/tutorial/ https://www.intel.com/content/www/us/en/programmable/support/support-resources/design-examples/design-software/vhdl.html http://ftp.smart-dv.com/examples/vhdl/index.html Combinacional \u00b6 END \u00b6 library ieee ; use ieee.std_logic_1164. all ; -------------------------------------------------- entity AND_ent is port ( x : in std_logic ; y : in std_logic ; F : out std_logic ); end AND_ent ; -------------------------------------------------- architecture behav2 of AND_ent is begin F <= x and y ; end behav2 ; Exemplo extra\u00eddo de: http://esd.cs.ucr.edu/labs/tutorial/ mux \u00b6 ------------------------------------------------------- -- Design Name : mux_using_when -- File Name : mux_using_assign.v -- Function : 2:1 Mux using when -- Coder : Deepak Kumar Tala ------------------------------------------------------- library ieee ; use ieee.std_logic_1164. all ; entity mux_using_when is port ( din_0 : in std_logic ; -- Mux first input din_1 : in std_logic ; -- Mux Second input sel : in std_logic ; -- Select input mux_out : out std_logic -- Mux output ); end entity ; architecture behavior of mux_using_when is begin mux_out <= din_0 when ( sel = '0' ) else din_1 ; end architecture ; ou ------------------------------------------------------- -- Design Name : mux_using_when -- File Name : mux_using_assign.v -- Function : 2:1 Mux using when -- Coder : Deepak Kumar Tala ------------------------------------------------------- library ieee ; use ieee.std_logic_1164. all ; entity mux_using_when is port ( din_0 : in std_logic ; -- Mux first input din_1 : in std_logic ; -- Mux Second input sel : in std_logic ; -- Select input mux_out : out std_logic -- Mux output ); end entity ; architecture behavior of mux_using_when is begin mux_out <= din_0 when ( sel = '0' ) else din_1 ; end architecture ; Exemplo extra\u00eddo de: http://ftp.smart-dv.com/examples/vhdl/mux.html demux \u00b6 Sa\u00edda sendo 4 sinais independentes: library ieee ; use ieee.std_logic_1164. all ; entity demux is port ( din : in std_logic ; -- Mux first input sel : in std_logic_vector ( 1 downto 0 ); -- Select output dout_0 : out std_logic ; -- demux first out dout_1 : out std_logic ; -- demux second out dout_2 : out std_logic ; -- demux ... dout_3 : out std_logic -- demux ... ); end entity ; architecture behavior of mux_using_when is begin dout_0 <= din when sel = \"00\" else '0' ; dout_1 <= din when sel = \"01\" else '0' ; dout_2 <= din when sel = \"10\" else '0' ; dout_3 <= din when sel = \"11\" else '0' ; end architecture ; Sa\u00edda sendo um vetor: library ieee ; use ieee.std_logic_1164. all ; entity demux is port ( din : in std_logic ; -- Mux first input sel : in std_logic_vector ( 1 downto 0 ); -- Select output dout : out std_logic_vector ( 3 downto 0 ) -- demux out vector ); end entity ; architecture behavior of mux_using_when is begin dout ( 0 ) <= din when sel = \"00\" else '0' ; dout ( 1 ) <= din when sel = \"01\" else '0' ; dout ( 2 ) <= din when sel = \"10\" else '0' ; dout ( 3 ) <= din when sel = \"11\" else '0' ; end architecture ; Enconder \u00b6 ------------------------------------------------------- -- Design Name : pri_encoder_using_when -- File Name : pri_encoder_using_when.vhd -- Function : Pri Encoder using when-else -- Coder : Deepak Kumar Tala (Verilog) -- Translator : Alexander H Pham (VHDL) -- Fixed : Tomasz Olszewski ------------------------------------------------------- library ieee ; use ieee.std_logic_1164. all ; entity pri_encoder_using_when is port ( enable : in std_logic ; -- Enable for the encoder encoder_in : in std_logic_vector ( 15 downto 0 ); -- 16-bit Input binary_out : out std_logic_vector ( 3 downto 0 ) -- 4 bit binary Output ); end entity ; architecture behavior of pri_encoder_using_when is begin binary_out <= \"0000\" when enable = '0' else \"0001\" when encoder_in ( 1 ) = '1' else \"0010\" when encoder_in ( 2 ) = '1' else \"0011\" when encoder_in ( 3 ) = '1' else \"0100\" when encoder_in ( 4 ) = '1' else \"0101\" when encoder_in ( 5 ) = '1' else \"0110\" when encoder_in ( 6 ) = '1' else \"0111\" when encoder_in ( 7 ) = '1' else \"1000\" when encoder_in ( 8 ) = '1' else \"1001\" when encoder_in ( 9 ) = '1' else \"1010\" when encoder_in ( 10 ) = '1' else \"1011\" when encoder_in ( 11 ) = '1' else \"1100\" when encoder_in ( 12 ) = '1' else \"1101\" when encoder_in ( 13 ) = '1' else \"1110\" when encoder_in ( 14 ) = '1' else \"1111\" when encoder_in ( 15 ) = '1' else \"0000\" ; end architecture ; Exemplo extra\u00eddo de: http://ftp.smart-dv.com/examples/vhdl/pri_encoder.html#Encoder_-_Using_when_Statement Paridade \u00b6 ------------------------------------------------------- -- Design Name : parity_using_assign -- File Name : parity_using_assign.vhd -- Function : Parity using direct assignment -- Coder : Deepak Kumar Tala (Verilog) -- Translator : Alexander H Pham (VHDL) ------------------------------------------------------- library ieee ; use ieee.std_logic_1164. all ; entity parity_using_assign is port ( data_in : in std_logic_vector ( 7 downto 0 ); parity_out : out std_logic ); end entity ; architecture rtl of parity_using_assign is begin parity_out <= ( data_in ( 0 ) xor data_in ( 1 )) xor ( data_in ( 2 ) xor data_in ( 3 )) xor ( data_in ( 4 ) xor data_in ( 5 )) xor ( data_in ( 6 ) xor data_in ( 7 )); end architecture ; Exemplo estra\u00eddo de: http://ftp.smart-dv.com/examples/vhdl/parity.html#Using_Assign","title":"Exemplos completos"},{"location":"VHDL-exemplos/#exemplos-completos","text":"http://esd.cs.ucr.edu/labs/tutorial/ https://www.intel.com/content/www/us/en/programmable/support/support-resources/design-examples/design-software/vhdl.html http://ftp.smart-dv.com/examples/vhdl/index.html","title":"Exemplos completos"},{"location":"VHDL-exemplos/#combinacional","text":"","title":"Combinacional"},{"location":"VHDL-exemplos/#end","text":"library ieee ; use ieee.std_logic_1164. all ; -------------------------------------------------- entity AND_ent is port ( x : in std_logic ; y : in std_logic ; F : out std_logic ); end AND_ent ; -------------------------------------------------- architecture behav2 of AND_ent is begin F <= x and y ; end behav2 ; Exemplo extra\u00eddo de: http://esd.cs.ucr.edu/labs/tutorial/","title":"END"},{"location":"VHDL-exemplos/#mux","text":"------------------------------------------------------- -- Design Name : mux_using_when -- File Name : mux_using_assign.v -- Function : 2:1 Mux using when -- Coder : Deepak Kumar Tala ------------------------------------------------------- library ieee ; use ieee.std_logic_1164. all ; entity mux_using_when is port ( din_0 : in std_logic ; -- Mux first input din_1 : in std_logic ; -- Mux Second input sel : in std_logic ; -- Select input mux_out : out std_logic -- Mux output ); end entity ; architecture behavior of mux_using_when is begin mux_out <= din_0 when ( sel = '0' ) else din_1 ; end architecture ; ou ------------------------------------------------------- -- Design Name : mux_using_when -- File Name : mux_using_assign.v -- Function : 2:1 Mux using when -- Coder : Deepak Kumar Tala ------------------------------------------------------- library ieee ; use ieee.std_logic_1164. all ; entity mux_using_when is port ( din_0 : in std_logic ; -- Mux first input din_1 : in std_logic ; -- Mux Second input sel : in std_logic ; -- Select input mux_out : out std_logic -- Mux output ); end entity ; architecture behavior of mux_using_when is begin mux_out <= din_0 when ( sel = '0' ) else din_1 ; end architecture ; Exemplo extra\u00eddo de: http://ftp.smart-dv.com/examples/vhdl/mux.html","title":"mux"},{"location":"VHDL-exemplos/#demux","text":"Sa\u00edda sendo 4 sinais independentes: library ieee ; use ieee.std_logic_1164. all ; entity demux is port ( din : in std_logic ; -- Mux first input sel : in std_logic_vector ( 1 downto 0 ); -- Select output dout_0 : out std_logic ; -- demux first out dout_1 : out std_logic ; -- demux second out dout_2 : out std_logic ; -- demux ... dout_3 : out std_logic -- demux ... ); end entity ; architecture behavior of mux_using_when is begin dout_0 <= din when sel = \"00\" else '0' ; dout_1 <= din when sel = \"01\" else '0' ; dout_2 <= din when sel = \"10\" else '0' ; dout_3 <= din when sel = \"11\" else '0' ; end architecture ; Sa\u00edda sendo um vetor: library ieee ; use ieee.std_logic_1164. all ; entity demux is port ( din : in std_logic ; -- Mux first input sel : in std_logic_vector ( 1 downto 0 ); -- Select output dout : out std_logic_vector ( 3 downto 0 ) -- demux out vector ); end entity ; architecture behavior of mux_using_when is begin dout ( 0 ) <= din when sel = \"00\" else '0' ; dout ( 1 ) <= din when sel = \"01\" else '0' ; dout ( 2 ) <= din when sel = \"10\" else '0' ; dout ( 3 ) <= din when sel = \"11\" else '0' ; end architecture ;","title":"demux"},{"location":"VHDL-exemplos/#enconder","text":"------------------------------------------------------- -- Design Name : pri_encoder_using_when -- File Name : pri_encoder_using_when.vhd -- Function : Pri Encoder using when-else -- Coder : Deepak Kumar Tala (Verilog) -- Translator : Alexander H Pham (VHDL) -- Fixed : Tomasz Olszewski ------------------------------------------------------- library ieee ; use ieee.std_logic_1164. all ; entity pri_encoder_using_when is port ( enable : in std_logic ; -- Enable for the encoder encoder_in : in std_logic_vector ( 15 downto 0 ); -- 16-bit Input binary_out : out std_logic_vector ( 3 downto 0 ) -- 4 bit binary Output ); end entity ; architecture behavior of pri_encoder_using_when is begin binary_out <= \"0000\" when enable = '0' else \"0001\" when encoder_in ( 1 ) = '1' else \"0010\" when encoder_in ( 2 ) = '1' else \"0011\" when encoder_in ( 3 ) = '1' else \"0100\" when encoder_in ( 4 ) = '1' else \"0101\" when encoder_in ( 5 ) = '1' else \"0110\" when encoder_in ( 6 ) = '1' else \"0111\" when encoder_in ( 7 ) = '1' else \"1000\" when encoder_in ( 8 ) = '1' else \"1001\" when encoder_in ( 9 ) = '1' else \"1010\" when encoder_in ( 10 ) = '1' else \"1011\" when encoder_in ( 11 ) = '1' else \"1100\" when encoder_in ( 12 ) = '1' else \"1101\" when encoder_in ( 13 ) = '1' else \"1110\" when encoder_in ( 14 ) = '1' else \"1111\" when encoder_in ( 15 ) = '1' else \"0000\" ; end architecture ; Exemplo extra\u00eddo de: http://ftp.smart-dv.com/examples/vhdl/pri_encoder.html#Encoder_-_Using_when_Statement","title":"Enconder"},{"location":"VHDL-exemplos/#paridade","text":"------------------------------------------------------- -- Design Name : parity_using_assign -- File Name : parity_using_assign.vhd -- Function : Parity using direct assignment -- Coder : Deepak Kumar Tala (Verilog) -- Translator : Alexander H Pham (VHDL) ------------------------------------------------------- library ieee ; use ieee.std_logic_1164. all ; entity parity_using_assign is port ( data_in : in std_logic_vector ( 7 downto 0 ); parity_out : out std_logic ); end entity ; architecture rtl of parity_using_assign is begin parity_out <= ( data_in ( 0 ) xor data_in ( 1 )) xor ( data_in ( 2 ) xor data_in ( 3 )) xor ( data_in ( 4 ) xor data_in ( 5 )) xor ( data_in ( 6 ) xor data_in ( 7 )); end architecture ; Exemplo estra\u00eddo de: http://ftp.smart-dv.com/examples/vhdl/parity.html#Using_Assign","title":"Paridade"},{"location":"VHDL-port-map/","text":"port map \u00b6 Desenvolvimento hier\u00e1rquico \u00b6 \u00c9 uma t\u00e9cnica de organiza\u00e7\u00e3o de projeto onde s\u00e3o desenvolvidos pequenos m\u00f3dulos e esses m\u00f3dulos fazem parte de um sistema maior, que por sua vez, fazem parte de algo muito mais complexo. As vantagens de um desenvolvimento desse tipo s\u00e3o: Facilidade em realizar testes e valida\u00e7\u00e3o Cada m\u00f3dulo \u00e9 testado independentemente Trabalho em equipe A partir do momento que as interfaces s\u00e3o bem estabelecidas, cada um do time pode desenvolver um m\u00f3dulo Ferramentas gostam / se adaptam bem As ferramentas de desenvolvimento conseguem otimizar o hardware melhor Reaproveitamento de m\u00f3dulos Muito mais f\u00e1cil para reaproveitar outros m\u00f3dulos. Leitura extra https://www.intel.com/content/www/us/en/programmable/support/support-resources/design-examples/design-software/vhdl/v_hier.html Fonte: https://www.embedded.com/the-art-of-fpga-construction/ port map \u00b6 port map \u00e9 a maneira em VHDL de reaproveitamos uma entidade definida em outro lugar no nosso arquivo. Pensar em port map como uma fun\u00e7\u00e3o n\u00e3o \u00e9 de todo errado, mas devesse notar que quando usamos port map estamos criando uma c\u00f3pia do hardware que \u00e9 descrito pela entidade usada, isso \u00e9 diferente de uma fun\u00e7\u00e3o em Python, que reaproveita o mesmo trecho de c\u00f3digo para cada chamada de fun\u00e7\u00e3o. \u00c9 mais apropriado pensar que a descri\u00e7\u00e3o de um hardware \u00e9 uma receita (que vemos na architecture ), o port map seria como o bolo, voc\u00ea pode ter v\u00e1rios bolos com a mesma receita e cada bolo pode ser usado/ir para pessoa diferente (entrada e sa\u00eddas). Vamos ver como usar port map com um exemplo a seguir, nesse exemplo possu\u00edmos dois arquivos modulo2.vhd e modulo1.vhd , e desejamos utilizar o modulo1 dentro do componente 2 (modulo2): ------------------- i1 | -------- | o1 -->|--->| modulo1|-----|--> i2 | -->| | | -->|/ -------- | | modulo2 | ------------------- modulo1.vhd entity modulo1 is port ( a , b : in std_logic ; x : out std_logic ); end entity ; architecture rtl OF modulo1 IS begin x <= a xor b ; end architecture ; modulo2.vhd entity modulo2 is port ( i1 , i2 : in std_logic ; o1 : out std_logic ); end entity ; architecture rtl OF modulo2 IS -- Aqui devemos fazer a declara\u00e7\u00e3o do componente -- que queremos utilizar, a declara\u00e7\u00e3o -- tem que ser igual a entidade do componente -- original, mas trocando a palavra `entity` -- pelo keyword `component` component modulo1 is port ( a , b : in std_logic ; x : out std_logic ); end component ; begin -- Agora com o componente 'criado' -- podemos utilizar no nosso projeto -- -- podemos dar um 'nome' a intancia do componente -- | -- | | nome do componente a ser usado -- v v u1 : modulo1 port map ( a => i1 , -- o sinal a do componente \u00e9 conectado no sinal i1 b => i2 , -- o sinal a do componente \u00e9 conectado no sinal i1 x => o1 -- o sinal a do componente \u00e9 conectado no sinal i1 ); end architecture ; Tip O nome da inst\u00e2ncia n\u00e3o pode repetir ( u1 , ...) Podemos instanciar a quantidade de componente que desejarmos (vai depender do tamanho da FPGA) Nenhuma porta de entrada pode ficar vazia! Voc\u00ea n\u00e3o precisa ligar todas sa\u00eddas. Para deixar uma sa\u00edda desconectada utilize o keyword OPEN : vhdl u1: modulo1 port map( a => OPEN, N\u00e3o podemos aplicar opera\u00e7\u00f5es no port map : vhdl u1: modulo1 port map( a => i1 and i2, Evitar a nota\u00e7\u00e3o de port map que n\u00e3o indica qual porta vai para onde: u1 : modulo1 port map ( i1 , i2 , o1 ); As vezes \u00e9 necess\u00e1rio criarmos sinais ( signals ) para atribuirmos aos componentes ``` Video-Exemplo: Construindo um Adder de 4-bits usando FullAdder de 1-bit \u00b6 Vers\u00e3o Texto - Exemplo: Construindo um Adder de 4-bits usando FullAdder de 1-bit \u00b6 Neste exemplo vamos ver a elabora\u00e7\u00e3o de um somador ( adder ) de 4-bits atr\u00e1ves do uso de v\u00e1rios somadores de 1-bit. Suponha que voc\u00ea j\u00e1 tenha um somador pronto por\u00e9m o mesmo \u00e9 apenas de 1-bit, criar um somador de 4-bits do zero, pode ser uma tarefa trabalhosa, elaborar uma tabela verdade de 2^4 = 16 linhas, econtrar 4 sa\u00eddas distintas (cada bit de sa\u00edda), enfim... ser\u00e1 que n\u00e3o \u00e9 poss\u00edvel usar o conceito que vimos de port-map anteriormente e multiplos somadores para obter o desejado? Sim, \u00e9 poss\u00edvel, desde que nosso somador de 1-bit seja um Full-Adder, lembre-se que a principal diferen\u00e7a de um Full-Adder e um Half-Adder, \u00e9 a presen\u00e7a de uma entrada de Carry In, que permite que a liga\u00e7\u00e3o em cascata de v\u00e1rios somadores. Portanto, o nosso somador de 4-bits, nada mais ser\u00e1 que uma caixa preta que dentro ter\u00e1 4 somadores de 1-bit realizando o trabalho, para o usu\u00e1rio final, que ir\u00e1 utilizar o componente isto ficar\u00e1 transparente e o mesmo n\u00e3o saber\u00e1 deste detalhe. Vamos criar nosso componente Somador de 4-bits, Adder.vhdl e definir suas entradas e sa\u00eddas (4-bits). entity Adder is port ( X : in std_logic_vector ( 3 downto 0 ); Y : in std_logic_vector ( 3 downto 0 ); Z : out std_logic_vector ( 3 downto 0 ) ); end Adder ; architecture archAdder of Adder is begin end archAdder ; Agora suponha que temos o arquivo de nosso FullAdder de 1-bit, FullAdder1.vhdl e que tenha a defini\u00e7\u00e3o (entidade da seguinte forma): entity FullAdder1 is port ( X : in std_logic ; Y : in std_logic ; Cin : in std_logic ; Z : out std_logic ; Cout : out std_logic ); end FullAdder1 ; Observe que n\u00f3s preocupamos apenas em ver a entidade (onde existem as entradas e sa\u00eddas). Quer dizer que agora podemos usar a entidade FullAdder1 diretamente no Adder ? N\u00e3o ainda! O componente Adder n\u00e3o conhece nenhum FullAdder1 ! para poder usar. Por isto devemos declarar na arquitetura do Adder que existe um componente com este nome e com tais entradas e sa\u00eddas dispon\u00edveis para uso! Para isso usamos a declara\u00e7\u00e3o component do VHDL, permitindo especificar os nomes e entradas. architecture archAdder of Adder is component FullAdder1 port ( -- Input ports X : in std_logic ; Y : in std_logic ; Cin : in std_logic ; -- Output ports Z : out std_logic ; Cout : out std_logic ); end component ; begin end archAdder ; Pronto! Agora podemos usar o componente FullAdder1 , na verdade, podemos usar v\u00e1rios! Isso mesmo, podemos criar v\u00e1rias inst\u00e2ncias deste FullAdder1 , vamos precisar de 4. A forma de fazer isto em VHDL, \u00e9 usar definir um nome de instancia, nome do componente e suas liga\u00e7\u00f5es (port-map). Sintaxe: < instance_name > : < component_name > port map ( < formal_input > => < signal > , < formal_output > => < signal > ); Exemplo para os nosso 4 FAs (por enquanto vamos ligar apenas as entradas X, Y e sa\u00eddas Z sem se preocupar com os Cin/Cout). A0 : FullAdder1 port map ( X => X ( 0 ), Y => Y ( 0 ), Z => Z ( 0 ) ); A1 : FullAdder1 port map ( X => X ( 1 ), Y => Y ( 1 ), Z => Z ( 1 ) ); A2 : FullAdder1 port map ( X => X ( 2 ), Y => Y ( 2 ), Z => Z ( 2 ) ); A3 : FullAdder1 port map ( X => X ( 3 ), Y => Y ( 3 ), Z => Z ( 3 ) ); Observe que conseguimos facilmente instanciar 4 somadores de 1-bit! Outro detalhe importante no port-map \u00e9 que sempre o sinal a esquerda pertence ao componente e este \u00e9 conectado ao sinal da direita (pertence ao arquivo atual). Por isto podemos ligar X a X(0), sem dar erro de nome duplicado, pois o VHDL \u00e9 espertinho e sabe que o primeiro X se refere ao X do componente e o segundo, ao do nosso Adder de 4-bits. Agora precisamos ligar os Carrys para que nosso somador some corretamente, lembre, o primeiro somador (bit 0), ter\u00e1 carry de entrada (Cin) zero (0), e os demais somadores receberam o carry de sa\u00edda (Cout) do somador anterior. No entanto no VHDL n\u00e3o \u00e9 poss\u00edvel ligar diretamente entre componentes diferentes!! E agora? Existem no VHDL, sinais virtuais, literalmente chamados signals , podemos pensar nestes sinais como um fio , cuidado, eles n\u00e3o s\u00e3o variav\u00e9is (o VHDL possui elas, por\u00e9m tem algumas pecularidades diferentes que n\u00e3o iremos abordar aqui) Os sinais devem serem declarados dentro de um arquitetura com a seguinte sintaxe signal < name > : < type > ; Como teremos 4 carrys de sa\u00edda, podemos usar ent\u00e3o signal carry : std_logic_vector ( 3 downto 0 ); Agora basta ligar o carry dos somadores intermediarios e o final, no anterior (n\u00e3o esquece de ligar o carry de entrada e sa\u00edda). Exemplo dos dois primeiros somadores. A0 : FullAdder1 port map ( X => X ( 0 ), Y => Y ( 0 ), Cin => '0' , Z => Z ( 0 ), Cout => carry ( 0 ) ); A1 : FullAdder1 port map ( X => X ( 1 ), Y => Y ( 1 ), Cin => carry ( 0 ), Z => Z ( 1 ), Cout => carry ( 1 ) ); ... Feito isto, seu somador est\u00e1 completo, basta utiliza-lo em um TopLevel ou outro VHDL que desejar para ver os resultados!","title":"port map"},{"location":"VHDL-port-map/#port-map","text":"","title":"port map"},{"location":"VHDL-port-map/#desenvolvimento-hierarquico","text":"\u00c9 uma t\u00e9cnica de organiza\u00e7\u00e3o de projeto onde s\u00e3o desenvolvidos pequenos m\u00f3dulos e esses m\u00f3dulos fazem parte de um sistema maior, que por sua vez, fazem parte de algo muito mais complexo. As vantagens de um desenvolvimento desse tipo s\u00e3o: Facilidade em realizar testes e valida\u00e7\u00e3o Cada m\u00f3dulo \u00e9 testado independentemente Trabalho em equipe A partir do momento que as interfaces s\u00e3o bem estabelecidas, cada um do time pode desenvolver um m\u00f3dulo Ferramentas gostam / se adaptam bem As ferramentas de desenvolvimento conseguem otimizar o hardware melhor Reaproveitamento de m\u00f3dulos Muito mais f\u00e1cil para reaproveitar outros m\u00f3dulos. Leitura extra https://www.intel.com/content/www/us/en/programmable/support/support-resources/design-examples/design-software/vhdl/v_hier.html Fonte: https://www.embedded.com/the-art-of-fpga-construction/","title":"Desenvolvimento hier\u00e1rquico"},{"location":"VHDL-port-map/#port-map_1","text":"port map \u00e9 a maneira em VHDL de reaproveitamos uma entidade definida em outro lugar no nosso arquivo. Pensar em port map como uma fun\u00e7\u00e3o n\u00e3o \u00e9 de todo errado, mas devesse notar que quando usamos port map estamos criando uma c\u00f3pia do hardware que \u00e9 descrito pela entidade usada, isso \u00e9 diferente de uma fun\u00e7\u00e3o em Python, que reaproveita o mesmo trecho de c\u00f3digo para cada chamada de fun\u00e7\u00e3o. \u00c9 mais apropriado pensar que a descri\u00e7\u00e3o de um hardware \u00e9 uma receita (que vemos na architecture ), o port map seria como o bolo, voc\u00ea pode ter v\u00e1rios bolos com a mesma receita e cada bolo pode ser usado/ir para pessoa diferente (entrada e sa\u00eddas). Vamos ver como usar port map com um exemplo a seguir, nesse exemplo possu\u00edmos dois arquivos modulo2.vhd e modulo1.vhd , e desejamos utilizar o modulo1 dentro do componente 2 (modulo2): ------------------- i1 | -------- | o1 -->|--->| modulo1|-----|--> i2 | -->| | | -->|/ -------- | | modulo2 | ------------------- modulo1.vhd entity modulo1 is port ( a , b : in std_logic ; x : out std_logic ); end entity ; architecture rtl OF modulo1 IS begin x <= a xor b ; end architecture ; modulo2.vhd entity modulo2 is port ( i1 , i2 : in std_logic ; o1 : out std_logic ); end entity ; architecture rtl OF modulo2 IS -- Aqui devemos fazer a declara\u00e7\u00e3o do componente -- que queremos utilizar, a declara\u00e7\u00e3o -- tem que ser igual a entidade do componente -- original, mas trocando a palavra `entity` -- pelo keyword `component` component modulo1 is port ( a , b : in std_logic ; x : out std_logic ); end component ; begin -- Agora com o componente 'criado' -- podemos utilizar no nosso projeto -- -- podemos dar um 'nome' a intancia do componente -- | -- | | nome do componente a ser usado -- v v u1 : modulo1 port map ( a => i1 , -- o sinal a do componente \u00e9 conectado no sinal i1 b => i2 , -- o sinal a do componente \u00e9 conectado no sinal i1 x => o1 -- o sinal a do componente \u00e9 conectado no sinal i1 ); end architecture ; Tip O nome da inst\u00e2ncia n\u00e3o pode repetir ( u1 , ...) Podemos instanciar a quantidade de componente que desejarmos (vai depender do tamanho da FPGA) Nenhuma porta de entrada pode ficar vazia! Voc\u00ea n\u00e3o precisa ligar todas sa\u00eddas. Para deixar uma sa\u00edda desconectada utilize o keyword OPEN : vhdl u1: modulo1 port map( a => OPEN, N\u00e3o podemos aplicar opera\u00e7\u00f5es no port map : vhdl u1: modulo1 port map( a => i1 and i2, Evitar a nota\u00e7\u00e3o de port map que n\u00e3o indica qual porta vai para onde: u1 : modulo1 port map ( i1 , i2 , o1 ); As vezes \u00e9 necess\u00e1rio criarmos sinais ( signals ) para atribuirmos aos componentes ```","title":"port map"},{"location":"VHDL-port-map/#video-exemplo-construindo-um-adder-de-4-bits-usando-fulladder-de-1-bit","text":"","title":"Video-Exemplo: Construindo um Adder de 4-bits usando FullAdder de 1-bit"},{"location":"VHDL-port-map/#versao-texto-exemplo-construindo-um-adder-de-4-bits-usando-fulladder-de-1-bit","text":"Neste exemplo vamos ver a elabora\u00e7\u00e3o de um somador ( adder ) de 4-bits atr\u00e1ves do uso de v\u00e1rios somadores de 1-bit. Suponha que voc\u00ea j\u00e1 tenha um somador pronto por\u00e9m o mesmo \u00e9 apenas de 1-bit, criar um somador de 4-bits do zero, pode ser uma tarefa trabalhosa, elaborar uma tabela verdade de 2^4 = 16 linhas, econtrar 4 sa\u00eddas distintas (cada bit de sa\u00edda), enfim... ser\u00e1 que n\u00e3o \u00e9 poss\u00edvel usar o conceito que vimos de port-map anteriormente e multiplos somadores para obter o desejado? Sim, \u00e9 poss\u00edvel, desde que nosso somador de 1-bit seja um Full-Adder, lembre-se que a principal diferen\u00e7a de um Full-Adder e um Half-Adder, \u00e9 a presen\u00e7a de uma entrada de Carry In, que permite que a liga\u00e7\u00e3o em cascata de v\u00e1rios somadores. Portanto, o nosso somador de 4-bits, nada mais ser\u00e1 que uma caixa preta que dentro ter\u00e1 4 somadores de 1-bit realizando o trabalho, para o usu\u00e1rio final, que ir\u00e1 utilizar o componente isto ficar\u00e1 transparente e o mesmo n\u00e3o saber\u00e1 deste detalhe. Vamos criar nosso componente Somador de 4-bits, Adder.vhdl e definir suas entradas e sa\u00eddas (4-bits). entity Adder is port ( X : in std_logic_vector ( 3 downto 0 ); Y : in std_logic_vector ( 3 downto 0 ); Z : out std_logic_vector ( 3 downto 0 ) ); end Adder ; architecture archAdder of Adder is begin end archAdder ; Agora suponha que temos o arquivo de nosso FullAdder de 1-bit, FullAdder1.vhdl e que tenha a defini\u00e7\u00e3o (entidade da seguinte forma): entity FullAdder1 is port ( X : in std_logic ; Y : in std_logic ; Cin : in std_logic ; Z : out std_logic ; Cout : out std_logic ); end FullAdder1 ; Observe que n\u00f3s preocupamos apenas em ver a entidade (onde existem as entradas e sa\u00eddas). Quer dizer que agora podemos usar a entidade FullAdder1 diretamente no Adder ? N\u00e3o ainda! O componente Adder n\u00e3o conhece nenhum FullAdder1 ! para poder usar. Por isto devemos declarar na arquitetura do Adder que existe um componente com este nome e com tais entradas e sa\u00eddas dispon\u00edveis para uso! Para isso usamos a declara\u00e7\u00e3o component do VHDL, permitindo especificar os nomes e entradas. architecture archAdder of Adder is component FullAdder1 port ( -- Input ports X : in std_logic ; Y : in std_logic ; Cin : in std_logic ; -- Output ports Z : out std_logic ; Cout : out std_logic ); end component ; begin end archAdder ; Pronto! Agora podemos usar o componente FullAdder1 , na verdade, podemos usar v\u00e1rios! Isso mesmo, podemos criar v\u00e1rias inst\u00e2ncias deste FullAdder1 , vamos precisar de 4. A forma de fazer isto em VHDL, \u00e9 usar definir um nome de instancia, nome do componente e suas liga\u00e7\u00f5es (port-map). Sintaxe: < instance_name > : < component_name > port map ( < formal_input > => < signal > , < formal_output > => < signal > ); Exemplo para os nosso 4 FAs (por enquanto vamos ligar apenas as entradas X, Y e sa\u00eddas Z sem se preocupar com os Cin/Cout). A0 : FullAdder1 port map ( X => X ( 0 ), Y => Y ( 0 ), Z => Z ( 0 ) ); A1 : FullAdder1 port map ( X => X ( 1 ), Y => Y ( 1 ), Z => Z ( 1 ) ); A2 : FullAdder1 port map ( X => X ( 2 ), Y => Y ( 2 ), Z => Z ( 2 ) ); A3 : FullAdder1 port map ( X => X ( 3 ), Y => Y ( 3 ), Z => Z ( 3 ) ); Observe que conseguimos facilmente instanciar 4 somadores de 1-bit! Outro detalhe importante no port-map \u00e9 que sempre o sinal a esquerda pertence ao componente e este \u00e9 conectado ao sinal da direita (pertence ao arquivo atual). Por isto podemos ligar X a X(0), sem dar erro de nome duplicado, pois o VHDL \u00e9 espertinho e sabe que o primeiro X se refere ao X do componente e o segundo, ao do nosso Adder de 4-bits. Agora precisamos ligar os Carrys para que nosso somador some corretamente, lembre, o primeiro somador (bit 0), ter\u00e1 carry de entrada (Cin) zero (0), e os demais somadores receberam o carry de sa\u00edda (Cout) do somador anterior. No entanto no VHDL n\u00e3o \u00e9 poss\u00edvel ligar diretamente entre componentes diferentes!! E agora? Existem no VHDL, sinais virtuais, literalmente chamados signals , podemos pensar nestes sinais como um fio , cuidado, eles n\u00e3o s\u00e3o variav\u00e9is (o VHDL possui elas, por\u00e9m tem algumas pecularidades diferentes que n\u00e3o iremos abordar aqui) Os sinais devem serem declarados dentro de um arquitetura com a seguinte sintaxe signal < name > : < type > ; Como teremos 4 carrys de sa\u00edda, podemos usar ent\u00e3o signal carry : std_logic_vector ( 3 downto 0 ); Agora basta ligar o carry dos somadores intermediarios e o final, no anterior (n\u00e3o esquece de ligar o carry de entrada e sa\u00edda). Exemplo dos dois primeiros somadores. A0 : FullAdder1 port map ( X => X ( 0 ), Y => Y ( 0 ), Cin => '0' , Z => Z ( 0 ), Cout => carry ( 0 ) ); A1 : FullAdder1 port map ( X => X ( 1 ), Y => Y ( 1 ), Cin => carry ( 0 ), Z => Z ( 1 ), Cout => carry ( 1 ) ); ... Feito isto, seu somador est\u00e1 completo, basta utiliza-lo em um TopLevel ou outro VHDL que desejar para ver os resultados!","title":"Vers\u00e3o Texto - Exemplo: Construindo um Adder de 4-bits usando FullAdder de 1-bit"},{"location":"X-Processadores-Projeto/","text":"Mundo Real \u00b6 Entregar at\u00e9 o \u00faltimo dia de aula (antes da AF). Esse projeto extra optativo (individual) fornece 15 pontos extras de Hardware e 10 pontos extras de Software . Processadores \u00b6 Voc\u00ea dever\u00e1 escolher um dos processadores listados a seguir ARM Cortex M0 RISC V SPARC V8 AVR Microchip PIC N\u00e3o pode repetir dentro do grupo! N\u00e3o pode ser o mesmo de 2019-1 ( 10 HW e 5 SW ) Estudo \u00b6 E entregar um documento com os itens a seguir: ( 2 HW ) Hist\u00f3rico Hist\u00f3ria da arquitetura Pessoas/ empresas respons\u00e1veis, Impacto hist\u00f3rico, impacto nos concorrentes/ comunidade/ Curiosidades ( 2 HW ) Uso atual Dispositivos e empresas que ainda fazem uso da arquitetura. ( 6 HW ) Arquitetura Descreva a arquitetura interna da CPU Quantidade de registradores Opera\u00e7\u00f5es da ULA Program Cunter (PC) Como \u00e9 realizado o acesso a mem\u00f3ria nessa arquitetura Especificidades Compara\u00e7\u00e3o com o Z01.1 ( 5 SW ) Instru\u00e7\u00f5es Descritivo das instru\u00e7\u00f5es e seus padr\u00f5es Quantidade total de instru\u00e7\u00f5es Diferen\u00e7a com rela\u00e7\u00e3o ao Z01.1 A entrega dever\u00e1 ser feita em PDF com entorno de 4 p\u00e1ginas, al\u00e9m do** documento, uma apresenta\u00e7\u00e3o de 5 minutos dever\u00e1 ser feito para seu professor/colegas de sala (iremos marcar). ( 5 HW / 5 SW ) C\u00f3digo exemplo \u00b6 Desenvolva um programa em assembly que realiza a multiplica\u00e7\u00e3o entre os valores 10 e 15. Dica A maioria dos processadores possuem um simulador online, busque na internet por isso, e desenvolva o programa no simulador.","title":"Mundo Real"},{"location":"X-Processadores-Projeto/#mundo-real","text":"Entregar at\u00e9 o \u00faltimo dia de aula (antes da AF). Esse projeto extra optativo (individual) fornece 15 pontos extras de Hardware e 10 pontos extras de Software .","title":"Mundo Real"},{"location":"X-Processadores-Projeto/#processadores","text":"Voc\u00ea dever\u00e1 escolher um dos processadores listados a seguir ARM Cortex M0 RISC V SPARC V8 AVR Microchip PIC N\u00e3o pode repetir dentro do grupo! N\u00e3o pode ser o mesmo de 2019-1","title":"Processadores"},{"location":"X-Processadores-Projeto/#10-hw-e-5-sw-estudo","text":"E entregar um documento com os itens a seguir: ( 2 HW ) Hist\u00f3rico Hist\u00f3ria da arquitetura Pessoas/ empresas respons\u00e1veis, Impacto hist\u00f3rico, impacto nos concorrentes/ comunidade/ Curiosidades ( 2 HW ) Uso atual Dispositivos e empresas que ainda fazem uso da arquitetura. ( 6 HW ) Arquitetura Descreva a arquitetura interna da CPU Quantidade de registradores Opera\u00e7\u00f5es da ULA Program Cunter (PC) Como \u00e9 realizado o acesso a mem\u00f3ria nessa arquitetura Especificidades Compara\u00e7\u00e3o com o Z01.1 ( 5 SW ) Instru\u00e7\u00f5es Descritivo das instru\u00e7\u00f5es e seus padr\u00f5es Quantidade total de instru\u00e7\u00f5es Diferen\u00e7a com rela\u00e7\u00e3o ao Z01.1 A entrega dever\u00e1 ser feita em PDF com entorno de 4 p\u00e1ginas, al\u00e9m do** documento, uma apresenta\u00e7\u00e3o de 5 minutos dever\u00e1 ser feito para seu professor/colegas de sala (iremos marcar).","title":"(10 HW e 5 SW) Estudo"},{"location":"X-Processadores-Projeto/#5-hw-5-sw-codigo-exemplo","text":"Desenvolva um programa em assembly que realiza a multiplica\u00e7\u00e3o entre os valores 10 e 15. Dica A maioria dos processadores possuem um simulador online, busque na internet por isso, e desenvolva o programa no simulador.","title":"(5 HW / 5 SW) C\u00f3digo exemplo"},{"location":"seq-Lab-1/","text":"Lab 10: D - L\u00f3gica Sequencial \u00b6 Antes de come\u00e7ar Toda vez que um novo projeto come\u00e7ar ser\u00e1 necess\u00e1rio realizar algumas configura\u00e7\u00f5es no reposit\u00f3rio do grupo, voc\u00eas devem seguir para o documento: Util/Come\u00e7ando novo Projeto e depois voltar para esse lab. N\u00e3o seguir sem realizar a etapa anterior. Nesse lab iremos implementar um flip-flop do tipo D e um binary digit. Estudo pr\u00e9vio necess\u00e1rio para realizar esse lab: Leitura Teoria/L\u00f3gica Sequencial VHDL/Sequencial Implementando um FF tipo D \u00b6 Note Fazer individual Discutir no grupo! Execute Fa\u00e7a uma branch Implemente local no seu PC S\u00f3 um integrante do grupo deve enviar para a master via PR ao final Tip Esse j\u00e1 \u00e9 um dos m\u00f3dulos da entrega do projeto! Vamos agora implementar um FF tipo D em VHDL, para isso iremos modificar o arquivo D-LogicaSequencial/src/rtl/FlipFlopD.vhd que declara a entidade de um Flip Flop do tipo D. Reset e Preset \u00b6 Warning Antes de continuar, voc\u00ea deve ter feito a leitura pr\u00e9via sobre L\u00f3gica Sequencial em VHDL, s\u00f3 continue ap\u00f3s ter realizado a leitura: No site da disciplina: VHDL Sequencial Flip Flops possuem normalmente dois outros sinais de controle: Clear e Preset , usados respectivamente para for\u00e7ar '0' ou '1' em sua sa\u00edda. Vamos modificar o c\u00f3digo anterior para suportar essas duas outras funcionalidades. Nesse caso possu\u00edmos duas op\u00e7\u00f5es: Set/Clear : s\u00edncrono Set/Clear : ass\u00edncrono O modo s\u00edncrono seria que o set e o clear s\u00f3 podem ser executado na subida do clock e no ass\u00edncrono em qualquer momento que o sinal se set e clear forem alterados o FF ir\u00e1 responder imediatamente. Nesse caso, iremos implementar o FF com set e reset ass\u00edncrono, para isso utilize a seguinte estrutura a seguir que j\u00e1 implementa o sinal de clear Iremos modificar o c\u00f3digo localizado em D-LogicaSequencial/src/rtl/FlipFlopD.vhd que possui a implementa\u00e7\u00e3o parcial de um FF tipo D, mas n\u00e3o tem o preset process ( clock , clear ) begin if ( clear = '1' ) then Q <= '0' ; elsif ( rising_edge ( clock )) then Q <= D ; end if ; end process ; Tarefa: FF completo D-LogicaSequencial/src/rtl/FlipFlopD.vhd Implemente o preset (o clear j\u00e1 est\u00e1 feito) Agora voc\u00ea pode executar o script de teste do projeto e verificar se a implementa\u00e7\u00e3o est\u00e1 correta. S\u00f3 continuar se estiver passando nos testes Tarefa: waveform execute ./testeLogicaSequencial -g analise a forma de onda do teste do FF no modelsim Tip Discuta no grupo a forma de onda Chame um professor para conversar sobre o entendimento de voc\u00eas Tarefa: RTL Gere o RTL (via quartus) analise o resultado do FF. Salve a forma de onda na pasta src/rtl/ do projeto com o nome FlipFlop.png . Checkpoint \u00b6 Ao final dessa etapa voc\u00ea deve ser capaz de: Saber o que \u00e9 um process em VHDL e o impacto da lista de sensibilidade Saber o que \u00e9 um FlipFlop tipo D Explicar a forma de onda do FlipFlopD gerada no modelsim Explicar o RTL do FlipFlopD criado pelo Quartus \u00b6","title":"Lab 10: D - L\u00f3gica Sequencial"},{"location":"seq-Lab-1/#lab-10-d-logica-sequencial","text":"Antes de come\u00e7ar Toda vez que um novo projeto come\u00e7ar ser\u00e1 necess\u00e1rio realizar algumas configura\u00e7\u00f5es no reposit\u00f3rio do grupo, voc\u00eas devem seguir para o documento: Util/Come\u00e7ando novo Projeto e depois voltar para esse lab. N\u00e3o seguir sem realizar a etapa anterior. Nesse lab iremos implementar um flip-flop do tipo D e um binary digit. Estudo pr\u00e9vio necess\u00e1rio para realizar esse lab: Leitura Teoria/L\u00f3gica Sequencial VHDL/Sequencial","title":"Lab 10: D - L\u00f3gica Sequencial"},{"location":"seq-Lab-1/#implementando-um-ff-tipo-d","text":"Note Fazer individual Discutir no grupo! Execute Fa\u00e7a uma branch Implemente local no seu PC S\u00f3 um integrante do grupo deve enviar para a master via PR ao final Tip Esse j\u00e1 \u00e9 um dos m\u00f3dulos da entrega do projeto! Vamos agora implementar um FF tipo D em VHDL, para isso iremos modificar o arquivo D-LogicaSequencial/src/rtl/FlipFlopD.vhd que declara a entidade de um Flip Flop do tipo D.","title":"Implementando um FF tipo D"},{"location":"seq-Lab-1/#reset-e-preset","text":"Warning Antes de continuar, voc\u00ea deve ter feito a leitura pr\u00e9via sobre L\u00f3gica Sequencial em VHDL, s\u00f3 continue ap\u00f3s ter realizado a leitura: No site da disciplina: VHDL Sequencial Flip Flops possuem normalmente dois outros sinais de controle: Clear e Preset , usados respectivamente para for\u00e7ar '0' ou '1' em sua sa\u00edda. Vamos modificar o c\u00f3digo anterior para suportar essas duas outras funcionalidades. Nesse caso possu\u00edmos duas op\u00e7\u00f5es: Set/Clear : s\u00edncrono Set/Clear : ass\u00edncrono O modo s\u00edncrono seria que o set e o clear s\u00f3 podem ser executado na subida do clock e no ass\u00edncrono em qualquer momento que o sinal se set e clear forem alterados o FF ir\u00e1 responder imediatamente. Nesse caso, iremos implementar o FF com set e reset ass\u00edncrono, para isso utilize a seguinte estrutura a seguir que j\u00e1 implementa o sinal de clear Iremos modificar o c\u00f3digo localizado em D-LogicaSequencial/src/rtl/FlipFlopD.vhd que possui a implementa\u00e7\u00e3o parcial de um FF tipo D, mas n\u00e3o tem o preset process ( clock , clear ) begin if ( clear = '1' ) then Q <= '0' ; elsif ( rising_edge ( clock )) then Q <= D ; end if ; end process ; Tarefa: FF completo D-LogicaSequencial/src/rtl/FlipFlopD.vhd Implemente o preset (o clear j\u00e1 est\u00e1 feito) Agora voc\u00ea pode executar o script de teste do projeto e verificar se a implementa\u00e7\u00e3o est\u00e1 correta. S\u00f3 continuar se estiver passando nos testes Tarefa: waveform execute ./testeLogicaSequencial -g analise a forma de onda do teste do FF no modelsim Tip Discuta no grupo a forma de onda Chame um professor para conversar sobre o entendimento de voc\u00eas Tarefa: RTL Gere o RTL (via quartus) analise o resultado do FF. Salve a forma de onda na pasta src/rtl/ do projeto com o nome FlipFlop.png .","title":"Reset e Preset"},{"location":"seq-Lab-1/#checkpoint","text":"Ao final dessa etapa voc\u00ea deve ser capaz de: Saber o que \u00e9 um process em VHDL e o impacto da lista de sensibilidade Saber o que \u00e9 um FlipFlop tipo D Explicar a forma de onda do FlipFlopD gerada no modelsim Explicar o RTL do FlipFlopD criado pelo Quartus","title":"Checkpoint"},{"location":"seq-Lab-1/#_1","text":"","title":""},{"location":"seq-Projeto/","text":"D - L\u00f3gica Sequencia \u00b6 Neste projeto voc\u00ea ter\u00e1 que desenvolver os componentes de mem\u00f3ria que ser\u00e3o utilizados no computador Z01. Instru\u00e7\u00f5es \u00b6 A pasta do projeto D-LogicaSequencial no reposit\u00f3rio Z01, possui a seguinte estrutura: /D-LogicaSequencial testeLogicaSequencial.py /Quartus /src /rtl *.vhd /tests /tst *.vhd Quartus: Projeto Quartus que faz uso dos arquivos VHDL localizados em src/rtl/*.vhd ; scripts: Scripts em python que automatizam a execu\u00e7\u00e3o dos testes; src/rtl/*.vhd : Arquivos VHDL que ser\u00e3o implementados pelo grupo; tests/tst/*.vhd : Arquivos VHDL que realizam o teste l\u00f3gico nos arquivos do rtl. Executando o Script de Teste \u00b6 Abra o terminal na pasta D-LogicaSequencial e execute o script python localizado nessa pasta: $ python testeLogicaSequencial.py O mesmo ir\u00e1 compilar os arquivos src/rtl/*.vhd e executar os testes unit\u00e1rios em cada um deles. Nesse momento do teste, como os m\u00f3dulos n\u00e3o est\u00e3o implementados, o resultado dever\u00e1 ser falho. Note Lembre que o arquivo tests/config.txt define quais testes ser\u00e3o executados. Projeto \u00b6 Deve-se gerar uma imagem com a forma de onda desses m\u00f3dulos. Deve-se gerar um RTL para cada m\u00f3dulo do projeto (Lab 10) Note que \u00e9 poss\u00edvel reaproveitar, via port map , os m\u00f3dulos dos projetos anteriores. Para isso basta usar port map. M\u00f3dulos \u00b6 Esses arquivos est\u00e3o localizados em D-LogicaSequencial/src/rtl/ e detalhados no Cap\u00edtulo 3 - The Elements of Computing Systems Flip Flop Arquivo : FlipFlopD.vhd Depend\u00eancia : \u00c9 \u00e9 um bloco elementar e sua implementa\u00e7\u00e3o \u00e9 criada no laborat\u00f3rio do projeto . Binary Digit Arquivo : BinaryDigit.vhd Depend\u00eancia : FlipFlopD e Mux2Way Descri\u00e7\u00e3o : \u00c9 um registrador feito para armazenar um \u00fanico bit de informa\u00e7\u00e3o (0 ou 1). A interface do m\u00f3dulo consiste em uma entrada (d) para o bit a ser armazenado, um sinal de load para indicar quando o bit de entrada deve ser armazenado um sinal de clock e a sa\u00edda output* que \u00e9 o bit armazenado: Register 8 Arquivo : Register8.vhd Depend\u00eancia : BinaryDigit Descri\u00e7\u00e3o : \u00c9 um registrador de 8 bits criado a partir do binaryDigit por\u00e9m agora para armazenar um vetor de entrada de 8 bits de tamanho. Register 16 Arquivo : Register16.vhd Depend\u00eancia : Register8 Descri\u00e7\u00e3o : \u00c9 um registrador de 16 bits criado a partir do Register8 por\u00e9m agora para armazenar um vetor de entrada de 16 bits de tamanho. Register 32 Arquivo : Register32.vhd Depend\u00eancia : Register16 Descri\u00e7\u00e3o : \u00c9 um registrador de 32 bits criado a partir do Register16 por\u00e9m agora para armazenar um vetor de entrada de 32 bits de tamanho. Register 64 Arquivo : Register64.vhd Depend\u00eancia : Register32 Descri\u00e7\u00e3o : \u00c9 um registrador de 64 bits criado a partir do Register32 por\u00e9m agora para armazenar um vetor de entrada de 64 bits de tamanho. Program Counter Arquivo : PC.vhd Depend\u00eancia : inc16 , mux16 , reg16 Descri\u00e7\u00e3o : O program counter ser\u00e1 o nosso endere\u00e7ador de mem\u00f3ria da CPU, ele ser\u00e1 respons\u00e1vel por apontar para a pr\u00f3xima instru\u00e7\u00e3o a ser executada. Como normalmente um c\u00f3digo segue um fluxo sequencial (uma linha na sequ\u00eancia da outra) o PC possui a habilidade de se auto incrementar a cada clock (apontando assim para a pr\u00f3xima instru\u00e7\u00e3o), mas ele tem que suportar condi\u00e7\u00f5es (if, while, ...) rompendo com esse fluxo cont\u00ednuo. Sua l\u00f3gica \u00e9 descrita no pseudo c\u00f3digo a seguir: If reset(t-1) then out(t)=0 else if load(t-1) then out(t)=in(t-1) else if inc(t-1) then out(t)=out(t-1)+1 else out(t)=out(t-1) Ram8 Arquivo : Ram8.vhd Depend\u00eancia : Register16 , Mux8Way16 , Dmux8Way Descri\u00e7\u00e3o : \u00c9 uma mem\u00f3ria de 8 endere\u00e7os com 16 bits de largura. O componente possui como entrada o vetor input de 16 bits, o endere\u00e7o a ser armazenado (address) o sinal load que indica quando \u00e9 para ser armazenado e o clock. Como sa\u00edda temos o valor lido no endere\u00e7o especificado quando load for igual a 0. Note que sinal LOAD tem como fun\u00e7\u00e3o similar o do READ/WRITE, quando zero, indica que queremos ler o valor armazenado, quando 1 indica que queremos escrever (write) nessa posi\u00e7\u00e3o. Ram64 Arquivo : Ram64.vhd Depend\u00eancia : Ram8 , Mux8Way16 , Dmux8Way Descri\u00e7\u00e3o : Similar a RAM8 por\u00e9m com 64 endere\u00e7os. Ram512 Arquivo : Ram512.vhd Depend\u00eancia : Ram64 , Mux8Way16 , Dmux8Way Descri\u00e7\u00e3o : Similar a RAM8 por\u00e9m com 512 endere\u00e7os. Ram4k Arquivo : Ram4k.vhd Depend\u00eancia : Ram512 , Mux8Way16 , Dmux8Way Descri\u00e7\u00e3o : Similar a RAM8 por\u00e9m com 4512 endere\u00e7os. Tip Todos esses m\u00f3dulos est\u00e3o bem documentados no livro The Elements of Computer System. Cap 3. Forma de onda \u00b6 Para cada teste realizado, deve-se carregar a interface gr\u00e1fica do simulador e tirar um print da forma de onda do m\u00f3dulo com os testes aplicados a ele. Essa imagem deve ser salva na mesma pasta dos arquivos vhdl ( src/doc/*_wave.png ) e com o mesmo nome dos m\u00f3dulos (similar ao projeto passado). Warning N\u00e3o basta s\u00f3 gerar a imagem, voc\u00ea precisa analisar e entender. Isso ser\u00e1 cobrado nas avalia\u00e7\u00f5es. RTL \u00b6 Para cada m\u00f3dulo deve-se gerar o RTL e salvar uma imagem da implementa\u00e7\u00e3o na pasta src/doc/_rtl.png . !! warning N\u00e3o basta s\u00f3 gerar a imagem, voc\u00ea precisa analisar e entender. Isso ser\u00e1 cobrado nas avalia\u00e7\u00f5es. Testando em Hardware \u00b6 No hardware voc\u00ea dever\u00e1 desenvolver um cen\u00e1rio de teste para o Program Counter ou para para a RAM8 . Rubricas para avalia\u00e7\u00e3o de projetos \u00b6 Cada integrante do grupo ir\u00e1 receber duas notas: uma referente ao desenvolvimento total do projeto (Projeto) e outra referente a sua participa\u00e7\u00e3o individual no grupo (que depende do seu papel). Projeto \u00b6 Conceito A - Gravou e testou a mem\u00f3ria RAM8 na FPGA. (gravou um v\u00eddeo para mostrar o funcionamento) B - Usou sempre que poss\u00edvel outros m\u00f3dulos para criar um novo (hierarquia) - Exemplo: usou o inc16 , mux16 e reg16 para criar PC C - Todos os m\u00f3dulos sendo testados no Travis - O ramo master passa nos testes do travis - Todos os m\u00f3dulos passam nos testes - Possui a forma de onda e rtl de todos os m\u00f3dulos (.png) D - Ao menos um m\u00f3dulo n\u00e3o foi implementando ou n\u00e3o passa no testes. I - Menos da metade dos m\u00f3dulos funcionando","title":"D - L\u00f3gica Sequencia"},{"location":"seq-Projeto/#d-logica-sequencia","text":"Neste projeto voc\u00ea ter\u00e1 que desenvolver os componentes de mem\u00f3ria que ser\u00e3o utilizados no computador Z01.","title":"D - L\u00f3gica Sequencia"},{"location":"seq-Projeto/#instrucoes","text":"A pasta do projeto D-LogicaSequencial no reposit\u00f3rio Z01, possui a seguinte estrutura: /D-LogicaSequencial testeLogicaSequencial.py /Quartus /src /rtl *.vhd /tests /tst *.vhd Quartus: Projeto Quartus que faz uso dos arquivos VHDL localizados em src/rtl/*.vhd ; scripts: Scripts em python que automatizam a execu\u00e7\u00e3o dos testes; src/rtl/*.vhd : Arquivos VHDL que ser\u00e3o implementados pelo grupo; tests/tst/*.vhd : Arquivos VHDL que realizam o teste l\u00f3gico nos arquivos do rtl.","title":"Instru\u00e7\u00f5es"},{"location":"seq-Projeto/#executando-o-script-de-teste","text":"Abra o terminal na pasta D-LogicaSequencial e execute o script python localizado nessa pasta: $ python testeLogicaSequencial.py O mesmo ir\u00e1 compilar os arquivos src/rtl/*.vhd e executar os testes unit\u00e1rios em cada um deles. Nesse momento do teste, como os m\u00f3dulos n\u00e3o est\u00e3o implementados, o resultado dever\u00e1 ser falho. Note Lembre que o arquivo tests/config.txt define quais testes ser\u00e3o executados.","title":"Executando o Script de Teste"},{"location":"seq-Projeto/#projeto","text":"Deve-se gerar uma imagem com a forma de onda desses m\u00f3dulos. Deve-se gerar um RTL para cada m\u00f3dulo do projeto (Lab 10) Note que \u00e9 poss\u00edvel reaproveitar, via port map , os m\u00f3dulos dos projetos anteriores. Para isso basta usar port map.","title":"Projeto"},{"location":"seq-Projeto/#modulos","text":"Esses arquivos est\u00e3o localizados em D-LogicaSequencial/src/rtl/ e detalhados no Cap\u00edtulo 3 - The Elements of Computing Systems Flip Flop Arquivo : FlipFlopD.vhd Depend\u00eancia : \u00c9 \u00e9 um bloco elementar e sua implementa\u00e7\u00e3o \u00e9 criada no laborat\u00f3rio do projeto . Binary Digit Arquivo : BinaryDigit.vhd Depend\u00eancia : FlipFlopD e Mux2Way Descri\u00e7\u00e3o : \u00c9 um registrador feito para armazenar um \u00fanico bit de informa\u00e7\u00e3o (0 ou 1). A interface do m\u00f3dulo consiste em uma entrada (d) para o bit a ser armazenado, um sinal de load para indicar quando o bit de entrada deve ser armazenado um sinal de clock e a sa\u00edda output* que \u00e9 o bit armazenado: Register 8 Arquivo : Register8.vhd Depend\u00eancia : BinaryDigit Descri\u00e7\u00e3o : \u00c9 um registrador de 8 bits criado a partir do binaryDigit por\u00e9m agora para armazenar um vetor de entrada de 8 bits de tamanho. Register 16 Arquivo : Register16.vhd Depend\u00eancia : Register8 Descri\u00e7\u00e3o : \u00c9 um registrador de 16 bits criado a partir do Register8 por\u00e9m agora para armazenar um vetor de entrada de 16 bits de tamanho. Register 32 Arquivo : Register32.vhd Depend\u00eancia : Register16 Descri\u00e7\u00e3o : \u00c9 um registrador de 32 bits criado a partir do Register16 por\u00e9m agora para armazenar um vetor de entrada de 32 bits de tamanho. Register 64 Arquivo : Register64.vhd Depend\u00eancia : Register32 Descri\u00e7\u00e3o : \u00c9 um registrador de 64 bits criado a partir do Register32 por\u00e9m agora para armazenar um vetor de entrada de 64 bits de tamanho. Program Counter Arquivo : PC.vhd Depend\u00eancia : inc16 , mux16 , reg16 Descri\u00e7\u00e3o : O program counter ser\u00e1 o nosso endere\u00e7ador de mem\u00f3ria da CPU, ele ser\u00e1 respons\u00e1vel por apontar para a pr\u00f3xima instru\u00e7\u00e3o a ser executada. Como normalmente um c\u00f3digo segue um fluxo sequencial (uma linha na sequ\u00eancia da outra) o PC possui a habilidade de se auto incrementar a cada clock (apontando assim para a pr\u00f3xima instru\u00e7\u00e3o), mas ele tem que suportar condi\u00e7\u00f5es (if, while, ...) rompendo com esse fluxo cont\u00ednuo. Sua l\u00f3gica \u00e9 descrita no pseudo c\u00f3digo a seguir: If reset(t-1) then out(t)=0 else if load(t-1) then out(t)=in(t-1) else if inc(t-1) then out(t)=out(t-1)+1 else out(t)=out(t-1) Ram8 Arquivo : Ram8.vhd Depend\u00eancia : Register16 , Mux8Way16 , Dmux8Way Descri\u00e7\u00e3o : \u00c9 uma mem\u00f3ria de 8 endere\u00e7os com 16 bits de largura. O componente possui como entrada o vetor input de 16 bits, o endere\u00e7o a ser armazenado (address) o sinal load que indica quando \u00e9 para ser armazenado e o clock. Como sa\u00edda temos o valor lido no endere\u00e7o especificado quando load for igual a 0. Note que sinal LOAD tem como fun\u00e7\u00e3o similar o do READ/WRITE, quando zero, indica que queremos ler o valor armazenado, quando 1 indica que queremos escrever (write) nessa posi\u00e7\u00e3o. Ram64 Arquivo : Ram64.vhd Depend\u00eancia : Ram8 , Mux8Way16 , Dmux8Way Descri\u00e7\u00e3o : Similar a RAM8 por\u00e9m com 64 endere\u00e7os. Ram512 Arquivo : Ram512.vhd Depend\u00eancia : Ram64 , Mux8Way16 , Dmux8Way Descri\u00e7\u00e3o : Similar a RAM8 por\u00e9m com 512 endere\u00e7os. Ram4k Arquivo : Ram4k.vhd Depend\u00eancia : Ram512 , Mux8Way16 , Dmux8Way Descri\u00e7\u00e3o : Similar a RAM8 por\u00e9m com 4512 endere\u00e7os. Tip Todos esses m\u00f3dulos est\u00e3o bem documentados no livro The Elements of Computer System. Cap 3.","title":"M\u00f3dulos"},{"location":"seq-Projeto/#forma-de-onda","text":"Para cada teste realizado, deve-se carregar a interface gr\u00e1fica do simulador e tirar um print da forma de onda do m\u00f3dulo com os testes aplicados a ele. Essa imagem deve ser salva na mesma pasta dos arquivos vhdl ( src/doc/*_wave.png ) e com o mesmo nome dos m\u00f3dulos (similar ao projeto passado). Warning N\u00e3o basta s\u00f3 gerar a imagem, voc\u00ea precisa analisar e entender. Isso ser\u00e1 cobrado nas avalia\u00e7\u00f5es.","title":"Forma de onda"},{"location":"seq-Projeto/#rtl","text":"Para cada m\u00f3dulo deve-se gerar o RTL e salvar uma imagem da implementa\u00e7\u00e3o na pasta src/doc/_rtl.png . !! warning N\u00e3o basta s\u00f3 gerar a imagem, voc\u00ea precisa analisar e entender. Isso ser\u00e1 cobrado nas avalia\u00e7\u00f5es.","title":"RTL"},{"location":"seq-Projeto/#testando-em-hardware","text":"No hardware voc\u00ea dever\u00e1 desenvolver um cen\u00e1rio de teste para o Program Counter ou para para a RAM8 .","title":"Testando em Hardware"},{"location":"seq-Projeto/#rubricas-para-avaliacao-de-projetos","text":"Cada integrante do grupo ir\u00e1 receber duas notas: uma referente ao desenvolvimento total do projeto (Projeto) e outra referente a sua participa\u00e7\u00e3o individual no grupo (que depende do seu papel).","title":"Rubricas para avalia\u00e7\u00e3o de projetos"},{"location":"seq-Projeto/#projeto_1","text":"Conceito A - Gravou e testou a mem\u00f3ria RAM8 na FPGA. (gravou um v\u00eddeo para mostrar o funcionamento) B - Usou sempre que poss\u00edvel outros m\u00f3dulos para criar um novo (hierarquia) - Exemplo: usou o inc16 , mux16 e reg16 para criar PC C - Todos os m\u00f3dulos sendo testados no Travis - O ramo master passa nos testes do travis - Todos os m\u00f3dulos passam nos testes - Possui a forma de onda e rtl de todos os m\u00f3dulos (.png) D - Ao menos um m\u00f3dulo n\u00e3o foi implementando ou n\u00e3o passa no testes. I - Menos da metade dos m\u00f3dulos funcionando","title":"Projeto"},{"location":"seq-lab-1-fpga/","text":"Testando na FPGA \u00b6 No Quartus atribua ao toplevel o arquivo TopLevel.vhd (mesmo passos anteriores), esse m\u00f3dulo ir\u00e1 mapear o FF rec\u00e9m criado para os pinos da FPGA: Clock <= not KEY(0); -- os botoes quando nao apertado vale 1 -- e apertado 0, essa logica inverte isso clear <= not KEY(1); set <= not KEY(2); u0 : FlipFlopD port map ( clock => Clock, d => SW(0), clear => clear, preset => set, q => LEDR(0) ); Note que nesse c\u00f3digo estamos usando os bot\u00f5es ( KEY ) da FPGA, al\u00e9m dos LEDs e das Chaves (SW). COMPILE, PROGRAME E TESTE + Chame um professor para validar Esse exemplo n\u00e3o segue as boas pr\u00e1ticas de projetos em FPGA pois n\u00e3o se deve gerar um clock a partir de um pino qualquer da FPGA, a FPGA possui pinos espec\u00edficos para a gera\u00e7\u00e3o do clock. Por\u00e9m \u00e9 a melhor maneira did\u00e1tica de mostrar um FF operando. O correto seria colocarmos um pino de \"enable\" que ativaria ou n\u00e3o o FF quando o bot\u00e3o fosse pressionado.","title":"Seq lab 1 fpga"},{"location":"seq-lab-1-fpga/#testando-na-fpga","text":"No Quartus atribua ao toplevel o arquivo TopLevel.vhd (mesmo passos anteriores), esse m\u00f3dulo ir\u00e1 mapear o FF rec\u00e9m criado para os pinos da FPGA: Clock <= not KEY(0); -- os botoes quando nao apertado vale 1 -- e apertado 0, essa logica inverte isso clear <= not KEY(1); set <= not KEY(2); u0 : FlipFlopD port map ( clock => Clock, d => SW(0), clear => clear, preset => set, q => LEDR(0) ); Note que nesse c\u00f3digo estamos usando os bot\u00f5es ( KEY ) da FPGA, al\u00e9m dos LEDs e das Chaves (SW). COMPILE, PROGRAME E TESTE + Chame um professor para validar Esse exemplo n\u00e3o segue as boas pr\u00e1ticas de projetos em FPGA pois n\u00e3o se deve gerar um clock a partir de um pino qualquer da FPGA, a FPGA possui pinos espec\u00edficos para a gera\u00e7\u00e3o do clock. Por\u00e9m \u00e9 a melhor maneira did\u00e1tica de mostrar um FF operando. O correto seria colocarmos um pino de \"enable\" que ativaria ou n\u00e3o o FF quando o bot\u00e3o fosse pressionado.","title":"Testando na FPGA"},{"location":"sobra/","text":"Configurando Travis \u00b6 Criando um project no github Adicionando issues Os issues devem ser todos os m\u00f3dulos a serem implementados do projeto. Referenciando a raiz \u00b6 Para come\u00e7ar ser\u00e1 necess\u00e1rio atualizar o fork do reposit\u00f3rio que voc\u00eas criaram, com novos dados que ser\u00e3o colocados no reposit\u00f3rio da disciplina. Uma vez clonado o reposit\u00f3rio, voc\u00ea deve entrar na pasta via o terminal: $ cd Z01.1-NomeDoGrupo Estando na pasta do reposit\u00f3rio precisamos agora indicar para o reposit\u00f3rio original na qual o reposit\u00f3rio que deu origem a esse fork, para isso devemos executar a seguinte linha de c\u00f3digo: $ git remote add upstream https://github.com/insper/Z01.1 Para verificar se deu certo, execute: $ git remote -v E deve aparecer al\u00e9m do link para o reposit\u00f3rio de voc\u00eas a refer\u00eancia ao reposit\u00f3rio original: upstream https://github.com/insper/Z01.1 ( fetch ) upstream https://github.com/insper/Z01.1 ( push ) Tip D\u00favidas? https://gist.github.com/CristinaSolana/1885435 https://help.github.com/articles/syncing-a-fork/ Sincronizando com upstream \u00b6 Apenas mediador Essa etapa deve ser realizada apenas pelo mediador do projeto! Para atualizar o reposit\u00f3rio do grupo de voc\u00eas com as novas atualiza\u00e7\u00f5es inseridas no reposit\u00f3rio da disciplina basta executar: $ git fetch upstream Agora precisamos realizar um merge desse branch (que cont\u00e9m as atualiza\u00e7\u00f5es do reposit\u00f3rio da disciplina) com o master: $ git checkout master $ git merge upstream/master Precisamos submeter essa atualiza\u00e7\u00e3o para o reposit\u00f3rio remoto a fim de todos do grupo terem acesso a vers\u00e3o mais nova. $ git push origin master Dicas VHDL Existem diversos locais onde podem tirar d\u00favida de VHDL , por exemplo : http://esd.cs.ucr.edu/labs/tutorial/ https://courseware.ee.calpoly.edu/cpe-169/Misc_stuff/cheat_sheet.pdf https://www.ics.uci.edu/~jmoorkan/vhdlref/vhdl_golden_reference_guide.pdf","title":"Sobra"},{"location":"sobra/#configurando-travis","text":"Criando um project no github Adicionando issues Os issues devem ser todos os m\u00f3dulos a serem implementados do projeto.","title":"Configurando Travis"},{"location":"sobra/#referenciando-a-raiz","text":"Para come\u00e7ar ser\u00e1 necess\u00e1rio atualizar o fork do reposit\u00f3rio que voc\u00eas criaram, com novos dados que ser\u00e3o colocados no reposit\u00f3rio da disciplina. Uma vez clonado o reposit\u00f3rio, voc\u00ea deve entrar na pasta via o terminal: $ cd Z01.1-NomeDoGrupo Estando na pasta do reposit\u00f3rio precisamos agora indicar para o reposit\u00f3rio original na qual o reposit\u00f3rio que deu origem a esse fork, para isso devemos executar a seguinte linha de c\u00f3digo: $ git remote add upstream https://github.com/insper/Z01.1 Para verificar se deu certo, execute: $ git remote -v E deve aparecer al\u00e9m do link para o reposit\u00f3rio de voc\u00eas a refer\u00eancia ao reposit\u00f3rio original: upstream https://github.com/insper/Z01.1 ( fetch ) upstream https://github.com/insper/Z01.1 ( push ) Tip D\u00favidas? https://gist.github.com/CristinaSolana/1885435 https://help.github.com/articles/syncing-a-fork/","title":"Referenciando a raiz"},{"location":"sobra/#sincronizando-com-upstream","text":"Apenas mediador Essa etapa deve ser realizada apenas pelo mediador do projeto! Para atualizar o reposit\u00f3rio do grupo de voc\u00eas com as novas atualiza\u00e7\u00f5es inseridas no reposit\u00f3rio da disciplina basta executar: $ git fetch upstream Agora precisamos realizar um merge desse branch (que cont\u00e9m as atualiza\u00e7\u00f5es do reposit\u00f3rio da disciplina) com o master: $ git checkout master $ git merge upstream/master Precisamos submeter essa atualiza\u00e7\u00e3o para o reposit\u00f3rio remoto a fim de todos do grupo terem acesso a vers\u00e3o mais nova. $ git push origin master Dicas VHDL Existem diversos locais onde podem tirar d\u00favida de VHDL , por exemplo : http://esd.cs.ucr.edu/labs/tutorial/ https://courseware.ee.calpoly.edu/cpe-169/Misc_stuff/cheat_sheet.pdf https://www.ics.uci.edu/~jmoorkan/vhdlref/vhdl_golden_reference_guide.pdf","title":"Sincronizando com upstream"},{"location":"ula-Lab-1/","text":"Lab 6: Adders \u00b6 Trabalhando em grupo Realizar o lab em trio Antes de come\u00e7ar Toda vez que um novo projeto come\u00e7ar ser\u00e1 necess\u00e1rio realizar algumas configura\u00e7\u00f5es no reposit\u00f3rio do grupo, voc\u00eas devem seguir para o documento: Util/Come\u00e7ando novo Projeto e depois voltar para esse lab. N\u00e3o seguir sem realizar a etapa anterior. Half-adder \u00b6 O half-adder \u00e9 um dispositivo somador bin\u00e1rio que possui duas entradas bin\u00e1rias (a,b) e duas sa\u00eddas bin\u00e1ria (soma dos bits (Soma) e o carry (vaium)). A tabela verdade desse componente \u00e9 detalhada a seguir: a b Soma Vaium 0 0 0 0 0 1 1 0 1 0 1 0 1 1 0 1 Com a tabela verdade podemos extrair as duas equa\u00e7\u00f5es que descreve esse componente: Soma e Vaium. soma = a xor b vaium = a and b Note Leia a teoria: Aritm\u00e9tica Binaria para mais informa\u00e7\u00f5es. Tip \\bar{a} b + a \\bar{b} = a \\oplus b \\bar{a} b + a \\bar{b} = a \\oplus b Agora com a equa\u00e7\u00e3o definida \u00e9 poss\u00edvel realizarmos uma descri\u00e7\u00e3o em VHDL do componente halfadder . Abra o arquivo C-UnidadeLogicaAritmetica/src/rtl/HalfAdder.vhd e modifique sua arquitetura para implementar a equa\u00e7\u00e3o do halfadder. Edite o arquivo de configura\u00e7\u00e3o do teste tests/config.txt e descomente a linha referente ao halfadder . Valide a implementa\u00e7\u00e3o executando o script de testes: testeULA.py Testando na FPGA \u00b6 Abra o projeto do Quartus e note que o toplevel faz uso do HalfAdder : begin u1 : HalfAdder port map ( a => SW ( 0 ), b => SW ( 1 ), soma => LEDR ( 0 ), vaium => LEDR ( 1 )); end rtl ; ------ SW(0) --> a -->| |--> Soma --> LEDR(0) | HA | SW(1) --> b -->| |--> Carry --> LEDR(1) ------ toplevel Tarefa Compile o projeto Gere e analise o RTL Programe a FPGA Mexa nas chaves, o resultado \u00e9 o esperado? Full-Adder \u00b6 Voc\u00ea deve fazer a mesma coisa com o fulladder: Extrair a equa\u00e7\u00e3o do FullAdder Transcrever para o arquivo: FullAdder.vhd Testar ( ./testeULA.py ) Com o m\u00f3dulo passando nos testes, editar o toplevel para utilizar no lugar do HalfAdder o FullAdder rec\u00e9m implementando! begin u1 : FullAdder port map ( a => SW ( 0 ), b => SW ( 1 ), c => SW ( 2 ), soma => LEDR ( 0 ), vaium => LEDR ( 1 )); end rtl ; Tarefa Compile o projeto Gere e analise o RTL Programe a FPGA Mexa nas chaves, o resultado \u00e9 o esperado? Somador \u00b6 Agora com o FullAdder (FAD) feito podemos construir um somador mais completo, que soma dois vetores de bits. Para isso iremos precisar de dois FullAdders conectados da seguinte maneira: x1 y1 ---------- x0 y0 '0' | | | | | | | v v v | v v v ---------- | ---------- | a b c | | | a b c | | | | | | Carry <--|vaium | <--|vaium | | soma | | soma | ---------- ---------- | | v v s1 s0 Nessa liga\u00e7\u00e3o, estamos somando dois vetores de dois bits cada: x(1 downto 0) + y(1 downto 0) que resulta em uma soma de dois bits: s(1 downto 0) e um carry . Question Explique o que est\u00e1 acontecendo para o seu colega, voc\u00ea entendeu o porque dessa liga\u00e7\u00e3o? Utilizando port map construa o circuito anterior, utilize como entrada X as chaves [SW(1) SW(0)] e como entrada Y as chaves [SW(3) SW(2)] , para visualizar coloque a sa\u00edda S nos leds [LEDR(1) LEDR(0)] e o carry no LEDR(3) Tarefa Modifique o toplevel para implementar esse somador Compile o projeto Gere e analise o RTL Programe a FPGA Mexa nas chaves, o resultado \u00e9 o esperado? Tip Voc\u00ea deve utilizar port map para isso, inicializando dois componentes FullAdder","title":"Lab 6: Adders"},{"location":"ula-Lab-1/#lab-6-adders","text":"Trabalhando em grupo Realizar o lab em trio Antes de come\u00e7ar Toda vez que um novo projeto come\u00e7ar ser\u00e1 necess\u00e1rio realizar algumas configura\u00e7\u00f5es no reposit\u00f3rio do grupo, voc\u00eas devem seguir para o documento: Util/Come\u00e7ando novo Projeto e depois voltar para esse lab. N\u00e3o seguir sem realizar a etapa anterior.","title":"Lab 6: Adders"},{"location":"ula-Lab-1/#half-adder","text":"O half-adder \u00e9 um dispositivo somador bin\u00e1rio que possui duas entradas bin\u00e1rias (a,b) e duas sa\u00eddas bin\u00e1ria (soma dos bits (Soma) e o carry (vaium)). A tabela verdade desse componente \u00e9 detalhada a seguir: a b Soma Vaium 0 0 0 0 0 1 1 0 1 0 1 0 1 1 0 1 Com a tabela verdade podemos extrair as duas equa\u00e7\u00f5es que descreve esse componente: Soma e Vaium. soma = a xor b vaium = a and b Note Leia a teoria: Aritm\u00e9tica Binaria para mais informa\u00e7\u00f5es. Tip \\bar{a} b + a \\bar{b} = a \\oplus b \\bar{a} b + a \\bar{b} = a \\oplus b Agora com a equa\u00e7\u00e3o definida \u00e9 poss\u00edvel realizarmos uma descri\u00e7\u00e3o em VHDL do componente halfadder . Abra o arquivo C-UnidadeLogicaAritmetica/src/rtl/HalfAdder.vhd e modifique sua arquitetura para implementar a equa\u00e7\u00e3o do halfadder. Edite o arquivo de configura\u00e7\u00e3o do teste tests/config.txt e descomente a linha referente ao halfadder . Valide a implementa\u00e7\u00e3o executando o script de testes: testeULA.py","title":"Half-adder"},{"location":"ula-Lab-1/#testando-na-fpga","text":"Abra o projeto do Quartus e note que o toplevel faz uso do HalfAdder : begin u1 : HalfAdder port map ( a => SW ( 0 ), b => SW ( 1 ), soma => LEDR ( 0 ), vaium => LEDR ( 1 )); end rtl ; ------ SW(0) --> a -->| |--> Soma --> LEDR(0) | HA | SW(1) --> b -->| |--> Carry --> LEDR(1) ------ toplevel Tarefa Compile o projeto Gere e analise o RTL Programe a FPGA Mexa nas chaves, o resultado \u00e9 o esperado?","title":"Testando na FPGA"},{"location":"ula-Lab-1/#full-adder","text":"Voc\u00ea deve fazer a mesma coisa com o fulladder: Extrair a equa\u00e7\u00e3o do FullAdder Transcrever para o arquivo: FullAdder.vhd Testar ( ./testeULA.py ) Com o m\u00f3dulo passando nos testes, editar o toplevel para utilizar no lugar do HalfAdder o FullAdder rec\u00e9m implementando! begin u1 : FullAdder port map ( a => SW ( 0 ), b => SW ( 1 ), c => SW ( 2 ), soma => LEDR ( 0 ), vaium => LEDR ( 1 )); end rtl ; Tarefa Compile o projeto Gere e analise o RTL Programe a FPGA Mexa nas chaves, o resultado \u00e9 o esperado?","title":"Full-Adder"},{"location":"ula-Lab-1/#somador","text":"Agora com o FullAdder (FAD) feito podemos construir um somador mais completo, que soma dois vetores de bits. Para isso iremos precisar de dois FullAdders conectados da seguinte maneira: x1 y1 ---------- x0 y0 '0' | | | | | | | v v v | v v v ---------- | ---------- | a b c | | | a b c | | | | | | Carry <--|vaium | <--|vaium | | soma | | soma | ---------- ---------- | | v v s1 s0 Nessa liga\u00e7\u00e3o, estamos somando dois vetores de dois bits cada: x(1 downto 0) + y(1 downto 0) que resulta em uma soma de dois bits: s(1 downto 0) e um carry . Question Explique o que est\u00e1 acontecendo para o seu colega, voc\u00ea entendeu o porque dessa liga\u00e7\u00e3o? Utilizando port map construa o circuito anterior, utilize como entrada X as chaves [SW(1) SW(0)] e como entrada Y as chaves [SW(3) SW(2)] , para visualizar coloque a sa\u00edda S nos leds [LEDR(1) LEDR(0)] e o carry no LEDR(3) Tarefa Modifique o toplevel para implementar esse somador Compile o projeto Gere e analise o RTL Programe a FPGA Mexa nas chaves, o resultado \u00e9 o esperado? Tip Voc\u00ea deve utilizar port map para isso, inicializando dois componentes FullAdder","title":"Somador"},{"location":"ula-Lab-2/","text":"Lab 7: Visualizando simula\u00e7\u00e3o \u00b6 Trabalhando em grupo Realizar o lab em trio \u00c9 muito dif\u00edcil sabermos porque uma implementa\u00e7\u00e3o em VHDL n\u00e3o funciona, atualmente o fluxo \u00e9: transcreve para VHDL o componente; testa; n\u00e3o funcionou volta para o VHDL; testa.... Ser\u00e1 que n\u00e3o existe uma forma de conseguirmos visualizar o resultado do teste e com isso mudarmos a implementa\u00e7\u00e3o em VDHL? Sim existe! Para isso ser\u00e1 necess\u00e1rio invocarmos a parte gr\u00e1fica do modelsim. Na hora de invocarmos o script de teste ( B-UnidadeLogicaAritmetica/testeULA.py ) passe o par\u00e2metro --gui (ou -g ), como a seguir: $ python testeULA.py --gui Esse comando ir\u00e1 executar a simula\u00e7\u00e3o e abrir no software modelsim (toda a simula\u00e7\u00e3o \u00e9 realizada por esse software, mas estava sendo 'mascarada' pelos scripts de teste em py). Note Antes de continuar, o m\u00f3dulo do HalfAdder.vhd j\u00e1 deve est\u00e1 implementando e testado (na forma tradicional). modelsim \u00b6 O modelsim n\u00e3o possui uma interface moderna, por\u00e9m \u00e9 o software de simula\u00e7\u00e3o de hardware mais completo e mais utilizado pela industria. Siga os passos a seguir para conseguirmos visualizarmos a forma de onda: Primeiramente devemos adicionar os sinais que desejamos visualizar, no caso do HalfAdder queremos ver suas entradas (a,b) e suas sa\u00eddas (soma, vaium). Para isso clique em wave : Tip Caso n\u00e3o possua a janela wave aberta, clique em File -> Wave e a janela ir\u00e1 aparecer. E depois selecione no menu das inst\u00e2ncias o m\u00f3dulo u1HalfAdder, com isso poderemos selecionar quais pinos/ sinais gostar\u00edamos de visualizar desse bloco. Arraste todos os sinais para o wave form : Resultando em: Agora podemos executar a simula\u00e7\u00e3o, na regi\u00e3o do script TCL execute o seguinte comando: vunit_run VSIM > vunit_run Podemos agora visualizar a forma de onda: Aprimorando teste \u00b6 Testbench (bancada de teste) \u00e9 a forma utilizada para verificarmos se um projeto de HDL (VHDL, Verilog, ...) est\u00e1 certo, o testbench pode ser escrito em v\u00e1rias linguagens inclusive em VHDL. Os TestBenchs est\u00e3o localizados nas pastas dos projetos em: /tests/tst/ . No projeto C temos os seguintes testbenchs definidos (um para cada m\u00f3dulo a ser implementando): /tests/tst/ tb_Add16.vhd tb_ALU.vhd tb_comparador16.vhd tb_FullAdder.vhd tb_HalfAdder.vhd tb_Inc16.vhd tb_inversor16.vhd tb_zerador16.vhd tb_HalfAdder.vhd \u00b6 Note que na simula\u00e7\u00e3o do HalfAdder n\u00e3o testamos um dos casos de entrada: 1 + 1 , esse teste est\u00e1 incompleto. Vamos corrigir isso! O arquivo tb_HalfAdder faz a inclus\u00e3o do m\u00f3dulo HalfAdder (component e port map) instanciando esse m\u00f3dulo para uso. No arquivo \u00e9 criado est\u00edmulos na entrada do componente e verifica-se se a sa\u00edda est\u00e1 de acordo com o que deveria ser feito. modificando o arquivo \u00b6 Agora vamos modificar o arquivo para inserir o teste que est\u00e1 faltando: 1+1 , para isso inclua as linhas a seguir logo ap\u00f3s o teste 3: -- Teste: 4 -- 1 + 1 +inA <= '1'; inB<= '1'; +wait for 200 ps; +assert(soma = '0' and vaium = '1') report \"Falha em teste: 4\" severity error; Como isso funciona? Primeiro colocamos os valores desejados na entrada do componente: inA <= '1'; inB <= '1'; \u00e9 necess\u00e1rio aguardar um instante de tempo para que as portas l\u00f3gicas fiquem com a sa\u00edda est\u00e1vel (e para possibilitar a visualiza\u00e7\u00e3o na simula\u00e7\u00e3o): wait for 200 ps; Testando novamente \u00b6 Execute novamente a simula\u00e7\u00e3o com o modo --gui e verifique se o m\u00f3dulo est\u00e1 se comportando corretamente: soma = 0 e vaium = 1 . Warning Salve e submeta as altera\u00e7\u00f5es para o remote , apenas uma pessoa do grupo deve realizar isso.","title":"Lab 7: Visualizando simula\u00e7\u00e3o"},{"location":"ula-Lab-2/#lab-7-visualizando-simulacao","text":"Trabalhando em grupo Realizar o lab em trio \u00c9 muito dif\u00edcil sabermos porque uma implementa\u00e7\u00e3o em VHDL n\u00e3o funciona, atualmente o fluxo \u00e9: transcreve para VHDL o componente; testa; n\u00e3o funcionou volta para o VHDL; testa.... Ser\u00e1 que n\u00e3o existe uma forma de conseguirmos visualizar o resultado do teste e com isso mudarmos a implementa\u00e7\u00e3o em VDHL? Sim existe! Para isso ser\u00e1 necess\u00e1rio invocarmos a parte gr\u00e1fica do modelsim. Na hora de invocarmos o script de teste ( B-UnidadeLogicaAritmetica/testeULA.py ) passe o par\u00e2metro --gui (ou -g ), como a seguir: $ python testeULA.py --gui Esse comando ir\u00e1 executar a simula\u00e7\u00e3o e abrir no software modelsim (toda a simula\u00e7\u00e3o \u00e9 realizada por esse software, mas estava sendo 'mascarada' pelos scripts de teste em py). Note Antes de continuar, o m\u00f3dulo do HalfAdder.vhd j\u00e1 deve est\u00e1 implementando e testado (na forma tradicional).","title":"Lab 7: Visualizando simula\u00e7\u00e3o"},{"location":"ula-Lab-2/#modelsim","text":"O modelsim n\u00e3o possui uma interface moderna, por\u00e9m \u00e9 o software de simula\u00e7\u00e3o de hardware mais completo e mais utilizado pela industria. Siga os passos a seguir para conseguirmos visualizarmos a forma de onda: Primeiramente devemos adicionar os sinais que desejamos visualizar, no caso do HalfAdder queremos ver suas entradas (a,b) e suas sa\u00eddas (soma, vaium). Para isso clique em wave : Tip Caso n\u00e3o possua a janela wave aberta, clique em File -> Wave e a janela ir\u00e1 aparecer. E depois selecione no menu das inst\u00e2ncias o m\u00f3dulo u1HalfAdder, com isso poderemos selecionar quais pinos/ sinais gostar\u00edamos de visualizar desse bloco. Arraste todos os sinais para o wave form : Resultando em: Agora podemos executar a simula\u00e7\u00e3o, na regi\u00e3o do script TCL execute o seguinte comando: vunit_run VSIM > vunit_run Podemos agora visualizar a forma de onda:","title":"modelsim"},{"location":"ula-Lab-2/#aprimorando-teste","text":"Testbench (bancada de teste) \u00e9 a forma utilizada para verificarmos se um projeto de HDL (VHDL, Verilog, ...) est\u00e1 certo, o testbench pode ser escrito em v\u00e1rias linguagens inclusive em VHDL. Os TestBenchs est\u00e3o localizados nas pastas dos projetos em: /tests/tst/ . No projeto C temos os seguintes testbenchs definidos (um para cada m\u00f3dulo a ser implementando): /tests/tst/ tb_Add16.vhd tb_ALU.vhd tb_comparador16.vhd tb_FullAdder.vhd tb_HalfAdder.vhd tb_Inc16.vhd tb_inversor16.vhd tb_zerador16.vhd","title":"Aprimorando teste"},{"location":"ula-Lab-2/#tb_halfaddervhd","text":"Note que na simula\u00e7\u00e3o do HalfAdder n\u00e3o testamos um dos casos de entrada: 1 + 1 , esse teste est\u00e1 incompleto. Vamos corrigir isso! O arquivo tb_HalfAdder faz a inclus\u00e3o do m\u00f3dulo HalfAdder (component e port map) instanciando esse m\u00f3dulo para uso. No arquivo \u00e9 criado est\u00edmulos na entrada do componente e verifica-se se a sa\u00edda est\u00e1 de acordo com o que deveria ser feito.","title":"tb_HalfAdder.vhd"},{"location":"ula-Lab-2/#modificando-o-arquivo","text":"Agora vamos modificar o arquivo para inserir o teste que est\u00e1 faltando: 1+1 , para isso inclua as linhas a seguir logo ap\u00f3s o teste 3: -- Teste: 4 -- 1 + 1 +inA <= '1'; inB<= '1'; +wait for 200 ps; +assert(soma = '0' and vaium = '1') report \"Falha em teste: 4\" severity error; Como isso funciona? Primeiro colocamos os valores desejados na entrada do componente: inA <= '1'; inB <= '1'; \u00e9 necess\u00e1rio aguardar um instante de tempo para que as portas l\u00f3gicas fiquem com a sa\u00edda est\u00e1vel (e para possibilitar a visualiza\u00e7\u00e3o na simula\u00e7\u00e3o): wait for 200 ps;","title":"modificando o arquivo"},{"location":"ula-Lab-2/#testando-novamente","text":"Execute novamente a simula\u00e7\u00e3o com o modo --gui e verifique se o m\u00f3dulo est\u00e1 se comportando corretamente: soma = 0 e vaium = 1 . Warning Salve e submeta as altera\u00e7\u00f5es para o remote , apenas uma pessoa do grupo deve realizar isso.","title":"Testando novamente"},{"location":"ula-Lab-3/","text":"Lab 8: ULA \u00b6 Trabalhando em grupo Realizar o lab em trio Antes de come\u00e7ar Toda vez que um novo projeto come\u00e7ar ser\u00e1 necess\u00e1rio realizar algumas configura\u00e7\u00f5es no reposit\u00f3rio do grupo, voc\u00eas devem seguir para o documento: Util/Come\u00e7ando novo Projeto e depois voltar para esse lab. N\u00e3o seguir sem realizar a etapa anterior. O objetivo desse laborat\u00f3rio \u00e9 o de trabalharmos com o controle dos sinais da ULA para entendermos as opera\u00e7\u00f5es da unidade de processamento do nosso computador. Programando FPGA com ULA Entendendo fun\u00e7\u00f5es das chaves e LEDs Controlando ULA para realizar opera\u00e7\u00f5es espec\u00edficas (exerc\u00edcios) Programando FPGA \u00b6 Com a FPGA plugada no PC e ligada, execute o script programFPGA.py da pasta do projeto C . Esse script ir\u00e1 realizar a programa\u00e7\u00e3o da FPGA com o hardware da Unidade L\u00f3gica Aritm\u00e9tica - ULA que voc\u00eas ter\u00e3o que implementar. Nesse exemplo os controles da ULA est\u00e3o mapeados para as chaves da FPGA, a sa\u00edda da ULA foi mapeada para LEDs: como ilustrado as figuras a seguir: Como isso \u00e9 feito em VHDL? De uma olhada no toplevel do projeto ( C-UnidadeLogicaAritmetica/src/TopLevel.vhd ) ula0: ALU port map ( x => x, Y => y, Zx => SW(0), Nx => SW(1), Zy => SW(2), Ny => SW(3), F => SW(4), No => SW(5), Zr => LEDR(8), Ng => LEDR(9), Saida(7 downto 0) => LEDR(7 downto 0), Saida(15 downto 8) => Open ); Note que a ULA que iremos desenvolver no projeto C tem 16 bits de largura, por\u00e9m como temos um limite de LEDs e bot\u00f5es na FPGA, estamos ignorando os valores mais significativos, sem afetar o projeto. Controlando ULA \u00b6 Com a FPGA programada podemos testar a ULA modificando seus sinais de controle. A seguir uma proposta de opera\u00e7\u00f5es l\u00f3gicas devem ser realizadas na FPGA, seus sinais de controle e resultado devem ser anotados nas tabelas. Tip O projeto FIXA as entradas da ULA com os valores: X = 0x73 Y = 0x5F Tarefa: out = X Configure os controles da ULA para fazer com que a sa\u00edda da ULA seja a entrada X Para isso voc\u00ea deve mexer nas chaves da FPGA e verificar a sa\u00edda nos leds. Tarefa: out = Y Configure os controles da ULA para fazer com que a sa\u00edda da ULA seja a entrada Y Tarefa: out = !Y Configure os controles da ULA para fazer com que a sa\u00edda da ULA seja a entrada a entrada Y negada Tarefa: out = 0 Fa\u00e7a com que a sa\u00edda da ULA seja 0 Tarefa: out = 1 Fa\u00e7a com que a sa\u00edda da ULA seja 1 Tarefa: out = -1 Fa\u00e7a com que a sa\u00edda da ULA seja -1 (em complemento de 2) Tarefa: out = X+Y Fa\u00e7a com que a sa\u00edda da ULA seja a entrada X + a entrada Y Tarefa (dif\u00edcil): out = X or Y Fa\u00e7a com que a sa\u00edda da ULA seja X ou Y Tarefa (dif\u00edcil): out = X - Y Fa\u00e7a com que a sa\u00edda da ULA seja a entrada X menos a entrada Y","title":"Lab 8: ULA"},{"location":"ula-Lab-3/#lab-8-ula","text":"Trabalhando em grupo Realizar o lab em trio Antes de come\u00e7ar Toda vez que um novo projeto come\u00e7ar ser\u00e1 necess\u00e1rio realizar algumas configura\u00e7\u00f5es no reposit\u00f3rio do grupo, voc\u00eas devem seguir para o documento: Util/Come\u00e7ando novo Projeto e depois voltar para esse lab. N\u00e3o seguir sem realizar a etapa anterior. O objetivo desse laborat\u00f3rio \u00e9 o de trabalharmos com o controle dos sinais da ULA para entendermos as opera\u00e7\u00f5es da unidade de processamento do nosso computador. Programando FPGA com ULA Entendendo fun\u00e7\u00f5es das chaves e LEDs Controlando ULA para realizar opera\u00e7\u00f5es espec\u00edficas (exerc\u00edcios)","title":"Lab 8: ULA"},{"location":"ula-Lab-3/#programando-fpga","text":"Com a FPGA plugada no PC e ligada, execute o script programFPGA.py da pasta do projeto C . Esse script ir\u00e1 realizar a programa\u00e7\u00e3o da FPGA com o hardware da Unidade L\u00f3gica Aritm\u00e9tica - ULA que voc\u00eas ter\u00e3o que implementar. Nesse exemplo os controles da ULA est\u00e3o mapeados para as chaves da FPGA, a sa\u00edda da ULA foi mapeada para LEDs: como ilustrado as figuras a seguir: Como isso \u00e9 feito em VHDL? De uma olhada no toplevel do projeto ( C-UnidadeLogicaAritmetica/src/TopLevel.vhd ) ula0: ALU port map ( x => x, Y => y, Zx => SW(0), Nx => SW(1), Zy => SW(2), Ny => SW(3), F => SW(4), No => SW(5), Zr => LEDR(8), Ng => LEDR(9), Saida(7 downto 0) => LEDR(7 downto 0), Saida(15 downto 8) => Open ); Note que a ULA que iremos desenvolver no projeto C tem 16 bits de largura, por\u00e9m como temos um limite de LEDs e bot\u00f5es na FPGA, estamos ignorando os valores mais significativos, sem afetar o projeto.","title":"Programando FPGA"},{"location":"ula-Lab-3/#controlando-ula","text":"Com a FPGA programada podemos testar a ULA modificando seus sinais de controle. A seguir uma proposta de opera\u00e7\u00f5es l\u00f3gicas devem ser realizadas na FPGA, seus sinais de controle e resultado devem ser anotados nas tabelas. Tip O projeto FIXA as entradas da ULA com os valores: X = 0x73 Y = 0x5F Tarefa: out = X Configure os controles da ULA para fazer com que a sa\u00edda da ULA seja a entrada X Para isso voc\u00ea deve mexer nas chaves da FPGA e verificar a sa\u00edda nos leds. Tarefa: out = Y Configure os controles da ULA para fazer com que a sa\u00edda da ULA seja a entrada Y Tarefa: out = !Y Configure os controles da ULA para fazer com que a sa\u00edda da ULA seja a entrada a entrada Y negada Tarefa: out = 0 Fa\u00e7a com que a sa\u00edda da ULA seja 0 Tarefa: out = 1 Fa\u00e7a com que a sa\u00edda da ULA seja 1 Tarefa: out = -1 Fa\u00e7a com que a sa\u00edda da ULA seja -1 (em complemento de 2) Tarefa: out = X+Y Fa\u00e7a com que a sa\u00edda da ULA seja a entrada X + a entrada Y Tarefa (dif\u00edcil): out = X or Y Fa\u00e7a com que a sa\u00edda da ULA seja X ou Y Tarefa (dif\u00edcil): out = X - Y Fa\u00e7a com que a sa\u00edda da ULA seja a entrada X menos a entrada Y","title":"Controlando ULA"},{"location":"ula-Projeto-dicas/","text":"C - Dicas (A,B) \u00b6 Como n\u00e3o temos mais o hardware dispon\u00edvel, teremos que modificar os testes para podermos testar a novas funcionalidades da ULA. Modificar a ULA Modificar o arquivo: tests/tst/tb_ULA.vhd Alterar o component da ULA (para bater com a entity da ula) Alterar os testes existentes Testar Como fazeer? Exemplo \u00b6 Imagine uma ALU em que foi implementado a seguinte funcionalidade: multiplicar um n\u00famero X por 2. As altera\u00e7\u00f5es necess\u00e1rias para esta opera\u00e7\u00e3o foram feitas no arquivo da ULA (VHDL) do grupo. No entanto, o teste implementado da ULA n\u00e3o verifica esta nova funcionalidade. Neste exemplo iremos ver como alterar o teste para validar esta nova fun\u00e7\u00e3o. O teste de interesse \u00e9 o arquivo presente em C-UnidadeLogicaAritimetica/tests/tst/tb_ALU.vhd . A sigla tb significa Testbench (bancada de testes). Note que o arquivo \u00e9 um arquivo em VHDL como qualquer outro, tendo como diferencial, o fato de utilizar a biblioteca vunit_lib que permite carregar alguns recursos para teste, olhe que na arquitetura, deve-se incluir a declara\u00e7\u00e3o do componente a ser testado e em seguida o mesmo \u00e9 instanciado (igual quando feito um port-map). Observe tamb\u00e9m que temos tamb\u00e9m alguns sinais ( signals ), estes s\u00e3o utilizados para alterar os valores que estamos colocando no componente a ser testado. A seguir, uma grande diferen\u00e7a do VHDL convencional que estamos acostumados se d\u00e1 no seguinte trecho: main : process begin ... end Esta diretiva process indica que o que est\u00e1 contido no begin-end ser\u00e1 executado sequencialmente diferente do que viemos usando que \u00e9 execu\u00e7\u00e3o combinacional. Voc\u00eas ter\u00e3o uma aula dedicada ao uso de l\u00f3gica sequencial, por enquanto, apenas pense que cada linha a seguir \u00e9 executada ap\u00f3s a outra. A seguir, teremos v\u00e1rios trechos de c\u00f3digos separados, cada trecho \u00e9 um teste sendo feito. -- Teste: 1 inX <= \"0000000000000000\" ; inY <= \"1111111111111111\" ; inZX <= '1' ; inNX <= '0' ; inZY <= '1' ; inNY <= '0' ; inF <= '1' ; inNO <= '0' ; wait for 100 ps ; assert ( outZR = '1' and outNG = '0' and outSaida = \"0000000000000000\" ) report \"Falha em teste: 1\" severity error ; Por exemplo, neste teste acima, \u00e9 colocado 0 na entrada X e -1 na entrada Y. \u00c9 zerado o X, n\u00e3o negado o X, zerado Y e n\u00e3o negado Y. Escolhido opera\u00e7\u00e3o de soma, e n\u00e3o inverte a sa\u00edda. Ele verifica se obtem na sa\u00edda o resultado 0, assim como flag do zerador ativo e flag de negativo desligado. Enfim, como pode-se ver colocamos as entradas desejadas e verificamos se a sa\u00edda \u00e9 a esperada por n\u00f3s. Caso n\u00e3o seja, o comando assert (condi\u00e7\u00e3o de teste) ir\u00e1 falhar e executar\u00e1 o comando report que reportar\u00e1 ao usu\u00e1rio uma falha com severidade de erro. No entanto, temos um problema a resolver, para poder incorporar a funcionalidade de multiplicar por 2, o projetista, decidiu alterar o MUX que existe no projeto da ALU para ser um seletor de 2 bits e portanto o sinal f agora possui 2 bits. Neste caso, teremos que alterar a declara\u00e7\u00e3o do componente referente ao sinal f f : in STD_LOGIC_VECTOR ( 1 downto 0 ); -- se 00 calcula x & y, 01 x + y, 10 x*2 E corrigir o sinal inF para 2 bits e todos os testes pre-existentes tamb\u00e9m ter\u00e3o que ser corrigidos! signal inF : STD_LOGIC_VECTOR ( 1 downto 0 ); `` Exemplo pro teste 1 ``` vhdl -- Teste: 1 inX <= \"0000000000000000\" ; inY <= \"1111111111111111\" ; inZX <= '1' ; inNX <= '0' ; inZY <= '1' ; inNY <= '0' ; inF <= \"01\" ; inNO <= '0' ; wait for 100 ps ; assert ( outZR = '1' and outNG = '0' and outSaida = \"0000000000000000\" ) report \"Falha em teste: 1\" severity error ; Feito isso agora vamos criar nossos testes para a funcionalidade outSaida = 2 * X. Colocando os testes no final do arquivo. Primeiro, testar 5 * 2 = 10. -- Teste: 20 - Testa 5 * 2= 10 inX <= \"0000000000000101\" ; inY <= \"1111111111111111\" ; inZX <= '0' ; inNX <= '0' ; inZY <= '0' ; inNY <= '0' ; inF <= \"10\" ; inNO <= '0' ; wait for 100 ps ; assert ( outZR = '0' and outNG = '0' and outSaida = \"0000000000001010\" ) report \"Falha em teste: 1\" severity error ; Colocamos X = 5 (em bin\u00e1rio). N\u00e3o zeramos X e escolhemos a op\u00e7\u00e3o correta no seletor f . Verificando o resultado outSaida = 10 (em bin\u00e1rio) e os flags. Depois vamos testar multiplica\u00e7\u00e3o por zero. -- Teste: 21 - Testa 0 * 2 = 0 inX <= \"0000000000000000\" ; inY <= \"1111111111111111\" ; inZX <= '0' ; inNX <= '0' ; inZY <= '0' ; inNY <= '0' ; inF <= \"10\" ; inNO <= '0' ; wait for 100 ps ; assert ( outZR = '1' and outNG = '0' and outSaida = \"0000000000000000\" ) report \"Falha em teste: 1\" severity error ; Enfim poderiamos fazer mais testes, envolvendo outros casos diferentes. O ideal \u00e9 criar testes que peguem todas as possibilidades razoavelmente diferentes, note que se for fazer para todas possibilidades, s\u00f3 levando em conta o X teriamos 2^16 possibilidades... \u00e9 invi\u00e1vel. Por isso teste apenas casos de borda , ou seja, quando o comportamento da sa\u00edda pode mudar razoavelmente do normal (por isso testamos o zero aqui!) Com isso feito, ao rodar o teste novamente na pasta, se a funcionalidade tiver sido implementada com sucesso, devemos obter um teste com exito! Parab\u00e9ns!","title":"C - Dicas (A,B)"},{"location":"ula-Projeto-dicas/#c-dicas-ab","text":"Como n\u00e3o temos mais o hardware dispon\u00edvel, teremos que modificar os testes para podermos testar a novas funcionalidades da ULA. Modificar a ULA Modificar o arquivo: tests/tst/tb_ULA.vhd Alterar o component da ULA (para bater com a entity da ula) Alterar os testes existentes Testar","title":"C - Dicas (A,B)"},{"location":"ula-Projeto-dicas/#como-fazeer-exemplo","text":"Imagine uma ALU em que foi implementado a seguinte funcionalidade: multiplicar um n\u00famero X por 2. As altera\u00e7\u00f5es necess\u00e1rias para esta opera\u00e7\u00e3o foram feitas no arquivo da ULA (VHDL) do grupo. No entanto, o teste implementado da ULA n\u00e3o verifica esta nova funcionalidade. Neste exemplo iremos ver como alterar o teste para validar esta nova fun\u00e7\u00e3o. O teste de interesse \u00e9 o arquivo presente em C-UnidadeLogicaAritimetica/tests/tst/tb_ALU.vhd . A sigla tb significa Testbench (bancada de testes). Note que o arquivo \u00e9 um arquivo em VHDL como qualquer outro, tendo como diferencial, o fato de utilizar a biblioteca vunit_lib que permite carregar alguns recursos para teste, olhe que na arquitetura, deve-se incluir a declara\u00e7\u00e3o do componente a ser testado e em seguida o mesmo \u00e9 instanciado (igual quando feito um port-map). Observe tamb\u00e9m que temos tamb\u00e9m alguns sinais ( signals ), estes s\u00e3o utilizados para alterar os valores que estamos colocando no componente a ser testado. A seguir, uma grande diferen\u00e7a do VHDL convencional que estamos acostumados se d\u00e1 no seguinte trecho: main : process begin ... end Esta diretiva process indica que o que est\u00e1 contido no begin-end ser\u00e1 executado sequencialmente diferente do que viemos usando que \u00e9 execu\u00e7\u00e3o combinacional. Voc\u00eas ter\u00e3o uma aula dedicada ao uso de l\u00f3gica sequencial, por enquanto, apenas pense que cada linha a seguir \u00e9 executada ap\u00f3s a outra. A seguir, teremos v\u00e1rios trechos de c\u00f3digos separados, cada trecho \u00e9 um teste sendo feito. -- Teste: 1 inX <= \"0000000000000000\" ; inY <= \"1111111111111111\" ; inZX <= '1' ; inNX <= '0' ; inZY <= '1' ; inNY <= '0' ; inF <= '1' ; inNO <= '0' ; wait for 100 ps ; assert ( outZR = '1' and outNG = '0' and outSaida = \"0000000000000000\" ) report \"Falha em teste: 1\" severity error ; Por exemplo, neste teste acima, \u00e9 colocado 0 na entrada X e -1 na entrada Y. \u00c9 zerado o X, n\u00e3o negado o X, zerado Y e n\u00e3o negado Y. Escolhido opera\u00e7\u00e3o de soma, e n\u00e3o inverte a sa\u00edda. Ele verifica se obtem na sa\u00edda o resultado 0, assim como flag do zerador ativo e flag de negativo desligado. Enfim, como pode-se ver colocamos as entradas desejadas e verificamos se a sa\u00edda \u00e9 a esperada por n\u00f3s. Caso n\u00e3o seja, o comando assert (condi\u00e7\u00e3o de teste) ir\u00e1 falhar e executar\u00e1 o comando report que reportar\u00e1 ao usu\u00e1rio uma falha com severidade de erro. No entanto, temos um problema a resolver, para poder incorporar a funcionalidade de multiplicar por 2, o projetista, decidiu alterar o MUX que existe no projeto da ALU para ser um seletor de 2 bits e portanto o sinal f agora possui 2 bits. Neste caso, teremos que alterar a declara\u00e7\u00e3o do componente referente ao sinal f f : in STD_LOGIC_VECTOR ( 1 downto 0 ); -- se 00 calcula x & y, 01 x + y, 10 x*2 E corrigir o sinal inF para 2 bits e todos os testes pre-existentes tamb\u00e9m ter\u00e3o que ser corrigidos! signal inF : STD_LOGIC_VECTOR ( 1 downto 0 ); `` Exemplo pro teste 1 ``` vhdl -- Teste: 1 inX <= \"0000000000000000\" ; inY <= \"1111111111111111\" ; inZX <= '1' ; inNX <= '0' ; inZY <= '1' ; inNY <= '0' ; inF <= \"01\" ; inNO <= '0' ; wait for 100 ps ; assert ( outZR = '1' and outNG = '0' and outSaida = \"0000000000000000\" ) report \"Falha em teste: 1\" severity error ; Feito isso agora vamos criar nossos testes para a funcionalidade outSaida = 2 * X. Colocando os testes no final do arquivo. Primeiro, testar 5 * 2 = 10. -- Teste: 20 - Testa 5 * 2= 10 inX <= \"0000000000000101\" ; inY <= \"1111111111111111\" ; inZX <= '0' ; inNX <= '0' ; inZY <= '0' ; inNY <= '0' ; inF <= \"10\" ; inNO <= '0' ; wait for 100 ps ; assert ( outZR = '0' and outNG = '0' and outSaida = \"0000000000001010\" ) report \"Falha em teste: 1\" severity error ; Colocamos X = 5 (em bin\u00e1rio). N\u00e3o zeramos X e escolhemos a op\u00e7\u00e3o correta no seletor f . Verificando o resultado outSaida = 10 (em bin\u00e1rio) e os flags. Depois vamos testar multiplica\u00e7\u00e3o por zero. -- Teste: 21 - Testa 0 * 2 = 0 inX <= \"0000000000000000\" ; inY <= \"1111111111111111\" ; inZX <= '0' ; inNX <= '0' ; inZY <= '0' ; inNY <= '0' ; inF <= \"10\" ; inNO <= '0' ; wait for 100 ps ; assert ( outZR = '1' and outNG = '0' and outSaida = \"0000000000000000\" ) report \"Falha em teste: 1\" severity error ; Enfim poderiamos fazer mais testes, envolvendo outros casos diferentes. O ideal \u00e9 criar testes que peguem todas as possibilidades razoavelmente diferentes, note que se for fazer para todas possibilidades, s\u00f3 levando em conta o X teriamos 2^16 possibilidades... \u00e9 invi\u00e1vel. Por isso teste apenas casos de borda , ou seja, quando o comportamento da sa\u00edda pode mudar razoavelmente do normal (por isso testamos o zero aqui!) Com isso feito, ao rodar o teste novamente na pasta, se a funcionalidade tiver sido implementada com sucesso, devemos obter um teste com exito! Parab\u00e9ns!","title":"Como fazeer? Exemplo"},{"location":"ula-Projeto/","text":"C - ULA \u00b6 Entrega 17/3 - Ter\u00e7a Neste projeto seu grupo ter\u00e1 que desenvolver os componentes para a implementa\u00e7\u00e3o de uma unidade l\u00f3gica e aritm\u00e9tica (ULA) de 16 bit (proposta pelo livro texto) que ser\u00e1 capaz de realizar opera\u00e7\u00f5es bin\u00e1rias muito simples por\u00e9m que possibilitar\u00e1 realizarmos muitas coisas! Warning O grupo deve eleger um novo scrum master para essa entrega. Note Nas discuss\u00f5es com o grupo, o scrum master dever\u00e1 definir os m\u00f3dulos que cada integrante ir\u00e1 desenvolver. Crie uma rotina para commits e pull-requests. Tip Voc\u00ea \u00e9 Scrum Master e n\u00e3o sabe por onde come\u00e7ar? De uma olhada nessas dicas: Vixi! Sou Scrum Master Tip Sempre teste os m\u00f3dulos e verifique se est\u00e1 funcionando como o esperado. Instru\u00e7\u00f5es \u00b6 A pasta do projeto D, no reposit\u00f3rio Z01, possui a seguinte estrutura: /C-ULA testeULA.py programFPGA.py /Quartus /src /rtl *.vhd /tests /tst *.vhd Quartus: Projeto Quartus que faz uso dos arquivos VHDL localizados em src/rtl/*.vhd; testeULA.py: Scripts em python que automatizam a execu\u00e7\u00e3o dos testes; src/rtl/*.vhd: Arquivos VHDL que ser\u00e3o implementados pelo grupo; tests/tst/*.vhd: Arquivos VHDL que realizam o teste l\u00f3gico nos arquivos do rtl. Executando o Script de Teste \u00b6 Abra o terminal na pasta C-UnidadeLogicaAritmetica/ e execute o script python localizado nessa pasta: $ ./testeULA.py O mesmo ir\u00e1 compilar os arquivos src/rtl/*.vhd e executar os testes unit\u00e1rios em cada um deles. Nesse momento do teste, como os m\u00f3dulos n\u00e3o est\u00e3o implementados, o resultado dever\u00e1 ser falho. Esse comando executa um teste unit\u00e1rio em cada um dos m\u00f3dulos, verificando se sua implementa\u00e7\u00e3o est\u00e1 correta. O resultado \u00e9 exibido na tela como : pass ou fail . O que deve ser feito: \u00b6 Al\u00e9m de implementar os m\u00f3dulos, deve-se gerar uma imagem com a forma de onda de cada um desses m\u00f3dulos. Para cada nova implementa\u00e7\u00e3o deve-se criar um novo branch e remover o coment\u00e1rio do arquivo: tests/config.txt somente o m\u00f3dulo que est\u00e1 sendo implementado. Note que \u00e9 poss\u00edvel reaproveitar, via port map , os m\u00f3dulos do projeto anterior (C). Esses m\u00f3dulos anteriores j\u00e1 est\u00e3o inclu\u00eddos automaticamente (pelo script) na compila\u00e7\u00e3o dos m\u00f3dulos do projeto C. M\u00f3dulos \u00b6 Note Esses arquivos est\u00e3o localizados em C-UnidadeLogicaAritmetica/src/rtl/ Deve-se implementar os seguintes circuitos combinacionais: HalfAdder Arquivo : HalfAdder.vhd Descri\u00e7\u00e3o : Adiciona dois bits que resulta em um bit de soma e outro de carry out. Depend\u00eancia : N\u00e3o tem. FullAdder Arquivo : FullAdder.vhd Descri\u00e7\u00e3o : Adiciona tr\u00eas bits, dois referentes \u00e0s entradas e o outro referente ao carry in. O resultado \u00e9 um bit com a soma e outro com o carry out. Depend\u00eancia : N\u00e3o tem. Add16 Arquivo : Add16.vhd Descri\u00e7\u00e3o : Adiciona dois vetores de 16 bits resultando em um vetor de 16 bits (sem carry out do bit mais significativo - MSB). Depend\u00eancia : FullAdder Note Deve utilizar o FullAdder via port map. Inc16 Arquivo : Inc16.vhd Descri\u00e7\u00e3o : Adiciona '1' a um vetor de 16 bits resultando em um vetor de 16 bits (sem carry out). Depend\u00eancia : Add16 Note Deve utilizar o add16 via port map . Inversor16 Arquivo : Inversor16.vhd Descri\u00e7\u00e3o : Inverte um vetor de entrada quando o bit de controle n (nx ou ny) for igual a '1', e n\u00e3o modifica o vetor de entrada caso contr\u00e1rio. O resultado \u00e9 um novo vetor de 16 bits. Depend\u00eancia : N\u00e3o tem. Zerador16 Arquivo : Zerador16.vhd Descri\u00e7\u00e3o : Zera um vetor de entrada quando o bit de controle z (zx ou zy) for igual a '1'. N\u00e3o modifica o vetor de entrada se o bit for '0'. O resultado \u00e9 um novo vetor de 16 bits. Depend\u00eancia : N\u00e3o tem. Comparador16 Arquivo : Comparador16.vhd Descri\u00e7\u00e3o : Verifica se o vetor de sa\u00edda (16 bits) \u00e9 igual a zero ( zr ) e se menor que Zero ( ng ). Caso igual a zero, faz com que o sinal zr seja igual a '1' e caso contr\u00e1rio '0'. Se o sinal de entrada for negativo faz com que ng receba '1' e '0' caso contr\u00e1rio. Depend\u00eancia : N\u00e3o tem. Pseudo c\u00f3digo : if ( a == 0 ): zr = 1 else : zr = 0 if ( a < 0 ): ng = 1 else : ng = 0 ALU Arquivo : ALU.vhd Descri\u00e7\u00e3o : A entidade que faz o mapeamento de todas as demais, interligando os blocos (zerador, comparador, inversor, Add ....) em um \u00fanico bloco. Depend\u00eancia : Comparador16 , Zerador16 , Inversor16 , Add16 , Note Deve utilizar os m\u00f3dulos via via port map . Para implementar a ALU ser\u00e1 necess\u00e1rio usar os blocos desenvolvidos neste projeto e os blocos desenvolvidos no projeto anterior: And16 , Mux16 . O script de compila\u00e7\u00e3o e teste j\u00e1 faz a inclus\u00e3o deles. A arquitetura da ULA pode ser vista abaixo: Forma de onda \u00b6 Para cada teste realizado, deve-se carregar a interface gr\u00e1fica e tirar um print da forma de onda do m\u00f3dulo com os testes aplicados a ele (LAB-7). Essa imagem deve ser salva na mesma pasta dos arquivos VHDL (src/rtl/) e com o mesmo nome dos m\u00f3dulos. A pasta no final do projeto deve possuir os seguintes arquivos: /src/rtl/ Add16.vhd Add16.png ALU.vhd ALU.png Comparador16.vhd Comparador16.png FullAdder.vhd FullAdder.png HalfAdder.vhd HalfAdder.png Inc16.vhd Inc16.png Inversor16.vhd Inversor16.png Zerador16.vhd Zerador16.png Testando em HW \u00b6 Para testar os m\u00f3dulos em hardware, deve-se abrir o projeto ( C-UnidadeLogicaAritmetica/Quartus ). Ele j\u00e1 inclui todos os m\u00f3dulos desta entrega e tamb\u00e9m os m\u00f3dulos da entrega passada. O arquivo localizado em /rtl/toplevel.vhd j\u00e1 faz o mapeamento dos pinos da FPGA para os pinos da ULA. Para testar no hardware basta compilar e programar a FPGA. Rubricas para avalia\u00e7\u00e3o de projetos \u00b6 Cada integrante do grupo ir\u00e1 receber duas notas: uma referente ao desenvolvimento total do projeto (Projeto) e outra referente a sua participa\u00e7\u00e3o individual no grupo (que depende do seu papel). Projeto \u00b6 Warning N\u00e3o fazer rubrica A e B na master, criar um novo branch para isso! Conceito A - Modifique a ULA adicionando a opera\u00e7\u00e3o de shift left/right - Modifique o toplevel para mostrar o resultado da ULA nos displays de 7s (em hexa) B - Modifique a ULA adicionando o sinal de estouro da soma (carry) a sa\u00edda da ULA - Modifique a ULA adicionando a opera\u00e7\u00e3o: X xor Y C - Configurou o travis para testar o projeto - Todos os modulos implementando e passam nos testes - Faz reaproveitamentos dos m\u00f3dulos via port map sempre que poss\u00edvel - Possui a forma de onda de todos os m\u00f3dulos (.png). - Compila no Quartus a ULA do grupo e fez um v\u00eddeo demonstrando o seu funcionamento (FPGA). D - Implementou todos os m\u00f3dulos menos a ULA. I - N\u00e3o implementou os m\u00f3dulos Add16, ULA, Comparador, FullAdder, HalfAdder, Inc16, Inversosr, Zerador. Note Para os conceitos B e A, o grupo deve gravar um v\u00eddeo da FPGA demonstrando que as modifica\u00e7\u00f5es funcionam. Para os conceitos B e A, o grupo deve modificar o teste da ULA para que comprove o funcionamento dos recursos adicionados (sinais, opera\u00e7\u00f5es), ou seja, testa-los tentando abordar todos os casos comuns de uso. Os conceitos s\u00e3o incrementais: primeiro deve atingir o C B A. Desenvolvedor e Scrum Master \u00b6 As rubricas a serem seguidas ser\u00e3o comuns a todos os projeto e est\u00e1 descrito no link: Rubricas Scrum e Desenvolvedor","title":"C - ULA"},{"location":"ula-Projeto/#c-ula","text":"Entrega 17/3 - Ter\u00e7a Neste projeto seu grupo ter\u00e1 que desenvolver os componentes para a implementa\u00e7\u00e3o de uma unidade l\u00f3gica e aritm\u00e9tica (ULA) de 16 bit (proposta pelo livro texto) que ser\u00e1 capaz de realizar opera\u00e7\u00f5es bin\u00e1rias muito simples por\u00e9m que possibilitar\u00e1 realizarmos muitas coisas! Warning O grupo deve eleger um novo scrum master para essa entrega. Note Nas discuss\u00f5es com o grupo, o scrum master dever\u00e1 definir os m\u00f3dulos que cada integrante ir\u00e1 desenvolver. Crie uma rotina para commits e pull-requests. Tip Voc\u00ea \u00e9 Scrum Master e n\u00e3o sabe por onde come\u00e7ar? De uma olhada nessas dicas: Vixi! Sou Scrum Master Tip Sempre teste os m\u00f3dulos e verifique se est\u00e1 funcionando como o esperado.","title":"C - ULA"},{"location":"ula-Projeto/#instrucoes","text":"A pasta do projeto D, no reposit\u00f3rio Z01, possui a seguinte estrutura: /C-ULA testeULA.py programFPGA.py /Quartus /src /rtl *.vhd /tests /tst *.vhd Quartus: Projeto Quartus que faz uso dos arquivos VHDL localizados em src/rtl/*.vhd; testeULA.py: Scripts em python que automatizam a execu\u00e7\u00e3o dos testes; src/rtl/*.vhd: Arquivos VHDL que ser\u00e3o implementados pelo grupo; tests/tst/*.vhd: Arquivos VHDL que realizam o teste l\u00f3gico nos arquivos do rtl.","title":"Instru\u00e7\u00f5es"},{"location":"ula-Projeto/#executando-o-script-de-teste","text":"Abra o terminal na pasta C-UnidadeLogicaAritmetica/ e execute o script python localizado nessa pasta: $ ./testeULA.py O mesmo ir\u00e1 compilar os arquivos src/rtl/*.vhd e executar os testes unit\u00e1rios em cada um deles. Nesse momento do teste, como os m\u00f3dulos n\u00e3o est\u00e3o implementados, o resultado dever\u00e1 ser falho. Esse comando executa um teste unit\u00e1rio em cada um dos m\u00f3dulos, verificando se sua implementa\u00e7\u00e3o est\u00e1 correta. O resultado \u00e9 exibido na tela como : pass ou fail .","title":"Executando o Script de Teste"},{"location":"ula-Projeto/#o-que-deve-ser-feito","text":"Al\u00e9m de implementar os m\u00f3dulos, deve-se gerar uma imagem com a forma de onda de cada um desses m\u00f3dulos. Para cada nova implementa\u00e7\u00e3o deve-se criar um novo branch e remover o coment\u00e1rio do arquivo: tests/config.txt somente o m\u00f3dulo que est\u00e1 sendo implementado. Note que \u00e9 poss\u00edvel reaproveitar, via port map , os m\u00f3dulos do projeto anterior (C). Esses m\u00f3dulos anteriores j\u00e1 est\u00e3o inclu\u00eddos automaticamente (pelo script) na compila\u00e7\u00e3o dos m\u00f3dulos do projeto C.","title":"O que deve ser feito:"},{"location":"ula-Projeto/#modulos","text":"Note Esses arquivos est\u00e3o localizados em C-UnidadeLogicaAritmetica/src/rtl/ Deve-se implementar os seguintes circuitos combinacionais: HalfAdder Arquivo : HalfAdder.vhd Descri\u00e7\u00e3o : Adiciona dois bits que resulta em um bit de soma e outro de carry out. Depend\u00eancia : N\u00e3o tem. FullAdder Arquivo : FullAdder.vhd Descri\u00e7\u00e3o : Adiciona tr\u00eas bits, dois referentes \u00e0s entradas e o outro referente ao carry in. O resultado \u00e9 um bit com a soma e outro com o carry out. Depend\u00eancia : N\u00e3o tem. Add16 Arquivo : Add16.vhd Descri\u00e7\u00e3o : Adiciona dois vetores de 16 bits resultando em um vetor de 16 bits (sem carry out do bit mais significativo - MSB). Depend\u00eancia : FullAdder Note Deve utilizar o FullAdder via port map. Inc16 Arquivo : Inc16.vhd Descri\u00e7\u00e3o : Adiciona '1' a um vetor de 16 bits resultando em um vetor de 16 bits (sem carry out). Depend\u00eancia : Add16 Note Deve utilizar o add16 via port map . Inversor16 Arquivo : Inversor16.vhd Descri\u00e7\u00e3o : Inverte um vetor de entrada quando o bit de controle n (nx ou ny) for igual a '1', e n\u00e3o modifica o vetor de entrada caso contr\u00e1rio. O resultado \u00e9 um novo vetor de 16 bits. Depend\u00eancia : N\u00e3o tem. Zerador16 Arquivo : Zerador16.vhd Descri\u00e7\u00e3o : Zera um vetor de entrada quando o bit de controle z (zx ou zy) for igual a '1'. N\u00e3o modifica o vetor de entrada se o bit for '0'. O resultado \u00e9 um novo vetor de 16 bits. Depend\u00eancia : N\u00e3o tem. Comparador16 Arquivo : Comparador16.vhd Descri\u00e7\u00e3o : Verifica se o vetor de sa\u00edda (16 bits) \u00e9 igual a zero ( zr ) e se menor que Zero ( ng ). Caso igual a zero, faz com que o sinal zr seja igual a '1' e caso contr\u00e1rio '0'. Se o sinal de entrada for negativo faz com que ng receba '1' e '0' caso contr\u00e1rio. Depend\u00eancia : N\u00e3o tem. Pseudo c\u00f3digo : if ( a == 0 ): zr = 1 else : zr = 0 if ( a < 0 ): ng = 1 else : ng = 0 ALU Arquivo : ALU.vhd Descri\u00e7\u00e3o : A entidade que faz o mapeamento de todas as demais, interligando os blocos (zerador, comparador, inversor, Add ....) em um \u00fanico bloco. Depend\u00eancia : Comparador16 , Zerador16 , Inversor16 , Add16 , Note Deve utilizar os m\u00f3dulos via via port map . Para implementar a ALU ser\u00e1 necess\u00e1rio usar os blocos desenvolvidos neste projeto e os blocos desenvolvidos no projeto anterior: And16 , Mux16 . O script de compila\u00e7\u00e3o e teste j\u00e1 faz a inclus\u00e3o deles. A arquitetura da ULA pode ser vista abaixo:","title":"M\u00f3dulos"},{"location":"ula-Projeto/#forma-de-onda","text":"Para cada teste realizado, deve-se carregar a interface gr\u00e1fica e tirar um print da forma de onda do m\u00f3dulo com os testes aplicados a ele (LAB-7). Essa imagem deve ser salva na mesma pasta dos arquivos VHDL (src/rtl/) e com o mesmo nome dos m\u00f3dulos. A pasta no final do projeto deve possuir os seguintes arquivos: /src/rtl/ Add16.vhd Add16.png ALU.vhd ALU.png Comparador16.vhd Comparador16.png FullAdder.vhd FullAdder.png HalfAdder.vhd HalfAdder.png Inc16.vhd Inc16.png Inversor16.vhd Inversor16.png Zerador16.vhd Zerador16.png","title":"Forma de onda"},{"location":"ula-Projeto/#testando-em-hw","text":"Para testar os m\u00f3dulos em hardware, deve-se abrir o projeto ( C-UnidadeLogicaAritmetica/Quartus ). Ele j\u00e1 inclui todos os m\u00f3dulos desta entrega e tamb\u00e9m os m\u00f3dulos da entrega passada. O arquivo localizado em /rtl/toplevel.vhd j\u00e1 faz o mapeamento dos pinos da FPGA para os pinos da ULA. Para testar no hardware basta compilar e programar a FPGA.","title":"Testando em HW"},{"location":"ula-Projeto/#rubricas-para-avaliacao-de-projetos","text":"Cada integrante do grupo ir\u00e1 receber duas notas: uma referente ao desenvolvimento total do projeto (Projeto) e outra referente a sua participa\u00e7\u00e3o individual no grupo (que depende do seu papel).","title":"Rubricas para avalia\u00e7\u00e3o de projetos"},{"location":"ula-Projeto/#projeto","text":"Warning N\u00e3o fazer rubrica A e B na master, criar um novo branch para isso! Conceito A - Modifique a ULA adicionando a opera\u00e7\u00e3o de shift left/right - Modifique o toplevel para mostrar o resultado da ULA nos displays de 7s (em hexa) B - Modifique a ULA adicionando o sinal de estouro da soma (carry) a sa\u00edda da ULA - Modifique a ULA adicionando a opera\u00e7\u00e3o: X xor Y C - Configurou o travis para testar o projeto - Todos os modulos implementando e passam nos testes - Faz reaproveitamentos dos m\u00f3dulos via port map sempre que poss\u00edvel - Possui a forma de onda de todos os m\u00f3dulos (.png). - Compila no Quartus a ULA do grupo e fez um v\u00eddeo demonstrando o seu funcionamento (FPGA). D - Implementou todos os m\u00f3dulos menos a ULA. I - N\u00e3o implementou os m\u00f3dulos Add16, ULA, Comparador, FullAdder, HalfAdder, Inc16, Inversosr, Zerador. Note Para os conceitos B e A, o grupo deve gravar um v\u00eddeo da FPGA demonstrando que as modifica\u00e7\u00f5es funcionam. Para os conceitos B e A, o grupo deve modificar o teste da ULA para que comprove o funcionamento dos recursos adicionados (sinais, opera\u00e7\u00f5es), ou seja, testa-los tentando abordar todos os casos comuns de uso. Os conceitos s\u00e3o incrementais: primeiro deve atingir o C B A.","title":"Projeto"},{"location":"ula-Projeto/#desenvolvedor-e-scrum-master","text":"As rubricas a serem seguidas ser\u00e3o comuns a todos os projeto e est\u00e1 descrito no link: Rubricas Scrum e Desenvolvedor","title":"Desenvolvedor e Scrum Master"},{"location":"ula-lab-4/","text":"Lab 9: Pequena CPU \u00b6 Sugest\u00e3o de trabalho Cada um faz na sua m\u00e1quina simultaneamente com os demais integrantes do grupo, discutindo no v\u00eddeo. Um integrante faz na sua m\u00e1quina e compartilha a tela com os demais (todos comentam o mesmo c\u00f3digo) Tempo Tempo estimando no lab: 15 min Come\u00e7ando \u00b6 Para n\u00e3o perdemos tempo com o git, esse lab est\u00e1 dispon\u00edvel em um novo reposit\u00f3rio, voc\u00eas podem ou clonar direto ou realizar um fork. Para come\u00e7ar a trabalhar, clone o reposit\u00f3rio para sua m\u00e1quina: cd ~ git clone https://github.com/Insper/Elementos-Lab10 Lab \u00b6 O objetivo desse lab \u00e9 o de come\u00e7armos entender como a ULA pode ser utilizada por um programa para realizar a\u00e7\u00f5es. Em CPUs a ULA \u00e9 controlada por um bloco chamado de Unidade de Controle ( control unit ), que \u00e9 respons\u00e1vel por interpretar as instru\u00e7\u00f5es e comandar a ULA! Para isso vamos usar a ULA proposta pelo curso (a que voc\u00eas est\u00e3o fazendo) em uma arquitetura de CPU muito simples, mas que servir\u00e1 de exemplo (nosso Z01.1 n\u00e3o ser\u00e1 assim). Essa arquitetura de CPU possui uma entrada do usu\u00e1rio (que pode ser por exemplo as chaves da placa) conectada a entrada Y da ULA e uma sa\u00edda (que pode ser os LEDs) conectada a sa\u00edda (out), a entrada X \u00e9 conectada a um registrador que recebe o valor da sa\u00edda da ULA. Nessa arquitetura fict\u00edcia vamos trabalhar com o conceito de registrador acumulador, onde o resultado da ULA ser\u00e1 sempre salvo no REG_C . Note Registrador \u00e9 o termo utilizado para uma unidade simples de mem\u00f3ria capaz de armazenar apenas uma unidade de dados (nesse caso 16bits). Nesse caso, a cada opera\u00e7\u00e3o do sistema (clock) o registrador salvo o resultado da ULA. Tip O REG_C guarda um resultado da opera\u00e7\u00e3o da ULA at\u00e9 a pr\u00f3xima instru\u00e7\u00e3o O diagrama a seguir ilustra a Arquitetura descrita anteriormente: Control Unit \u00b6 A unidade de controle (UC) \u00e9 respons\u00e1vel por ler as instru\u00e7\u00f5es a serem executadas (que est\u00e3o em bin\u00e1rio) e comandar toda a CPU para executar o que deve ser feito. Nesse exemplo fict\u00edcio a UC comanda apenas a ULA, mas ela poderia controlar outras coisas tamb\u00e9m. Programa \u00b6 O programa nesse caso \u00e9 uma palavra de 4 bits de largura que descreve qual opera\u00e7\u00e3o deve ser realizada na CPU (linguagem de m\u00e1quina), nessa nossa CPU tempos as seguintes opera\u00e7\u00f5es definidas: Linguagem de maquina Instru\u00e7\u00e3o OP CODE 0000 REG_C = REG_C nop 0001 REG_C = 0 mov 0,C 1000 REG_C = ! REG_C not C 1001 REG_C = REG_C + 1 add 1,C 1010 REG_C = REG_C + Y add Y,C 1011 REG_C = REG_C - 1 sub 1,C Tip OP CODE \u00e9 o termo usado para descrever uma instru\u00e7\u00e3o, programas escritos em assembly fazem uso de opcodes para facilitar a programa\u00e7\u00e3o. Exemplo \u00b6 Vamos pensar em um programa muito simples que faz o seguinte: Carrega 0 em REG_C REG_C + 1 O c\u00f3digo disso (em nasm , usando os opcodes) seria: mov 0 , C add 1 , C nop Tip nop = no operation, ou seja, n\u00e3o faz nada! CPUs de forma simplificada uma CPU possui dois estados de opera\u00e7\u00e3o, ou est\u00e1 executando alguma instru\u00e7\u00e3o ou est\u00e1 dormindo. Isso n\u00e3o \u00e9 bem verdade em hardware reais, uma CPU pode estar em outros estados, tais como esperando um resultado de uma opera\u00e7\u00e3o. Note Nosso nop \u00e9 implementando pelo comando que faz sair X como resultado da ULA, assim REG_C = REG_C , ou seja, n\u00e3o faz nada! (que modifica o resultado da sa\u00edda da CPU). Para fazermos isso, temos que ter a seguinte instru\u00e7\u00e3o em mem\u00f3ria: 0: 0001 <--- O Programa come\u00e7a na linha 0 1: 1001 | e a cada 'clock' executa para pr\u00f3xima linha 2: 0000 v Legal n\u00e9? Mas para isso funcionar, a Unidade de Controle deve ser capaz de ler a instru\u00e7\u00e3o (4 bits) e controlar a ULA para executar tal comando. Nesse lab ela j\u00e1 est\u00e1 implementada com as duas instru\u00e7\u00f5es anteriores ( mov 0,C , add 1,c ). Para testar o projeto executamos o comando: ./testeLab.py . O mais interessante \u00e9 rodar com -g e verificar a forma de onda... testando ./testeLab.py 1. Terminando o Control Unit \u00b6 Nossa primeira atividade nesse lab ser\u00e1 a de termina de implementar a Unidade de Controle, para possuir todas as instru\u00e7\u00f5es anteriores. Uma parte dela j\u00e1 foi implementada, mas s\u00f3 possui as instru\u00e7\u00f5es: mov 0,C , add 1,C e nop , vamos implementar as demais? Para isso ser\u00e1 necess\u00e1rio modificar o arquivo /src/ControlUnit.vhd , nele \u00e9 que est\u00e1 implementando a l\u00f3gica que traduz instru\u00e7\u00f5es em execu\u00e7\u00e3o no hardware. O control unit l\u00ea o a instru\u00e7\u00e3o que est\u00e1 salva na mem\u00f3ria ( op ) e aciona a ULA ( ula ) para realizar tal opera\u00e7\u00e3o. A sa\u00edda do controlUnit ( ula out std_logic_vector ) \u00e9 um vetor composto pelos sinais de controle da ula: [ zx , nx , zy , ny , f , no ]. entity controlunit is port ( op : in std_logic_vector ( 3 downto 0 ); -- Operacao ula : out std_logic_vector ( 5 downto 0 ) -- controle da ula -- [nx zx ny zy f n] ); end entity ; architecture rtl of controlunit is begin with op select ula <= \"101010\" when \"0001\" , \"011111\" when \"1001\" , \"001100\" when others ; end architecture ; Example Quando a instru\u00e7\u00e3o for 0001 ( mov 0,C ) o controlUnit ir\u00e1 acionar a ula: zx=1 , nx=0 , zy=1 , ny=1 , f=1 , no=0 para que a sua sa\u00edda seja 0. Modifique Voc\u00ea deve inserir as instru\u00e7\u00f5es que est\u00e3o faltando serem implementadas no ControlUnit ( not C , add Y,C , sub 1,C ). Consulte a tabela de opera\u00e7\u00f5es da ULA: https://insper.github.io/Z01.1/Teoria-ULA/ Antes de testar aplique o patch a seguir para inserirmos os novos comandos no teste do lab: git apply teste2.patch !!! tip \u00e9 necess\u00e1rio adicionar as tr\u00eas linhas a seguir no controlUnit.vhd e preencher \" \" com o controle da ULA. ```diff with op select ula <= \"101010\" when \"0001\", \"011111\" when \"1001\", + \" \" when \"1000\", + \" \" when \"1010\", + \" \" when \"1011\" \"001100\" when others; 2. Analisando CPU \u00b6 Discuta em grupo as limita\u00e7\u00f5es dessa nossa CPU, e o que poderia ser feito para melhorar: Essa CPU \u00e9 capaz de realizar qualquer tipo de c\u00e1lculo? Quais limita\u00e7\u00f5es voc\u00ea percebe nela? Temos condicionais? Como implementar .... Responda o formul\u00e1rio com a resposta do grupo ap\u00f3s discuss\u00e3o (pode ser uma resposta por grupo ou uma mais de uma, voc\u00eas que escolhem): Loading\u2026","title":"Lab 9: Pequena CPU"},{"location":"ula-lab-4/#lab-9-pequena-cpu","text":"Sugest\u00e3o de trabalho Cada um faz na sua m\u00e1quina simultaneamente com os demais integrantes do grupo, discutindo no v\u00eddeo. Um integrante faz na sua m\u00e1quina e compartilha a tela com os demais (todos comentam o mesmo c\u00f3digo) Tempo Tempo estimando no lab: 15 min","title":"Lab 9: Pequena CPU"},{"location":"ula-lab-4/#comecando","text":"Para n\u00e3o perdemos tempo com o git, esse lab est\u00e1 dispon\u00edvel em um novo reposit\u00f3rio, voc\u00eas podem ou clonar direto ou realizar um fork. Para come\u00e7ar a trabalhar, clone o reposit\u00f3rio para sua m\u00e1quina: cd ~ git clone https://github.com/Insper/Elementos-Lab10","title":"Come\u00e7ando"},{"location":"ula-lab-4/#lab","text":"O objetivo desse lab \u00e9 o de come\u00e7armos entender como a ULA pode ser utilizada por um programa para realizar a\u00e7\u00f5es. Em CPUs a ULA \u00e9 controlada por um bloco chamado de Unidade de Controle ( control unit ), que \u00e9 respons\u00e1vel por interpretar as instru\u00e7\u00f5es e comandar a ULA! Para isso vamos usar a ULA proposta pelo curso (a que voc\u00eas est\u00e3o fazendo) em uma arquitetura de CPU muito simples, mas que servir\u00e1 de exemplo (nosso Z01.1 n\u00e3o ser\u00e1 assim). Essa arquitetura de CPU possui uma entrada do usu\u00e1rio (que pode ser por exemplo as chaves da placa) conectada a entrada Y da ULA e uma sa\u00edda (que pode ser os LEDs) conectada a sa\u00edda (out), a entrada X \u00e9 conectada a um registrador que recebe o valor da sa\u00edda da ULA. Nessa arquitetura fict\u00edcia vamos trabalhar com o conceito de registrador acumulador, onde o resultado da ULA ser\u00e1 sempre salvo no REG_C . Note Registrador \u00e9 o termo utilizado para uma unidade simples de mem\u00f3ria capaz de armazenar apenas uma unidade de dados (nesse caso 16bits). Nesse caso, a cada opera\u00e7\u00e3o do sistema (clock) o registrador salvo o resultado da ULA. Tip O REG_C guarda um resultado da opera\u00e7\u00e3o da ULA at\u00e9 a pr\u00f3xima instru\u00e7\u00e3o O diagrama a seguir ilustra a Arquitetura descrita anteriormente:","title":"Lab"},{"location":"ula-lab-4/#control-unit","text":"A unidade de controle (UC) \u00e9 respons\u00e1vel por ler as instru\u00e7\u00f5es a serem executadas (que est\u00e3o em bin\u00e1rio) e comandar toda a CPU para executar o que deve ser feito. Nesse exemplo fict\u00edcio a UC comanda apenas a ULA, mas ela poderia controlar outras coisas tamb\u00e9m.","title":"Control Unit"},{"location":"ula-lab-4/#programa","text":"O programa nesse caso \u00e9 uma palavra de 4 bits de largura que descreve qual opera\u00e7\u00e3o deve ser realizada na CPU (linguagem de m\u00e1quina), nessa nossa CPU tempos as seguintes opera\u00e7\u00f5es definidas: Linguagem de maquina Instru\u00e7\u00e3o OP CODE 0000 REG_C = REG_C nop 0001 REG_C = 0 mov 0,C 1000 REG_C = ! REG_C not C 1001 REG_C = REG_C + 1 add 1,C 1010 REG_C = REG_C + Y add Y,C 1011 REG_C = REG_C - 1 sub 1,C Tip OP CODE \u00e9 o termo usado para descrever uma instru\u00e7\u00e3o, programas escritos em assembly fazem uso de opcodes para facilitar a programa\u00e7\u00e3o.","title":"Programa"},{"location":"ula-lab-4/#exemplo","text":"Vamos pensar em um programa muito simples que faz o seguinte: Carrega 0 em REG_C REG_C + 1 O c\u00f3digo disso (em nasm , usando os opcodes) seria: mov 0 , C add 1 , C nop Tip nop = no operation, ou seja, n\u00e3o faz nada! CPUs de forma simplificada uma CPU possui dois estados de opera\u00e7\u00e3o, ou est\u00e1 executando alguma instru\u00e7\u00e3o ou est\u00e1 dormindo. Isso n\u00e3o \u00e9 bem verdade em hardware reais, uma CPU pode estar em outros estados, tais como esperando um resultado de uma opera\u00e7\u00e3o. Note Nosso nop \u00e9 implementando pelo comando que faz sair X como resultado da ULA, assim REG_C = REG_C , ou seja, n\u00e3o faz nada! (que modifica o resultado da sa\u00edda da CPU). Para fazermos isso, temos que ter a seguinte instru\u00e7\u00e3o em mem\u00f3ria: 0: 0001 <--- O Programa come\u00e7a na linha 0 1: 1001 | e a cada 'clock' executa para pr\u00f3xima linha 2: 0000 v Legal n\u00e9? Mas para isso funcionar, a Unidade de Controle deve ser capaz de ler a instru\u00e7\u00e3o (4 bits) e controlar a ULA para executar tal comando. Nesse lab ela j\u00e1 est\u00e1 implementada com as duas instru\u00e7\u00f5es anteriores ( mov 0,C , add 1,c ). Para testar o projeto executamos o comando: ./testeLab.py . O mais interessante \u00e9 rodar com -g e verificar a forma de onda... testando ./testeLab.py","title":"Exemplo"},{"location":"ula-lab-4/#1-terminando-o-control-unit","text":"Nossa primeira atividade nesse lab ser\u00e1 a de termina de implementar a Unidade de Controle, para possuir todas as instru\u00e7\u00f5es anteriores. Uma parte dela j\u00e1 foi implementada, mas s\u00f3 possui as instru\u00e7\u00f5es: mov 0,C , add 1,C e nop , vamos implementar as demais? Para isso ser\u00e1 necess\u00e1rio modificar o arquivo /src/ControlUnit.vhd , nele \u00e9 que est\u00e1 implementando a l\u00f3gica que traduz instru\u00e7\u00f5es em execu\u00e7\u00e3o no hardware. O control unit l\u00ea o a instru\u00e7\u00e3o que est\u00e1 salva na mem\u00f3ria ( op ) e aciona a ULA ( ula ) para realizar tal opera\u00e7\u00e3o. A sa\u00edda do controlUnit ( ula out std_logic_vector ) \u00e9 um vetor composto pelos sinais de controle da ula: [ zx , nx , zy , ny , f , no ]. entity controlunit is port ( op : in std_logic_vector ( 3 downto 0 ); -- Operacao ula : out std_logic_vector ( 5 downto 0 ) -- controle da ula -- [nx zx ny zy f n] ); end entity ; architecture rtl of controlunit is begin with op select ula <= \"101010\" when \"0001\" , \"011111\" when \"1001\" , \"001100\" when others ; end architecture ; Example Quando a instru\u00e7\u00e3o for 0001 ( mov 0,C ) o controlUnit ir\u00e1 acionar a ula: zx=1 , nx=0 , zy=1 , ny=1 , f=1 , no=0 para que a sua sa\u00edda seja 0. Modifique Voc\u00ea deve inserir as instru\u00e7\u00f5es que est\u00e3o faltando serem implementadas no ControlUnit ( not C , add Y,C , sub 1,C ). Consulte a tabela de opera\u00e7\u00f5es da ULA: https://insper.github.io/Z01.1/Teoria-ULA/ Antes de testar aplique o patch a seguir para inserirmos os novos comandos no teste do lab: git apply teste2.patch !!! tip \u00e9 necess\u00e1rio adicionar as tr\u00eas linhas a seguir no controlUnit.vhd e preencher \" \" com o controle da ULA. ```diff with op select ula <= \"101010\" when \"0001\", \"011111\" when \"1001\", + \" \" when \"1000\", + \" \" when \"1010\", + \" \" when \"1011\" \"001100\" when others;","title":"1. Terminando o Control Unit"},{"location":"ula-lab-4/#2-analisando-cpu","text":"Discuta em grupo as limita\u00e7\u00f5es dessa nossa CPU, e o que poderia ser feito para melhorar: Essa CPU \u00e9 capaz de realizar qualquer tipo de c\u00e1lculo? Quais limita\u00e7\u00f5es voc\u00ea percebe nela? Temos condicionais? Como implementar .... Responda o formul\u00e1rio com a resposta do grupo ap\u00f3s discuss\u00e3o (pode ser uma resposta por grupo ou uma mais de uma, voc\u00eas que escolhem): Loading\u2026","title":"2. Analisando CPU"}]}